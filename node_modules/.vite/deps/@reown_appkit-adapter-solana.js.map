{
  "version": 3,
  "sources": ["../../@reown/appkit-adapter-solana/node_modules/base-x/src/index.js", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/node_modules/bs58/index.js", "../../@reown/appkit-adapter-solana/node_modules/@solana/errors/src/codes.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/errors/src/context.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/errors/src/messages.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/errors/src/message-formatter.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/errors/src/error.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/errors/src/stack-trace.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/errors/src/rpc-enum-errors.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/errors/src/instruction-error.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/errors/src/transaction-error.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/errors/src/json-rpc-error.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/bytes.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/codec.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/combine-codec.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/add-codec-sentinel.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/assertions.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/add-codec-size-prefix.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/fix-codec-size.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/offset-codec.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/resize-codec.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/pad-codec.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/reverse-codec.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-core/src/transform-codec.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/assertions.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/common.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/utils.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/f32.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/f64.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/i128.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/i16.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/i32.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/i64.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/i8.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/short-u16.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/u128.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/u16.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/u32.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/u64.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/codecs-numbers/src/u8.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/ed25519.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/to-buffer.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/borsh-schema.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/publickey.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/account.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/bpf-loader-deprecated.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/transaction/constants.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/transaction/expiry-custom-errors.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/message/account-keys.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/layout.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/shortvec-encoding.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/assert.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/message/compiled-keys.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/guarded-array-utils.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/message/legacy.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/message/v0.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/message/versioned.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/transaction/legacy.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/transaction/message.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/transaction/versioned.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/timing.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/sysvar.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/errors.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/send-and-confirm-transaction.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/sleep.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/instruction.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/fee-calculator.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/nonce-account.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/bigint.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/programs/system.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/loader.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/bpf-loader.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/node_modules/.pnpm/fast-stable-stringify@1.0.0/node_modules/fast-stable-stringify/index.js", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/epoch-schedule.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/__forks__/browser/fetch-impl.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/rpc-websocket.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/account-data.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/programs/address-lookup-table/state.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/makeWebsocketUrl.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/connection.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/keypair.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/programs/address-lookup-table/index.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/programs/compute-budget.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/programs/ed25519.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/secp256k1.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/programs/secp256k1.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/programs/stake.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/programs/vote.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/validator-info.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/vote-account.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/cluster.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/utils/send-and-confirm-raw-transaction.ts", "../../@reown/appkit-adapter-solana/node_modules/@solana/web3.js/src/index.ts", "../../@reown/appkit-utils/src/solana/SolanaHelpersUtils.ts", "../../@solana/wallet-adapter-base/src/errors.ts", "../../@solana/wallet-adapter-base/src/adapter.ts", "../../@solana/wallet-adapter-base/src/transaction.ts", "../../@solana/wallet-standard-features/src/signAndSendTransaction.ts", "../../@solana/wallet-standard-features/src/signMessage.ts", "../../@solana/wallet-standard-features/src/signTransaction.ts", "../../@wallet-standard/features/src/connect.ts", "../../@wallet-standard/features/src/disconnect.ts", "../../@wallet-standard/features/src/events.ts", "../../@solana/wallet-adapter-base/src/standard.ts", "../../@solana/wallet-adapter-base/src/types.ts", "../../@reown/appkit-adapter-solana/src/utils/withSolanaNamespace.ts", "../../@reown/appkit-adapter-solana/src/providers/shared/ProviderEventEmitter.ts", "../../@reown/appkit-adapter-solana/src/providers/AuthProvider.ts", "../../@reown/appkit-adapter-solana/src/providers/CoinbaseWalletProvider.ts", "../../@reown/appkit-adapter-solana/src/providers/shared/Errors.ts", "../../@reown/appkit-adapter-solana/src/providers/SolanaWalletConnectProvider.ts", "../../@reown/appkit-adapter-solana/src/utils/SolanaStoreUtil.ts", "../../@reown/appkit-adapter-solana/src/utils/createSPLTokenTransaction.ts", "../../@reown/appkit-adapter-solana/src/utils/createSendTransaction.ts", "../../@wallet-standard/app/src/wallets.ts", "../../@solana/wallet-standard-util/src/commitment.ts", "../../@solana/wallet-standard-util/src/signIn.ts", "../../@reown/appkit-adapter-solana/src/utils/chains.ts", "../../@reown/appkit-adapter-solana/src/providers/WalletStandardProvider.ts", "../../@reown/appkit-adapter-solana/src/utils/watchStandard.ts", "../../@reown/appkit-adapter-solana/src/client.ts"],
  "sourcesContent": ["'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (psz < source.length) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n", "var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n", "/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @module\n * @privateRemarks\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors — e.g. under the same package — can be a good way to namespace them. E.g. All codec-related errors start with `SOLANA_ERROR__CODECS__`.\n *   - Use consistent names — e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\nexport const SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nexport const SOLANA_ERROR__INVALID_NONCE = 2;\nexport const SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nexport const SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nexport const SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nexport const SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nexport const SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nexport const SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nexport const SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nexport const SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\n\n// JSON-RPC-related errors.\n// Reserve error codes in the range [-32768, -32000]\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/custom_error.rs\nexport const SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nexport const SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nexport const SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nexport const SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\n\n// Addresses-related errors.\n// Reserve error codes in the range [2800000-2800999].\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000;\nexport const SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nexport const SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nexport const SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nexport const SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nexport const SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nexport const SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nexport const SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\n\n// Account-related errors.\n// Reserve error codes in the range [3230000-3230999].\nexport const SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000;\nexport const SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nexport const SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\n\n// Subtle-Crypto-related errors.\n// Reserve error codes in the range [3610000-3610999].\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\n\n// Crypto-related errors.\n// Reserve error codes in the range [3611000-3611050].\nexport const SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000;\n\n// Key-related errors.\n// Reserve error codes in the range [3704000-3704999].\nexport const SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000;\nexport const SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nexport const SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nexport const SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nexport const SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\n\n// Instruction-related errors.\n// Reserve error codes in the range [4128000-4128999].\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000;\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nexport const SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\n\n// Instruction errors.\n// Reserve error codes starting with [4615000-4615999] for the Rust enum `InstructionError`.\n// Error names here are dictated by the RPC (see ./instruction-error.ts).\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\n\n// Signer-related errors.\n// Reserve error codes in the range [5508000-5508999].\nexport const SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nexport const SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\n\n// Transaction-related errors.\n// Reserve error codes in the range [5663000-5663999].\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000;\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nexport const SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nexport const SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nexport const SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nexport const SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\n\n// Transaction errors.\n// Reserve error codes starting with [7050000-7050999] for the Rust enum `TransactionError`.\n// Error names here are dictated by the RPC (see ./transaction-error.ts).\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\n// `InstructionError` intentionally omitted.\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\n\n// Codec-related errors.\n// Reserve error codes in the range [8078000-8078999].\nexport const SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000;\nexport const SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nexport const SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nexport const SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nexport const SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nexport const SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nexport const SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nexport const SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nexport const SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nexport const SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nexport const SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nexport const SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nexport const SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nexport const SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nexport const SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nexport const SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nexport const SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nexport const SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nexport const SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nexport const SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\n\n// RPC-related errors.\n// Reserve error codes in the range [8100000-8100999].\nexport const SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nexport const SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\n\n// RPC-Subscriptions-related errors.\n// Reserve error codes in the range [8190000-8190999].\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\n\n// Invariant violation errors.\n// Reserve error codes in the range [9900000-9900999].\n// These errors should only be thrown when there is a bug with the\n// library itself and should, in theory, never reach the end user.\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\n\n/**\n * A union of every Solana error code\n *\n * @privateRemarks\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like `@solana/errors`\n * is not safe, for a variety of reasons covered here: https://stackoverflow.com/a/28818850\n */\nexport type SolanaErrorCode =\n    | typeof SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND\n    | typeof SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE\n    | typeof SOLANA_ERROR__ADDRESSES__MALFORMED_PDA\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER\n    | typeof SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED\n    | typeof SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS\n    | typeof SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE\n    | typeof SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_CONSTANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS\n    | typeof SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE\n    | typeof SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES\n    | typeof SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    | typeof SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH\n    | typeof SOLANA_ERROR__INVALID_NONCE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_PARAMS\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_REQUEST\n    | typeof SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND\n    | typeof SOLANA_ERROR__JSON_RPC__PARSE_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SCAN_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION\n    | typeof SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY\n    | typeof SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__MALFORMED_BIGINT_STRING\n    | typeof SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR\n    | typeof SOLANA_ERROR__MALFORMED_NUMBER_STRING\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD\n    | typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID\n    | typeof SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING\n    | typeof SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES\n    | typeof SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE\n    | typeof SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;\n\n/**\n * Errors of this type are understood to have an optional {@link SolanaError} nested inside as\n * `cause`.\n */\nexport type SolanaErrorCodeWithCause = typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;\n", "/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @privateRemarks\n * WARNING:\n *   - Don't change or remove members of an error's context.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SolanaErrorCode,\n} from './codes';\nimport { RpcSimulateTransactionResult } from './json-rpc-error';\n\ntype BasicInstructionErrorContext<T extends SolanaErrorCode> = Readonly<{ [P in T]: { index: number } }>;\n\ntype DefaultUnspecifiedErrorContextToUndefined<T> = {\n    [P in SolanaErrorCode]: P extends keyof T ? T[P] : undefined;\n};\n\ntype TypedArrayMutableProperties = 'copyWithin' | 'fill' | 'reverse' | 'set' | 'sort';\ninterface ReadonlyUint8Array extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number;\n}\n\n/** A amount of bytes. */\ntype Bytes = number;\n\n/**\n * A map of every {@link SolanaError} code to the type of its `context` property.\n */\nexport type SolanaErrorContext = DefaultUnspecifiedErrorContextToUndefined<\n    BasicInstructionErrorContext<\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    > & {\n        [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: {\n            putativeAddress: string;\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: {\n            actual: number;\n            maxSeeds: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: {\n            actual: number;\n            index: number;\n            maxSeedLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: {\n            bump: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: {\n            currentBlockHeight: bigint;\n            lastValidBlockHeight: bigint;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: {\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: {\n            stringValues: string[];\n        };\n        [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: {\n            encodedBytes: ReadonlyUint8Array;\n            hexEncodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: {\n            decoderFixedSize: number;\n            encoderFixedSize: number;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: {\n            decoderMaxSize: number | undefined;\n            encoderMaxSize: number | undefined;\n        };\n        [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            formattedValidDiscriminators: string;\n            validDiscriminators: number[];\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: {\n            codecDescription: string;\n            expectedSize: number;\n            hexZeroValue: string;\n            zeroValue: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n            expected: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: {\n            constant: ReadonlyUint8Array;\n            data: ReadonlyUint8Array;\n            hexConstant: string;\n            hexData: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: {\n            formattedNumericalValues: string;\n            numericalValues: number[];\n            stringValues: string[];\n            variant: number | string | symbol;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: {\n            actual: bigint | number;\n            codecDescription: string;\n            expected: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: {\n            alphabet: string;\n            base: number;\n            value: string;\n        };\n        [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            maxRange: number;\n            minRange: number;\n        };\n        [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: {\n            codecDescription: string;\n            max: bigint | number;\n            min: bigint | number;\n            value: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: {\n            bytesLength: number;\n            codecDescription: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: {\n            decodedBytes: ReadonlyUint8Array;\n            hexDecodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: {\n            maxRange: number;\n            minRange: number;\n            variant: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: {\n            encodedData: string;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: {\n            code: number;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            index: number;\n            instructionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: {\n            data?: ReadonlyUint8Array;\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: {\n            accountAddresses?: string[];\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: {\n            actualProgramAddress: string;\n            expectedProgramAddress: string;\n        };\n        [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__INVALID_NONCE]: {\n            actualNonceValue: string;\n            expectedNonceValue: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: {\n            cacheKey: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: {\n            channelName: string;\n            supportedChannelNames: string[];\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: {\n            unexpectedValue: unknown;\n        };\n        [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: {\n            contextSlot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: {\n            numSlotsBehind?: number;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: Omit<\n            RpcSimulateTransactionResult,\n            'err'\n        >;\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: {\n            byteLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: {\n            error: unknown;\n            message: string;\n        };\n        [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: {\n            nonceAccountAddress: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: {\n            notificationName: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: {\n            errorEvent: Event;\n        };\n        [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: {\n            method: string;\n            params: unknown[];\n        };\n        [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: {\n            argumentLabel: string;\n            keyPath: readonly (number | string | symbol)[];\n            methodName: string;\n            optionalPathLabel: string;\n            path?: string;\n            value: bigint;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: {\n            headers: Headers;\n            message: string;\n            statusCode: number;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: {\n            headers: string[];\n        };\n        [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: {\n            key: CryptoKey;\n        };\n        [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: {\n            value: bigint;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            transactionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: {\n            expectedAddresses: string[];\n            unexpectedAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: {\n            transactionSize: Bytes;\n            transactionSizeLimit: Bytes;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: {\n            lookupTableAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: {\n            highestKnownIndex: number;\n            highestRequestedIndex: number;\n            lookupTableAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: {\n            unitsConsumed: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: {\n            numRequiredSignatures: number;\n            signaturesLength: number;\n            signerAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: {\n            actualVersion: number;\n        };\n    }\n>;\n\nexport function decodeEncodedContext(encodedContext: string): object {\n    const decodedUrlString = __NODEJS__ ? Buffer.from(encodedContext, 'base64').toString('utf8') : atob(encodedContext);\n    return Object.fromEntries(new URLSearchParams(decodedUrlString).entries());\n}\n\nfunction encodeValue(value: unknown): string {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join('%2C%20' /* \", \" */);\n        return '%5B' /* \"[\" */ + commaSeparatedValues + /* \"]\" */ '%5D';\n    } else if (typeof value === 'bigint') {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(\n            String(\n                value != null && Object.getPrototypeOf(value) === null\n                    ? // Plain objects with no prototype don't have a `toString` method.\n                      // Convert them before stringifying them.\n                      { ...(value as object) }\n                    : value,\n            ),\n        );\n    }\n}\n\nfunction encodeObjectContextEntry([key, value]: [string, unknown]): `${typeof key}=${string}` {\n    return `${key}=${encodeValue(value)}`;\n}\n\nexport function encodeContextObject(context: object): string {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join('&');\n    return __NODEJS__ ? Buffer.from(searchParamsString, 'utf8').toString('base64') : btoa(searchParamsString);\n}\n", "/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,\n    SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,\n    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,\n    SolanaErrorCode,\n} from './codes';\n\n/**\n * A map of every {@link SolanaError} code to the error message shown to developers in development\n * mode.\n */\nexport const SolanaErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `SolanaErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in SolanaErrorCode]: string;\n}> = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: 'Account not found at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]:\n        'Not all accounts were decoded. Encoded accounts found at addresses: $addresses.',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: 'Expected decoded account at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: 'Failed to decode account data at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: 'Accounts not found at addresses: $addresses',\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]:\n        'Unable to find a viable program address bump seed.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: '$putativeAddress is not a base58-encoded address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]:\n        'Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: 'The `CryptoKey` must be an `Ed25519` public key.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]:\n        '$putativeOffCurveAddress is not a base58-encoded off-curve address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: 'Invalid seeds; point must fall off the Ed25519 curve.',\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]:\n        'Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].',\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]:\n        'A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.',\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]:\n        'The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.',\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]:\n        'Expected program derived address bump to be in the range [0, 255], got: $bump.',\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: 'Program address cannot end with PDA marker.',\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]:\n        'The network has progressed past the last block for which this transaction could have been committed.',\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]:\n        'Codec [$codecDescription] cannot decode empty byte arrays.',\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]:\n        'Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.',\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]:\n        'Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]:\n        'Encoder and decoder must either both be fixed-size or variable-size.',\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.',\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: 'Expected a fixed-size codec, got a variable-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected a positive byte length, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: 'Expected a variable-size codec, got a fixed-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]:\n        'Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].',\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected $expected bytes, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]:\n        'Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].',\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]:\n        'Invalid discriminated union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]:\n        'Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.',\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]:\n        'Invalid literal union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]:\n        'Expected [$codecDescription] to have $expected items, got $actual.',\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: 'Invalid value $value for base $base with alphabet $alphabet.',\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.',\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.',\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.',\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]:\n        'Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].',\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]:\n        'Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.',\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: 'No random values implementation could be found.',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: 'instruction requires an uninitialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]:\n        'instruction tries to borrow reference for an account which is already borrowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'instruction left account with an outstanding borrowed reference',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]:\n        \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: 'account data too small for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: 'instruction expected an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]:\n        'An account does not have enough lamports to be rent-exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: 'Program arithmetic overflowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: 'Failed to serialize or deserialize account data: $encodedData',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]:\n        'Builtin programs must consume compute units',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: 'Cross-program invocation call depth too deep',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: 'Computational budget exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: 'custom program error: #$code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: 'instruction contains duplicate accounts',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]:\n        'instruction modifications of multiply-passed account differ',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: 'executable accounts must be rent exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: 'instruction changed executable accounts data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]:\n        'instruction changed the balance of an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: 'instruction changed executable bit of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]:\n        'instruction modified data of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]:\n        'instruction spent from the balance of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: 'generic instruction error',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: 'Provided owner is not allowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: 'Account is immutable',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: 'Incorrect authority provided',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: 'incorrect program id for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: 'insufficient funds for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: 'invalid account data for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: 'Invalid account owner',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: 'invalid program argument',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: 'program returned invalid error code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: 'invalid instruction data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: 'Failed to reallocate account data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: 'Provided seeds do not result in a valid address',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]:\n        'Accounts data allocations exceeded the maximum allowed per transaction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: 'Max accounts exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: 'Max instruction trace length exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]:\n        'Length of the seed is too long for address generation',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: 'An account required by the instruction is missing',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: 'missing required signature for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]:\n        'instruction illegally modified the program id of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: 'insufficient account keys for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]:\n        'Cross-program invocation with unauthorized signer or writable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]:\n        'Failed to create program execution environment',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: 'Program failed to compile',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: 'Program failed to complete',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: 'instruction modified data of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]:\n        'instruction changed the balance of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]:\n        'Cross-program invocation reentrancy not allowed for this instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: 'instruction modified rent epoch of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]:\n        'sum of account balances before and after instruction do not match',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: 'instruction requires an initialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: '',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: 'Unsupported program id',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: 'Unsupported sysvar',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: 'The instruction does not have any accounts.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: 'The instruction does not have any data.',\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]:\n        'Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.',\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]:\n        'Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__INVALID_NONCE]:\n        'The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]:\n        'Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It ' +\n        'should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]:\n        'Invariant violation: This data publisher does not publish to the channel named ' +\n        '`$channelName`. Supported channels include $supportedChannelNames.',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]:\n        'Invariant violation: WebSocket message iterator state is corrupt; iterated without first ' +\n        'resolving existing message promise. It should be impossible to hit this error; please ' +\n        'file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]:\n        'Invariant violation: WebSocket message iterator is missing state storage. It should be ' +\n        'impossible to hit this error; please file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]:\n        'Invariant violation: Switch statement non-exhaustive. Received unexpected value ' +\n        '`$unexpectedValue`. It should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: 'JSON-RPC error: Internal JSON-RPC error ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: 'JSON-RPC error: Invalid method parameter(s) ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]:\n        'JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]:\n        'JSON-RPC error: The method does not exist / is not available ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]:\n        'JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: 'Minimum context slot has not been reached',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: 'Node is unhealthy; behind by $numSlotsBehind slots',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: 'No snapshot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: 'Transaction simulation failed',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]:\n        'Transaction history is not available from this node',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: 'Transaction signature length mismatch',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]:\n        'Transaction signature verification failure',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: '$__serverMessage',\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: 'Key pair bytes must be of length 64, got $byteLength.',\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]:\n        'Expected private key bytes with length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]:\n        'Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]:\n        'The provided private key does not match the provided public key.',\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.',\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: 'Lamports value must be in the range [0, 2e64-1]',\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: '`$value` cannot be parsed as a `BigInt`',\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: '$message',\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: '`$value` cannot be parsed as a `Number`',\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: 'No nonce account could be found at address `$nonceAccountAddress`',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]:\n        \"The notification name must end in 'Notifications' and the API must supply a \" +\n        \"subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]:\n        'WebSocket was closed before payload could be added to the send buffer',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: 'WebSocket connection closed',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: 'WebSocket failed to connect',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]:\n        'Failed to obtain a subscription id from the server',\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: 'Could not find an API plan for RPC method: `$method`',\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]:\n        'The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was ' +\n        '`$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds ' +\n        '`Number.MAX_SAFE_INTEGER`.',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: 'HTTP error ($statusCode): $message',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]:\n        'HTTP header(s) forbidden: $headers. Learn more at ' +\n        'https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.',\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]:\n        'Multiple distinct signers were identified for address `$address`. Please ensure that ' +\n        'you are using the same signer instance for each address.',\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]:\n        'The provided value does not implement the `KeyPairSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]:\n        'The provided value does not implement the `MessageModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]:\n        'The provided value does not implement the `MessagePartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]:\n        'The provided value does not implement any of the `MessageSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]:\n        'The provided value does not implement the `TransactionModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]:\n        'The provided value does not implement the `TransactionPartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]:\n        'The provided value does not implement the `TransactionSendingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]:\n        'The provided value does not implement any of the `TransactionSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]:\n        'More than one `TransactionSendingSigner` was identified.',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]:\n        'No `TransactionSendingSigner` was identified. Please provide a valid ' +\n        '`TransactionWithSingleSendingSigner` transaction.',\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]:\n        'Wallet account signers do not support signing multiple messages/transactions in a single operation',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: 'Cannot export a non-extractable key.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: 'No digest implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]:\n        'Cryptographic operations are only allowed in secure browser contexts. Read more ' +\n        'here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]:\n        'This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall ' +\n        '@solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in ' +\n        'environments that do not support Ed25519.\\n\\nFor a list of runtimes that ' +\n        'currently support Ed25519 operations, visit ' +\n        'https://github.com/WICG/webcrypto-secure-curves/issues/20.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]:\n        'No signature verification implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: 'No key generation implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: 'No signing implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: 'No key export implementation could be found.',\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]:\n        'Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'Transaction processing left an account with an outstanding borrowed reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: 'Account in use',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: 'Account loaded twice',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]:\n        'Attempt to debit an account but found no record of a prior credit.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]:\n        \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: 'This transaction has already been processed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: 'Blockhash not found',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: 'Loader call chain is too deep',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]:\n        'Transactions are currently disabled due to cluster maintenance',\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]:\n        'Transaction contains a duplicate instruction ($index) that is not allowed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: 'Insufficient funds for fee',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]:\n        'Transaction results in an account ($accountIndex) with insufficient funds for rent',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: 'This account may not be used to pay transaction fees',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: 'Transaction contains an invalid account reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]:\n        'Transaction loads an address table account with invalid data',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]:\n        'Transaction address table lookup uses an invalid index',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]:\n        'Transaction loads an address table account with an invalid owner',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]:\n        'LoadedAccountsDataSizeLimit set for transaction must be greater than 0.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]:\n        'This program may not be used for executing instructions',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]:\n        'Transaction leaves an account with a lower balance than rent-exempt minimum',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]:\n        'Transaction loads a writable account that cannot be written',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]:\n        'Transaction exceeded max loaded accounts data size cap',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]:\n        'Transaction requires a fee but has no signature present',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: 'Attempt to load a program that does not exist',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]:\n        'Execution of the program referenced by account at index $accountIndex is temporarily restricted.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: 'ResanitizationNeeded',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: 'Transaction failed to sanitize accounts offsets correctly',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: 'Transaction did not pass signature verification',\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: 'Transaction locked too many accounts',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]:\n        'Sum of account balances before and after transaction do not match',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: 'The transaction failed with the error `$errorName`',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: 'Transaction version is unsupported',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]:\n        'Transaction would exceed account data limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]:\n        'Transaction would exceed total account data limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]:\n        'Transaction would exceed max account limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]:\n        'Transaction would exceed max Block Cost Limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: 'Transaction would exceed max Vote Cost Limit',\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]:\n        'Attempted to sign a transaction with an address that is not a signer for it',\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: 'Transaction is missing an address at index: $index.',\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]:\n        'Transaction has no expected signers therefore it cannot be encoded',\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]:\n        'Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: 'Transaction does not have a blockhash lifetime',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: 'Transaction is not a durable nonce transaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]:\n        'Contents of these address lookup tables unknown: $lookupTableAddresses',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]:\n        'Lookup of address at index $highestRequestedIndex failed for lookup table ' +\n        '`$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table ' +\n        'may have been extended since its contents were retrieved',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: 'No fee payer set in CompiledTransaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]:\n        'Could not find program address at index $index',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Failed to estimate the compute unit consumption for this transaction message. This is ' +\n        'likely because simulating the transaction failed. Inspect the `cause` property of this ' +\n        'error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Transaction failed when it was simulated in order to estimate the compute unit consumption. ' +\n        'The compute unit estimate provided is for a transaction that failed when simulated and may not ' +\n        'be representative of the compute units this transaction would consume if successful. Inspect the ' +\n        '`cause` property of this error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: 'Transaction is missing a fee payer.',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]:\n        \"Could not determine this transaction's signature. Make sure that the transaction has \" +\n        'been signed by its fee payer.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]:\n        'Transaction first instruction is not advance nonce account instruction.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]:\n        'Transaction with no instructions cannot be durable nonce transaction.',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]:\n        'This transaction includes an address (`$programAddress`) which is both ' +\n        'invoked and set as the fee payer. Program addresses may not pay fees',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]:\n        'This transaction includes an address (`$programAddress`) which is both invoked and ' +\n        'marked writable. Program addresses may not be writable',\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]:\n        'The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.',\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: 'Transaction is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]:\n        'Transaction version must be in the range [0, 127]. `$actualVersion` given',\n};\n", "import { SolanaErrorCode } from './codes';\nimport { encodeContextObject } from './context';\nimport { SolanaErrorMessages } from './messages';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: object = {},\n): string {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n\n            fragments.push(\n                variableName in context\n                    ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                      `${context[variableName as keyof typeof context]}`\n                    : `$${variableName}`,\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: Record<string, unknown> = {},\n): string {\n    if (process.env.NODE_ENV !== \"production\") {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n", "import { SolanaErrorCode, SolanaErrorCodeWithCause } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { getErrorMessage } from './message-formatter';\n\n/**\n * A type guard that returns `true` if the input is a {@link SolanaError}, optionally with a\n * particular error code.\n *\n * When the `code` argument is supplied and the input is a {@link SolanaError}, TypeScript will\n * refine the error's {@link SolanaError#context | `context`} property to the type associated with\n * that error code. You can use that context to render useful error messages, or to make\n * context-aware decisions that help your application to recover from the error.\n *\n * @example\n * ```ts\n * import {\n *     SOLANA_ERROR__TRANSACTION__MISSING_SIGNATURE,\n *     SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n *     isSolanaError,\n * } from '@solana/errors';\n * import { assertIsFullySignedTransaction, getSignatureFromTransaction } from '@solana/transactions';\n *\n * try {\n *     const transactionSignature = getSignatureFromTransaction(tx);\n *     assertIsFullySignedTransaction(tx);\n *     /* ... *\\/\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         displayError(\n *             \"We can't send this transaction without signatures for these addresses:\\n- %s\",\n *             // The type of the `context` object is now refined to contain `addresses`.\n *             e.context.addresses.join('\\n- '),\n *         );\n *         return;\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING)) {\n *         if (!tx.feePayer) {\n *             displayError('Choose a fee payer for this transaction before sending it');\n *         } else {\n *             displayError('The fee payer still needs to sign for this transaction');\n *         }\n *         return;\n *     }\n *     throw e;\n * }\n * ```\n */\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    /**\n     * When supplied, this function will require that the input is a {@link SolanaError} _and_ that\n     * its error code is exactly this value.\n     */\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode> {\n    const isSolanaError = e instanceof Error && e.name === 'SolanaError';\n    if (isSolanaError) {\n        if (code !== undefined) {\n            return (e as SolanaError<TErrorCode>).context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\n\ntype SolanaErrorCodedContext = Readonly<{\n    [P in SolanaErrorCode]: (SolanaErrorContext[P] extends undefined ? object : SolanaErrorContext[P]) & {\n        __code: P;\n    };\n}>;\n\n/**\n * Encapsulates an error's stacktrace, a Solana-specific numeric code that indicates what went\n * wrong, and optional context if the type of error indicated by the code supports it.\n */\nexport class SolanaError<TErrorCode extends SolanaErrorCode = SolanaErrorCode> extends Error {\n    /**\n     * Indicates the root cause of this {@link SolanaError}, if any.\n     *\n     * For example, a transaction error might have an instruction error as its root cause. In this\n     * case, you will be able to access the instruction error on the transaction error as `cause`.\n     */\n    readonly cause?: TErrorCode extends SolanaErrorCodeWithCause ? SolanaError : unknown = this.cause;\n    /**\n     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n     */\n    readonly context: SolanaErrorCodedContext[TErrorCode];\n    constructor(\n        ...[code, contextAndErrorOptions]: SolanaErrorContext[TErrorCode] extends undefined\n            ? [code: TErrorCode, errorOptions?: ErrorOptions | undefined]\n            : [code: TErrorCode, contextAndErrorOptions: SolanaErrorContext[TErrorCode] & (ErrorOptions | undefined)]\n    ) {\n        let context: SolanaErrorContext[TErrorCode] | undefined;\n        let errorOptions: ErrorOptions | undefined;\n        if (contextAndErrorOptions) {\n            // If the `ErrorOptions` type ever changes, update this code.\n            const { cause, ...contextRest } = contextAndErrorOptions;\n            if (cause) {\n                errorOptions = { cause };\n            }\n            if (Object.keys(contextRest).length > 0) {\n                context = contextRest as SolanaErrorContext[TErrorCode];\n            }\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = {\n            __code: code,\n            ...context,\n        } as SolanaErrorCodedContext[TErrorCode];\n        // This is necessary so that `isSolanaError()` can identify a `SolanaError` without having\n        // to import the class for use in an `instanceof` check.\n        this.name = 'SolanaError';\n    }\n}\n", "export function safeCaptureStackTrace(...args: Parameters<typeof Error.captureStackTrace>): void {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n", "import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\n\ntype Config = Readonly<{\n    /**\n     * Oh, hello. You might wonder what in tarnation is going on here. Allow us to explain.\n     *\n     * One of the goals of `@solana/errors` is to allow errors that are not interesting to your\n     * application to shake out of your app bundle in production. This means that we must never\n     * export large hardcoded maps of error codes/messages.\n     *\n     * Unfortunately, where instruction and transaction errors from the RPC are concerned, we have\n     * no choice but to keep a map between the RPC `rpcEnumError` enum name and its corresponding\n     * `SolanaError` code. In the interest of implementing that map in as few bytes of source code\n     * as possible, we do the following:\n     *\n     *   1. Reserve a block of sequential error codes for the enum in question\n     *   2. Hardcode the list of enum names in that same order\n     *   3. Match the enum error name from the RPC with its index in that list, and reconstruct the\n     *      `SolanaError` code by adding the `errorCodeBaseOffset` to that index\n     */\n    errorCodeBaseOffset: number;\n    getErrorContext: (\n        errorCode: SolanaErrorCode,\n        rpcErrorName: string,\n        rpcErrorContext?: unknown,\n    ) => SolanaErrorContext[SolanaErrorCode];\n    orderedErrorNames: string[];\n    rpcEnumError: string | { [key: string]: unknown };\n}>;\n\nexport function getSolanaErrorFromRpcError(\n    { errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }: Config,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    constructorOpt: Function,\n): SolanaError {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === 'string') {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = (errorCodeBaseOffset + codeOffset) as SolanaErrorCode;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n", "import {\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'GenericError',\n    'InvalidArgument',\n    'InvalidInstructionData',\n    'InvalidAccountData',\n    'AccountDataTooSmall',\n    'InsufficientFunds',\n    'IncorrectProgramId',\n    'MissingRequiredSignature',\n    'AccountAlreadyInitialized',\n    'UninitializedAccount',\n    'UnbalancedInstruction',\n    'ModifiedProgramId',\n    'ExternalAccountLamportSpend',\n    'ExternalAccountDataModified',\n    'ReadonlyLamportChange',\n    'ReadonlyDataModified',\n    'DuplicateAccountIndex',\n    'ExecutableModified',\n    'RentEpochModified',\n    'NotEnoughAccountKeys',\n    'AccountDataSizeChanged',\n    'AccountNotExecutable',\n    'AccountBorrowFailed',\n    'AccountBorrowOutstanding',\n    'DuplicateAccountOutOfSync',\n    'Custom',\n    'InvalidError',\n    'ExecutableDataModified',\n    'ExecutableLamportChange',\n    'ExecutableAccountNotRentExempt',\n    'UnsupportedProgramId',\n    'CallDepth',\n    'MissingAccount',\n    'ReentrancyNotAllowed',\n    'MaxSeedLengthExceeded',\n    'InvalidSeeds',\n    'InvalidRealloc',\n    'ComputationalBudgetExceeded',\n    'PrivilegeEscalation',\n    'ProgramEnvironmentSetupFailure',\n    'ProgramFailedToComplete',\n    'ProgramFailedToCompile',\n    'Immutable',\n    'IncorrectAuthority',\n    'BorshIoError',\n    'AccountNotRentExempt',\n    'InvalidAccountOwner',\n    'ArithmeticOverflow',\n    'UnsupportedSysvar',\n    'IllegalOwner',\n    'MaxAccountsDataAllocationsExceeded',\n    'MaxAccountsExceeded',\n    'MaxInstructionTraceLengthExceeded',\n    'BuiltinProgramsMustConsumeComputeUnits',\n];\n\nexport function getSolanaErrorFromInstructionError(\n    /**\n     * The index of the instruction inside the transaction.\n     */\n    index: bigint | number,\n    instructionError: string | { [key: string]: unknown },\n): SolanaError {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 4615001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        index: numberIndex,\n                        ...(rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                    return {\n                        code: Number(rpcErrorContext as bigint | number),\n                        index: numberIndex,\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                    return {\n                        encodedData: rpcErrorContext as string,\n                        index: numberIndex,\n                    };\n                }\n                return { index: numberIndex };\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: instructionError,\n        },\n        getSolanaErrorFromInstructionError,\n    );\n}\n", "import {\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromInstructionError } from './instruction-error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\n/**\n * How to add an error when an entry is added to the RPC `TransactionError` enum:\n *\n *   1. Follow the instructions in `./codes.ts` to add a corresponding Solana error code\n *   2. Add the `TransactionError` enum name in the same order as it appears in `./codes.ts`\n *   3. Add the new error name/code mapping to `./__tests__/transaction-error-test.ts`\n */\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'AccountInUse',\n    'AccountLoadedTwice',\n    'AccountNotFound',\n    'ProgramAccountNotFound',\n    'InsufficientFundsForFee',\n    'InvalidAccountForFee',\n    'AlreadyProcessed',\n    'BlockhashNotFound',\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    'CallChainTooDeep',\n    'MissingSignatureForFee',\n    'InvalidAccountIndex',\n    'SignatureFailure',\n    'InvalidProgramForExecution',\n    'SanitizeFailure',\n    'ClusterMaintenance',\n    'AccountBorrowOutstanding',\n    'WouldExceedMaxBlockCostLimit',\n    'UnsupportedVersion',\n    'InvalidWritableAccount',\n    'WouldExceedMaxAccountCostLimit',\n    'WouldExceedAccountDataBlockLimit',\n    'TooManyAccountLocks',\n    'AddressLookupTableNotFound',\n    'InvalidAddressLookupTableOwner',\n    'InvalidAddressLookupTableData',\n    'InvalidAddressLookupTableIndex',\n    'InvalidRentPayingAccount',\n    'WouldExceedMaxVoteCostLimit',\n    'WouldExceedAccountDataTotalLimit',\n    'DuplicateInstruction',\n    'InsufficientFundsForRent',\n    'MaxLoadedAccountsDataSizeExceeded',\n    'InvalidLoadedAccountsDataSizeLimit',\n    'ResanitizationNeeded',\n    'ProgramExecutionTemporarilyRestricted',\n    'UnbalancedTransaction',\n];\n\nexport function getSolanaErrorFromTransactionError(transactionError: string | { [key: string]: unknown }): SolanaError {\n    if (typeof transactionError === 'object' && 'InstructionError' in transactionError) {\n        return getSolanaErrorFromInstructionError(\n            ...(transactionError.InstructionError as Parameters<typeof getSolanaErrorFromInstructionError>),\n        );\n    }\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 7050001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        ...(rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                    return {\n                        index: Number(rpcErrorContext as bigint | number),\n                    };\n                } else if (\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT ||\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n                ) {\n                    return {\n                        accountIndex: Number((rpcErrorContext as { account_index: bigint | number }).account_index),\n                    };\n                }\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: transactionError,\n        },\n        getSolanaErrorFromTransactionError,\n    );\n}\n", "import {\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SolanaErrorCode,\n} from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\nimport { getSolanaErrorFromTransactionError } from './transaction-error';\n\ninterface RpcErrorResponse {\n    code: bigint | number;\n    data?: unknown;\n    message: string;\n}\n\ntype TransactionError = string | { [key: string]: unknown };\n\n/**\n * Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-types/src/response.rs\n * @hidden\n */\nexport interface RpcSimulateTransactionResult {\n    accounts:\n        | ({\n              data:\n                  | string // LegacyBinary\n                  | {\n                        // Json\n                        parsed: unknown;\n                        program: string;\n                        space: number;\n                    }\n                  // Binary\n                  | [encodedBytes: string, encoding: 'base58' | 'base64' | 'base64+zstd' | 'binary' | 'jsonParsed'];\n              executable: boolean;\n              lamports: number;\n              owner: string;\n              rentEpoch: number;\n              space?: number;\n          } | null)[]\n        | null;\n    err: TransactionError | null;\n    // Enabled by `enable_cpi_recording`\n    innerInstructions?:\n        | {\n              index: number;\n              instructions: (\n                  | {\n                        // Compiled\n                        accounts: number[];\n                        data: string;\n                        programIdIndex: number;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // Parsed\n                        parsed: unknown;\n                        program: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // PartiallyDecoded\n                        accounts: string[];\n                        data: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n              )[];\n          }[]\n        | null;\n    logs: string[] | null;\n    replacementBlockhash: string | null;\n    returnData: {\n        data: [string, 'base64'];\n        programId: string;\n    } | null;\n    unitsConsumed: bigint | null;\n}\n\nexport function getSolanaErrorFromJsonRpcError(putativeErrorResponse: unknown): SolanaError {\n    let out: SolanaError;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data as RpcSimulateTransactionResult;\n            const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject,\n            });\n        } else {\n            let errorContext;\n            switch (code) {\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    // The server supplies no structured data, but rather a pre-formatted message. Put\n                    // the server message in `context` so as not to completely lose the data. The long\n                    // term fix for this is to add data to the server responses and modify the\n                    // messages in `@solana/errors` to be actual format strings.\n                    errorContext = { __serverMessage: message };\n                    break;\n                default:\n                    if (typeof data === 'object' && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code as SolanaErrorCode, errorContext as SolanaErrorContext[SolanaErrorCode]);\n        }\n    } else {\n        const message =\n            typeof putativeErrorResponse === 'object' &&\n            putativeErrorResponse !== null &&\n            'message' in putativeErrorResponse &&\n            typeof putativeErrorResponse.message === 'string'\n                ? putativeErrorResponse.message\n                : 'Malformed JSON-RPC error with no message attribute';\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, { error: putativeErrorResponse, message });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\n\nfunction isRpcErrorResponse(value: unknown): value is RpcErrorResponse {\n    return (\n        typeof value === 'object' &&\n        value !== null &&\n        'code' in value &&\n        'message' in value &&\n        (typeof value.code === 'number' || typeof value.code === 'bigint') &&\n        typeof value.message === 'string'\n    );\n}\n", "import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n *\n * @param byteArrays - The array of byte arrays to concatenate.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02]);\n * const bytes2 = new Uint8Array([]);\n * const bytes3 = new Uint8Array([0x03, 0x04]);\n * const bytes = mergeBytes([bytes1, bytes2, bytes3]);\n * //    ^ [0x01, 0x02, 0x03, 0x04]\n * ```\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n *\n * @param bytes - The byte array to pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 2);\n * // bytes === paddedBytes\n * ```\n */\nexport const padBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n *\n * @param bytes - The byte array to truncate or pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Truncates the byte array to the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const fixedBytes = fixBytes(bytes, 2);\n * //    ^ [0x01, 0x02]\n * ```\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 2);\n * // bytes === fixedBytes\n * ```\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n *\n * @param data - The byte sequence to search for.\n * @param bytes - The byte array in which to search for `data`.\n * @param offset - The position in `bytes` where the search begins.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const data = new Uint8Array([0x02, 0x03]);\n * containsBytes(bytes, data, 1); // true\n * containsBytes(bytes, data, 2); // false\n * ```\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n", "import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * This is a common interface for {@link FixedSizeEncoder} and {@link VariableSizeEncoder}.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n */\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a fixed-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const encoder: FixedSizeEncoder<number, 4>;\n * const bytes = encoder.encode(42);\n * const size = encoder.fixedSize; // 4\n * ```\n *\n * @see {@link Encoder}\n * @see {@link VariableSizeEncoder}\n */\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a variable-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * ```ts\n * const encoder: VariableSizeEncoder<string>;\n * const bytes = encoder.encode('hello');\n * const size = encoder.getSizeFromValue('hello');\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n */\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** Returns the size of the encoded value in bytes for a given input. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * An `Encoder` can be either:\n * - A {@link FixedSizeEncoder}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeEncoder}, where encoded values can vary in size.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * Encoding a value into a new byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = encoder.encode('hello');\n * ```\n *\n * @example\n * Writing the encoded value into an existing byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = new Uint8Array(100);\n * const nextOffset = encoder.write('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Encoders` manually using the {@link createEncoder} function but it is more common\n * to compose multiple `Encoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Encoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructEncoder, addEncoderSizePrefix, getUtf8Encoder, getU32Encoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonEncoder = (): Encoder<Person> =>\n *     getStructEncoder([\n *         ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *         ['age', getU32Encoder()],\n *     ]);\n * ```\n *\n * Note that composed `Encoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Encoder()` is\n * a fixed-size encoder, while `addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())`\n * is a variable-size encoder. This makes the final `Person` encoder a variable-size encoder.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link createEncoder}\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * This is a common interface for {@link FixedSizeDecoder} and {@link VariableSizeDecoder}.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n */\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\n/**\n * An object that can decode a fixed-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const decoder: FixedSizeDecoder<number, 4>;\n * const value = decoder.decode(bytes);\n * const size = decoder.fixedSize; // 4\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can decode a variable-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const decoder: VariableSizeDecoder<number>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * An `Decoder` can be either:\n * - A {@link FixedSizeDecoder}, where all byte arrays have the same fixed size.\n * - A {@link VariableSizeDecoder}, where byte arrays can vary in size.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * Getting the decoded value from a byte array.\n * ```ts\n * const decoder: Decoder<string>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @example\n * Reading the decoded value from a byte array at a specific offset\n * and getting the offset of the next byte to read.\n * ```ts\n * const decoder: Decoder<string>;\n * const [value, nextOffset] = decoder.read('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Decoders` manually using the {@link createDecoder} function but it is more common\n * to compose multiple `Decoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Decoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructDecoder, addDecoderSizePrefix, getUtf8Decoder, getU32Decoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonDecoder = (): Decoder<Person> =>\n *     getStructDecoder([\n *         ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *         ['age', getU32Decoder()],\n *     ]);\n * ```\n *\n * Note that composed `Decoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Decoder()` is\n * a fixed-size decoder, while `addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())`\n * is a variable-size decoder. This makes the final `Person` decoder a variable-size decoder.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link createDecoder}\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\n/**\n * An object that can encode and decode a value to and from a fixed-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const codec: FixedSizeCodec<number | bigint, bigint, 8>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.fixedSize; // 8\n * ```\n *\n * @see {@link Codec}\n * @see {@link VariableSizeCodec}\n */\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\n/**\n * An object that can encode and decode a value to and from a variable-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec: VariableSizeCodec<number | bigint, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.getSizeFromValue(42);\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n */\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a byte array.\n *\n * A `Codec` can be either:\n * - A {@link FixedSizeCodec}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeCodec}, where encoded values can vary in size.\n *\n * @example\n * ```ts\n * const codec: Codec<string>;\n * const bytes = codec.encode('hello');\n * const value = codec.decode(bytes); // 'hello'\n * ```\n *\n * @remarks\n * For convenience, codecs can encode looser types than they decode.\n * That is, type {@link TFrom} can be a superset of type {@link TTo}.\n * For instance, a `Codec<bigint | number, bigint>` can encode both\n * `bigint` and `number` values, but will always decode to a `bigint`.\n *\n * ```ts\n * const codec: Codec<bigint | number, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * It is worth noting that codecs are the union of encoders and decoders.\n * This means that a `Codec<TFrom, TTo>` can be combined from an `Encoder<TFrom>`\n * and a `Decoder<TTo>` using the {@link combineCodec} function. This is particularly\n * useful for library authors who want to expose all three types of objects to their users.\n *\n * ```ts\n * const encoder: Encoder<bigint | number>;\n * const decoder: Decoder<bigint>;\n * const codec: Codec<bigint | number, bigint> = combineCodec(encoder, decoder);\n * ```\n *\n * Aside from combining encoders and decoders, codecs can also be created from scratch using\n * the {@link createCodec} function but it is more common to compose multiple codecs together\n * using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create a `Codec` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructCodec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonCodec = (): Codec<Person> =>\n *     getStructCodec([\n *         ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *         ['age', getU32Codec()],\n *     ]);\n * ```\n *\n * Note that composed `Codec` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Codec()` is\n * a fixed-size codec, while `addCodecSizePrefix(getUtf8Codec(), getU32Codec())`\n * is a variable-size codec. This makes the final `Person` codec a variable-size codec.\n *\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link combineCodec}\n * @see {@link createCodec}\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Gets the encoded size of a given value in bytes using the provided encoder.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @param value - The value to be encoded.\n * @param encoder - The encoder used to determine the encoded size.\n * @returns The size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const fixedSizeEncoder = { fixedSize: 4 };\n * getEncodedSize(123, fixedSizeEncoder); // Returns 4.\n *\n * const variableSizeEncoder = { getSizeFromValue: (value: string) => value.length };\n * getEncodedSize(\"hello\", variableSizeEncoder); // Returns 5.\n * ```\n *\n * @see {@link Encoder}\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/**\n * Creates an `Encoder` by filling in the missing `encode` function using the provided `write` function and\n * either the `fixedSize` property (for {@link FixedSizeEncoder | FixedSizeEncoders}) or\n * the `getSizeFromValue` function (for {@link VariableSizeEncoder | VariableSizeEncoders}).\n *\n * Instead of manually implementing `encode`, this utility leverages the existing `write` function\n * and the size helpers to generate a complete encoder. The provided `encode` method will allocate\n * a new `Uint8Array` of the correct size and use `write` to populate it.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size encoders).\n *\n * @param encoder - An encoder object that implements `write`, but not `encode`.\n * - If the encoder has a `fixedSize` property, it is treated as a {@link FixedSizeEncoder}.\n * - Otherwise, it is treated as a {@link VariableSizeEncoder}.\n *\n * @returns A fully functional `Encoder` with both `write` and `encode` methods.\n *\n * @example\n * Creating a custom fixed-size encoder.\n * ```ts\n * const encoder = createEncoder({\n *     fixedSize: 4,\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n * ```\n *\n * @example\n * Creating a custom variable-size encoder:\n * ```ts\n * const encoder = createEncoder({\n *     getSizeFromValue: (value: string) => value.length,\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = encoder.encode(\"hello\");\n * // 0x68656c6c6f\n * ```\n *\n * @remarks\n * Note that, while `createEncoder` is useful for defining more complex encoders, it is more common to compose\n * encoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createEncoder`.\n *\n * ```ts\n * // Fixed-size encoder for unsigned 32-bit integers.\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n *\n * // Variable-size encoder for 32-bytes prefixed UTF-8 strings.\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const bytes = encoder.encode(\"hello\");\n * // 0x0500000068656c6c6f\n *\n * // Variable-size encoder for custom objects.\n * type Person = { name: string; age: number };\n * const encoder: Encoder<Person> = getStructEncoder([\n *     ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *     ['age', getU32Encoder()],\n * ]);\n * const bytes = encoder.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link getStructEncoder}\n * @see {@link getU32Encoder}\n * @see {@link getUtf8Encoder}\n * @see {@link addEncoderSizePrefix}\n */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Creates a `Decoder` by filling in the missing `decode` function using the provided `read` function.\n *\n * Instead of manually implementing `decode`, this utility leverages the existing `read` function\n * and the size properties to generate a complete decoder. The provided `decode` method will read\n * from a `Uint8Array` at the given offset and return the decoded value.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeDecoder} will be created, otherwise\n * a {@link VariableSizeDecoder} will be created.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size decoders).\n *\n * @param decoder - A decoder object that implements `read`, but not `decode`.\n * - If the decoder has a `fixedSize` property, it is treated as a {@link FixedSizeDecoder}.\n * - Otherwise, it is treated as a {@link VariableSizeDecoder}.\n *\n * @returns A fully functional `Decoder` with both `read` and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size decoder.\n * ```ts\n * const decoder = createDecoder({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size decoder:\n * ```ts\n * const decoder = createDecoder({\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([104, 101, 108, 108, 111]));\n * // \"hello\"\n * ```\n *\n * @remarks\n * Note that, while `createDecoder` is useful for defining more complex decoders, it is more common to compose\n * decoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createDecoder`.\n *\n * ```ts\n * // Fixed-size decoder for unsigned 32-bit integers.\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n *\n * // Variable-size decoder for 32-bytes prefixed UTF-8 strings.\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const value = decoder.decode(new Uint8Array([5, 0, 0, 0, 104, 101, 108, 108, 111]));\n * // \"hello\"\n *\n * // Variable-size decoder for custom objects.\n * type Person = { name: string; age: number };\n * const decoder: Decoder<Person> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n * const value = decoder.decode(new Uint8Array([3, 0, 0, 0, 66, 111, 98, 42, 0, 0, 0]));\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Decoder}\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link getStructDecoder}\n * @see {@link getU32Decoder}\n * @see {@link getUtf8Decoder}\n * @see {@link addDecoderSizePrefix}\n */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/**\n * Creates a `Codec` by filling in the missing `encode` and `decode` functions using the provided `write` and `read` functions.\n *\n * This utility combines the behavior of {@link createEncoder} and {@link createDecoder} to produce a fully functional `Codec`.\n * The `encode` method is derived from the `write` function, while the `decode` method is derived from the `read` function.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeCodec} will be created, otherwise\n * a {@link VariableSizeCodec} will be created.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param codec - A codec object that implements `write` and `read`, but not `encode` or `decode`.\n * - If the codec has a `fixedSize` property, it is treated as a {@link FixedSizeCodec}.\n * - Otherwise, it is treated as a {@link VariableSizeCodec}.\n *\n * @returns A fully functional `Codec` with `write`, `read`, `encode`, and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size codec.\n * ```ts\n * const codec = createCodec({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size codec:\n * ```ts\n * const codec = createCodec({\n *     getSizeFromValue: (value: string) => value.length,\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = codec.encode(\"hello\");\n * // 0x68656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n * ```\n *\n * @remarks\n * This function effectively combines the behavior of {@link createEncoder} and {@link createDecoder}.\n * If you only need to encode or decode (but not both), consider using those functions instead.\n *\n * Here are some alternative examples using codec primitives instead of `createCodec`.\n *\n * ```ts\n * // Fixed-size codec for unsigned 32-bit integers.\n * const codec = getU32Codec();\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n *\n * // Variable-size codec for 32-bytes prefixed UTF-8 strings.\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const bytes = codec.encode(\"hello\");\n * // 0x0500000068656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n *\n * // Variable-size codec for custom objects.\n * type Person = { name: string; age: number };\n * const codec: Codec<PersonInput, Person> = getStructCodec([\n *     ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *     ['age', getU32Codec()],\n * ]);\n * const bytes = codec.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * const value = codec.decode(bytes);\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link createEncoder}\n * @see {@link createDecoder}\n * @see {@link getStructCodec}\n * @see {@link getU32Codec}\n * @see {@link getUtf8Codec}\n * @see {@link addCodecSizePrefix}\n */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is fixed-size.\n *\n * A fixed-size object is identified by the presence of a `fixedSize` property.\n * If this property exists, the object is considered a {@link FixedSizeCodec},\n * {@link FixedSizeEncoder}, or {@link FixedSizeDecoder}.\n * Otherwise, it is assumed to be a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is fixed-size, `false` otherwise.\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isFixedSize(encoder); // true\n * ```\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isFixedSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is commonly used to distinguish between fixed-size and variable-size objects at runtime.\n * If you need to enforce this distinction with type assertions, consider using {@link assertIsFixedSize}.\n *\n * @see {@link assertIsFixedSize}\n */\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is fixed-size.\n *\n * If the object is not fixed-size (i.e., it lacks a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not fixed-size.\n *\n * @example\n * Asserting a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsFixedSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsFixedSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isFixedSize}.\n * If you only need to check whether an object is fixed-size without throwing an error, use {@link isFixedSize} instead.\n *\n * @see {@link isFixedSize}\n */\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is variable-size.\n *\n * A variable-size object is identified by the absence of a `fixedSize` property.\n * If this property is missing, the object is considered a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is variable-size, `false` otherwise.\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isVariableSize(encoder); // true\n * ```\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isVariableSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is the inverse of {@link isFixedSize}.\n *\n * @see {@link isFixedSize}\n * @see {@link assertIsVariableSize}\n */\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is variable-size.\n *\n * If the object is not variable-size (i.e., it has a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not variable-size.\n *\n * @example\n * Asserting a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsVariableSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsVariableSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isVariableSize}.\n * If you only need to check whether an object is variable-size without throwing an error, use {@link isVariableSize} instead.\n *\n * Also note that this function is the inverse of {@link assertIsFixedSize}.\n *\n * @see {@link isVariableSize}\n * @see {@link assertIsFixedSize}\n */\nexport function assertIsVariableSize<TFrom>(encoder: Encoder<TFrom>): asserts encoder is VariableSizeEncoder<TFrom>;\nexport function assertIsVariableSize<TTo>(decoder: Decoder<TTo>): asserts decoder is VariableSizeDecoder<TTo>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n", "import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an `Encoder` and a `Decoder` into a `Codec`.\n *\n * That is, given a `Encoder<TFrom>` and a `Decoder<TTo>`, this function returns a `Codec<TFrom, TTo>`.\n *\n * This allows for modular composition by keeping encoding and decoding logic separate\n * while still offering a convenient way to bundle them into a single `Codec`.\n * This is particularly useful for library maintainers who want to expose `Encoders`,\n * `Decoders`, and `Codecs` separately, enabling tree-shaking of unused logic.\n *\n * The provided `Encoder` and `Decoder` must be compatible in terms of:\n * - **Fixed Size:** If both are fixed-size, they must have the same `fixedSize` value.\n * - **Variable Size:** If either has a `maxSize` attribute, it must match the other.\n *\n * If these conditions are not met, a {@link SolanaError} will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param encoder - The `Encoder` to combine.\n * @param decoder - The `Decoder` to combine.\n * @returns A `Codec` that provides both `encode` and `decode` methods.\n *\n * @throws {SolanaError}\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH`\n *   Thrown if the encoder and decoder have mismatched size types (fixed vs. variable).\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH`\n *   Thrown if both are fixed-size but have different `fixedSize` values.\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH`\n *   Thrown if the `maxSize` attributes do not match.\n *\n * @example\n * Creating a fixed-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = getU32Encoder();\n * const decoder = getU32Decoder();\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(42); // 0x2a000000\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Creating a variable-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(\"hello\"); // 0x0500000068656c6c6f\n * const value = codec.decode(bytes); // \"hello\"\n * ```\n *\n * @remarks\n * The recommended pattern for defining codecs in libraries is to expose separate functions for the encoder, decoder, and codec.\n * This allows users to import only what they need, improving tree-shaking efficiency.\n *\n * ```ts\n * type MyType = \\/* ... *\\/;\n * const getMyTypeEncoder = (): Encoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeDecoder = (): Decoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeCodec = (): Codec<MyType> =>\n *     combineCodec(getMyTypeEncoder(), getMyTypeDecoder());\n * ```\n *\n * @see {@link Codec}\n * @see {@link Encoder}\n * @see {@link Decoder}\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n", "import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until\n * a given `Uint8Array` sentinel is found.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a given `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\n * codec.encode('hello');\n * // 0x68656c6c6fffff\n * //   |        └-- Our sentinel.\n * //   └-- Our encoded string.\n * ```\n *\n * @remarks\n * Note that the sentinel _must not_ be present in the encoded data and\n * _must_ be present in the decoded data for this to work.\n * If this is not the case, dedicated errors will be thrown.\n *\n * ```ts\n * const sentinel = new Uint8Array([108, 108]); // 'll'\n * const codec = addCodecSentinel(getUtf8Codec(), sentinel);\n *\n * codec.encode('hello'); // Throws: sentinel is in encoded data.\n * codec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n * ```\n *\n * Separate {@link addEncoderSentinel} and {@link addDecoderSentinel} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode('hello');\n * const value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSentinel}\n * @see {@link addDecoderSentinel}\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n", "import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty (after the optional provided offset).\n *\n * Returns void if the byte array is not empty but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n * If provided, the byte array is considered empty if it has no bytes after the offset.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 1); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 3); // Throws\n * ```\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode\n * (after the optional provided offset).\n *\n * Returns void if the byte array has at least the expected number\n * of bytes but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param expected - The minimum number of bytes expected in the byte array.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 4, bytes); // Throws\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 2, bytes, 1); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes, 1); // Throws\n * ```\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param offset - The offset to check.\n * @param bytesLength - The length of the byte array from which the offset should be within bounds.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 0, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 3, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 4, bytes.length); // Throws\n * ```\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n", "import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the nested `decoder` by reading its encoded `prefix`.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Stores the byte size of any given codec as an encoded number prefix.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n * When encoding, the size of the encoded data is stored before the encoded data itself.\n * When decoding, the size is read first to know how many bytes to read next.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * For example, say we want to bound a variable-size base-58 string using a `u32` size prefix.\n * Here’s how you can use the `addCodecSizePrefix` function to achieve that.\n *\n * ```ts\n * const getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n *\n * getU32Base58Codec().encode('hello world');\n * // 0x0b00000068656c6c6f20776f726c64\n * //   |       └-- Our encoded base-58 string.\n * //   └-- Our encoded u32 size prefix.\n * ```\n *\n * @remarks\n * Separate {@link addEncoderSizePrefix} and {@link addDecoderSizePrefix} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSizePrefix(getBase58Encoder(), getU32Encoder()).encode('hello');\n * const value = addDecoderSizePrefix(getBase58Decoder(), getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSizePrefix}\n * @see {@link addDecoderSizePrefix}\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n", "import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * The resulting encoder ensures that encoded values always have the specified number of bytes.\n * If the original encoded value is larger than `fixedBytes`, it is truncated.\n * If it is smaller, it is padded with trailing zeroes.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n * @returns A `FixedSizeEncoder` that ensures a consistent output size.\n *\n * @example\n * ```ts\n * const encoder = fixEncoderSize(getUtf8Encoder(), 4);\n * encoder.encode(\"Hello\"); // 0x48656c6c (truncated)\n * encoder.encode(\"Hi\");    // 0x48690000 (padded)\n * encoder.encode(\"Hiya\");  // 0x48697961 (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * The resulting decoder always reads exactly `fixedBytes` bytes from the input.\n * If the nested decoder is also fixed-size, the bytes are truncated or padded as needed.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n * @returns A `FixedSizeDecoder` that ensures a consistent input size.\n *\n * @example\n * ```ts\n * const decoder = fixDecoderSize(getUtf8Decoder(), 4);\n * decoder.decode(new Uint8Array([72, 101, 108, 108, 111])); // \"Hell\" (truncated)\n * decoder.decode(new Uint8Array([72, 105, 0, 0]));          // \"Hi\" (zeroes ignored)\n * decoder.decode(new Uint8Array([72, 105, 121, 97]));       // \"Hiya\" (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixEncoderSize}\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * The resulting codec ensures that both encoding and decoding operate on a fixed number of bytes.\n * When encoding:\n * - If the encoded value is larger than `fixedBytes`, it is truncated.\n * - If it is smaller, it is padded with trailing zeroes.\n * - If it is exactly `fixedBytes`, it remains unchanged.\n *\n * When decoding:\n * - Exactly `fixedBytes` bytes are read from the input.\n * - If the nested decoder has a smaller fixed size, bytes are truncated or padded as necessary.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n * @returns A `FixedSizeCodec` that ensures both encoding and decoding conform to a fixed size.\n *\n * @example\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 4);\n *\n * const bytes1 = codec.encode(\"Hello\"); // 0x48656c6c (truncated)\n * const value1 = codec.decode(bytes1);  // \"Hell\"\n *\n * const bytes2 = codec.encode(\"Hi\");    // 0x48690000 (padded)\n * const value2 = codec.decode(bytes2);  // \"Hi\"\n *\n * const bytes3 = codec.encode(\"Hiya\");  // 0x48697961 (same length)\n * const value3 = codec.decode(bytes3);  // \"Hiya\"\n * ```\n *\n * @remarks\n * If you only need to enforce a fixed size for encoding, use {@link fixEncoderSize}.\n * If you only need to enforce a fixed size for decoding, use {@link fixDecoderSize}.\n *\n * ```ts\n * const bytes = fixEncoderSize(getUtf8Encoder(), 4).encode(\"Hiya\");\n * const value = fixDecoderSize(getUtf8Decoder(), 4).decode(bytes);\n * ```\n *\n * @see {@link fixEncoderSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n", "import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Configuration object for modifying the offset of an encoder, decoder, or codec.\n *\n * This type defines optional functions for adjusting the **pre-offset** (before encoding/decoding)\n * and the **post-offset** (after encoding/decoding). These functions allow precise control\n * over where data is written or read within a byte array.\n *\n * @property preOffset - A function that modifies the offset before encoding or decoding.\n * @property postOffset - A function that modifies the offset after encoding or decoding.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * };\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * };\n * ```\n *\n * @example\n * Using both pre-offset and post-offset together.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n *     postOffset: ({ postOffset }) => postOffset + 4,\n * };\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n * @see {@link offsetCodec}\n */\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\n/**\n * Scope provided to the `preOffset` and `postOffset` functions,\n * containing contextual information about the current encoding or decoding process.\n *\n * The pre-offset function modifies where encoding or decoding begins,\n * while the post-offset function modifies where the next operation continues.\n *\n * @property bytes - The entire byte array being encoded or decoded.\n * @property preOffset - The original offset before encoding or decoding starts.\n * @property wrapBytes - A helper function that wraps offsets around the byte array length.\n *\n * @example\n * Using `wrapBytes` to wrap a negative offset to the end of the byte array.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves to last 4 bytes\n * };\n * ```\n *\n * @example\n * Adjusting the offset dynamically based on the byte array size.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ bytes }) => bytes.length > 10 ? 4 : 2,\n * };\n * ```\n *\n * @see {@link PreOffsetFunction}\n * @see {@link PostOffsetFunction}\n */\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\n/**\n * A function that modifies the pre-offset before encoding or decoding.\n *\n * This function is used to adjust the starting position before writing\n * or reading data in a byte array.\n *\n * @param scope - The current encoding or decoding context.\n * @returns The new offset at which encoding or decoding should start.\n *\n * @example\n * Skipping the first 2 bytes before writing or reading.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ preOffset }) => preOffset + 2;\n * ```\n *\n * @example\n * Wrapping the offset to ensure it stays within bounds.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ wrapBytes, preOffset }) => wrapBytes(preOffset + 10);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\n\n/**\n * A function that modifies the post-offset after encoding or decoding.\n *\n * This function adjusts where the next encoder or decoder should start\n * after the current operation has completed.\n *\n * @param scope - The current encoding or decoding context, including the modified pre-offset\n * and the original post-offset.\n * @returns The new offset at which the next operation should begin.\n *\n * @example\n * Moving the post-offset forward by 4 bytes.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset }) => postOffset + 4;\n * ```\n *\n * @example\n * Wrapping the post-offset within the byte array length.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ wrapBytes, postOffset }) => wrapBytes(postOffset);\n * ```\n *\n * @example\n * Ensuring a minimum spacing of 8 bytes between values.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset, newPreOffset }) =>\n *     Math.max(postOffset, newPreOffset + 8);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder before and/or after encoding.\n *\n * This function allows an encoder to write its encoded value at a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before encoding) and post-offset adjustments (after encoding).\n *\n * The pre-offset function determines where encoding should start, while the\n * post-offset function adjusts where the next encoder should continue writing.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new encoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Actually written at offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * const nextOffset = encoder.write(42, bytes, 0); // Next encoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to ensure an offset wraps around the byte array length.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Writes at bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetDecoder}\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder before and/or after decoding.\n *\n * This function allows a decoder to read its input from a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before decoding) and post-offset adjustments (after decoding).\n *\n * The pre-offset function determines where decoding should start, while the\n * post-offset function adjusts where the next decoder should continue reading.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new decoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array([0, 0, 42, 0]); // Value starts at offset 2\n * decoder.read(bytes, 0); // Actually reads from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array([42, 0, 0, 0]);\n * const [value, nextOffset] = decoder.read(bytes, 0); // Next decoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to read from the last 4 bytes of an array.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 42]); // Value stored at the last 4 bytes\n * decoder.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetEncoder}\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec before and/or after encoding and decoding.\n *\n * This function allows a codec to encode and decode values at custom offsets\n * within a byte array. It modifies both the **pre-offset** (where encoding/decoding starts)\n * and the **post-offset** (where the next operation should continue).\n *\n * This is particularly useful when working with structured binary formats\n * that require skipping reserved bytes, inserting padding, or aligning fields at\n * specific locations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new codec with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Actually written at offset 2\n * codec.read(bytes, 0);      // Actually read from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0);\n * // Next encoding starts at offset 6 instead of 4\n * codec.read(bytes, 0);\n * // Next decoding starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to loop around negative offsets.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Writes at bytes.length - 4\n * codec.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you only need to adjust offsets for encoding, use {@link offsetEncoder}.\n * If you only need to adjust offsets for decoding, use {@link offsetDecoder}.\n *\n * ```ts\n * const bytes = new Uint8Array(10);\n * offsetEncoder(getU32Encoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).write(42, bytes, 0);\n * const [value] = offsetDecoder(getU32Decoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).read(bytes, 0);\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n", "import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n *\n * This function modifies the size of an encoder using a provided transformation function.\n * For fixed-size encoders, it updates the `fixedSize` property, and for variable-size\n * encoders, it adjusts the size calculation based on the encoded value.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The original fixed size of the encoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param encoder - The encoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new encoder with the updated size.\n *\n * @example\n * Increasing the size of a `u16` encoder by 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU16Encoder(), size => size + 2);\n * encoder.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * ```\n *\n * @example\n * Shrinking a `u32` encoder to only use 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU32Encoder(), () => 2);\n * encoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeDecoder}\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n *\n * This function modifies the size of a decoder using a provided transformation function.\n * For fixed-size decoders, it updates the `fixedSize` property to reflect the new size.\n * Variable-size decoders remain unchanged, as their size is determined dynamically.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the decoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param decoder - The decoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new decoder with the updated size.\n *\n * @example\n * Expanding a `u16` decoder to read 4 bytes instead of 2.\n * ```ts\n * const decoder = resizeDecoder(getU16Decoder(), size => size + 2);\n * decoder.fixedSize; // 4\n * ```\n *\n * @example\n * Shrinking a `u32` decoder to only read 2 bytes.\n * ```ts\n * const decoder = resizeDecoder(getU32Decoder(), () => 2);\n * decoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeEncoder}\n */\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n *\n * This function modifies the size of both the codec using a provided\n * transformation function. It is useful for adjusting the allocated byte size for\n * encoding and decoding without altering the underlying data structure.\n *\n * If the new size is negative, an error will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the encoded/decoded value (for fixed-size codecs).\n * @typeParam TNewSize - The new fixed size after resizing (for fixed-size codecs).\n *\n * @param codec - The codec whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new codec with the updated size.\n *\n * @example\n * Expanding a `u16` codec from 2 to 4 bytes.\n * ```ts\n * const codec = resizeCodec(getU16Codec(), size => size + 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (reads original two bytes)\n * ```\n *\n * @example\n * Shrinking a `u32` codec to only use 2 bytes.\n * ```ts\n * const codec = resizeCodec(getU32Codec(), () => 2);\n * codec.fixedSize; // 2\n * ```\n *\n * @remarks\n * If you only need to resize an encoder, use {@link resizeEncoder}.\n * If you only need to resize a decoder, use {@link resizeDecoder}.\n *\n * ```ts\n * const bytes = resizeEncoder(getU32Encoder(), (size) => size + 2).encode(0xffff);\n * const value = resizeDecoder(getU32Decoder(), (size) => size + 2).decode(bytes);\n * ```\n *\n * @see {@link resizeEncoder}\n * @see {@link resizeDecoder}\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n", "import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder, shifting the encoded value forward\n * by `offset` bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add before encoding.\n * @returns A new encoder with left padding applied.\n *\n * @example\n * ```ts\n * const encoder = padLeftEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder, extending the encoded value by `offset`\n * bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add after encoding.\n * @returns A new encoder with right padding applied.\n *\n * @example\n * ```ts\n * const encoder = padRightEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0xffff0000 (two extra bytes added at the end)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightDecoder}\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder, shifting the decoding position forward\n * by `offset` bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip before decoding.\n * @returns A new decoder with left padding applied.\n *\n * @example\n * ```ts\n * const decoder = padLeftDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0, 0, 0x12, 0x34])); // 0xffff (reads from offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftEncoder}\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder, extending the post-offset by `offset`\n * bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip after decoding.\n * @returns A new decoder with right padding applied.\n *\n * @example\n * ```ts\n * const decoder = padRightDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0x12, 0x34, 0, 0])); // 0xffff (ignores trailing bytes)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightEncoder}\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec, shifting the encoding and decoding positions\n * forward by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * This ensures that values are read and written at a later position in the byte array,\n * while the padding bytes remain unused.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add before encoding and decoding.\n * @returns A new codec with left padding applied.\n *\n * @example\n * ```ts\n * const codec = padLeftCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * const value = codec.decode(bytes);  // 0xffff (reads from offset 2)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padLeftEncoder}.\n * If you only need to apply padding for decoding, use {@link padLeftDecoder}.\n *\n * ```ts\n * const bytes = padLeftEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padLeftDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padLeftEncoder}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec, extending the encoded and decoded value\n * by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * The extra bytes remain unused, ensuring that the next operation starts further\n * along the byte array.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add after encoding and decoding.\n * @returns A new codec with right padding applied.\n *\n * @example\n * ```ts\n * const codec = padRightCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (ignores padding bytes)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padRightEncoder}.\n * If you only need to apply padding for decoding, use {@link padRightDecoder}.\n *\n * ```ts\n * const bytes = padRightEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padRightDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padRightEncoder}\n * @see {@link padRightDecoder}\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n", "import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n *\n * Given a `FixedSizeEncoder`, this function returns a new `FixedSizeEncoder` that\n * reverses the bytes within the fixed-size byte array when encoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The fixed-size encoder to reverse.\n * @returns A new encoder that writes bytes in reverse order.\n *\n * @example\n * Encoding a `u16` value in reverse order.\n * ```ts\n * const encoder = reverseEncoder(getU16Encoder({ endian: Endian.Big }));\n * const bytes = encoder.encode(0x1234); // 0x3412 (bytes are flipped)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseDecoder}\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n *\n * Given a `FixedSizeDecoder`, this function returns a new `FixedSizeDecoder` that\n * reverses the bytes within the fixed-size byte array before decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the decoded value in bytes.\n *\n * @param decoder - The fixed-size decoder to reverse.\n * @returns A new decoder that reads bytes in reverse order.\n *\n * @example\n * Decoding a reversed `u16` value.\n * ```ts\n * const decoder = reverseDecoder(getU16Decoder({ endian: Endian.Big }));\n * const value = decoder.decode(new Uint8Array([0x34, 0x12])); // 0x1234 (bytes are flipped back)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseEncoder}\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n *\n * Given a `FixedSizeCodec`, this function returns a new `FixedSizeCodec` that\n * reverses the bytes within the fixed-size byte array during encoding and decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded/decoded value in bytes.\n *\n * @param codec - The fixed-size codec to reverse.\n * @returns A new codec that encodes and decodes bytes in reverse order.\n *\n * @example\n * Reversing a `u16` codec.\n * ```ts\n * const codec = reverseCodec(getU16Codec({ endian: Endian.Big }));\n * const bytes = codec.encode(0x1234); // 0x3412 (bytes are flipped)\n * const value = codec.decode(bytes);  // 0x1234 (bytes are flipped back)\n * ```\n *\n * @remarks\n * If you only need to reverse an encoder, use {@link reverseEncoder}.\n * If you only need to reverse a decoder, use {@link reverseDecoder}.\n *\n * ```ts\n * const bytes = reverseEncoder(getU16Encoder()).encode(0x1234);\n * const value = reverseDecoder(getU16Decoder()).decode(bytes);\n * ```\n *\n * @see {@link reverseEncoder}\n * @see {@link reverseDecoder}\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n", "import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Transforms an encoder by mapping its input values.\n *\n * This function takes an existing `Encoder<A>` and returns an `Encoder<B>`, allowing values of type `B`\n * to be converted into values of type `A` before encoding. The transformation is applied via the `unmap` function.\n *\n * This is useful for handling type conversions, applying default values, or structuring data before encoding.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldFrom - The original type expected by the encoder.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n *\n * @param encoder - The encoder to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @returns A new encoder that accepts `TNewFrom` values and transforms them before encoding.\n *\n * @example\n * Encoding a string by counting its characters and storing the length as a `u32`.\n * ```ts\n * const encoder = transformEncoder(getU32Encoder(), (value: string) => value.length);\n * encoder.encode(\"hello\"); // 0x05000000 (stores length 5)\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformDecoder}\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Transforms a decoder by mapping its output values.\n *\n * This function takes an existing `Decoder<A>` and returns a `Decoder<B>`, allowing values of type `A`\n * to be converted into values of type `B` after decoding. The transformation is applied via the `map` function.\n *\n * This is useful for post-processing, type conversions, or enriching decoded data.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldTo - The original type returned by the decoder.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param decoder - The decoder to transform.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding.\n * @returns A new decoder that decodes into `TNewTo`.\n *\n * @example\n * Decoding a stored `u32` length into a string of `'x'` characters.\n * ```ts\n * const decoder = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length));\n * decoder.decode(new Uint8Array([0x05, 0x00, 0x00, 0x00])); // \"xxxxx\"\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformEncoder}\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Transforms a codec by mapping its input and output values.\n *\n * This function takes an existing `Codec<A, B>` and returns a `Codec<C, D>`, allowing:\n * - Values of type `C` to be transformed into `A` before encoding.\n * - Values of type `B` to be transformed into `D` after decoding.\n *\n * This is useful for adapting codecs to work with different representations, handling default values, or\n * converting between primitive and structured types.\n *\n * @typeParam TOldFrom - The original type expected by the codec.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n * @typeParam TOldTo - The original type returned by the codec.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param codec - The codec to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding (optional).\n * @returns A new codec that encodes `TNewFrom` and decodes into `TNewTo`.\n *\n * @example\n * Mapping a `u32` codec to encode string lengths and decode them into `'x'` characters.\n * ```ts\n * const codec = transformCodec(\n *     getU32Codec(),\n *     (value: string) => value.length, // Encode string length\n *     (length) => 'x'.repeat(length)  // Decode length into a string of 'x's\n * );\n *\n * const bytes = codec.encode(\"hello\"); // 0x05000000 (stores length 5)\n * const value = codec.decode(bytes);   // \"xxxxx\"\n * ```\n *\n * @remarks\n * If only input transformation is needed, use {@link transformEncoder}.\n * If only output transformation is needed, use {@link transformDecoder}.\n *\n * ```ts\n * const bytes = transformEncoder(getU32Encoder(), (value: string) => value.length).encode(\"hello\");\n * const value = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length)).decode(bytes);\n * ```\n *\n * @see {@link transformEncoder}\n * @see {@link transformDecoder}\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n", "import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Ensures that a given number falls within a specified range.\n *\n * If the number is outside the allowed range, an error is thrown.\n * This function is primarily used to validate values before encoding them in a codec.\n *\n * @param codecDescription - A string describing the codec that is performing the validation.\n * @param min - The minimum allowed value (inclusive).\n * @param max - The maximum allowed value (inclusive).\n * @param value - The number to validate.\n *\n * @throws {@link SolanaError} if the value is out of range.\n *\n * @example\n * Validating a number within range.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 42); // Passes\n * ```\n *\n * @example\n * Throwing an error for an out-of-range value.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 300); // Throws\n * ```\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n", "import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n/**\n * Represents an encoder for numbers and bigints.\n *\n * This type allows encoding values that are either `number` or `bigint`.\n * Depending on the specific implementation, the encoded output may have a fixed or variable size.\n *\n * @see {@link FixedSizeNumberEncoder}\n */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/**\n * Represents a fixed-size encoder for numbers and bigints.\n *\n * This encoder serializes values using an exact number of bytes, defined by `TSize`.\n *\n * @typeParam TSize - The number of bytes used for encoding.\n *\n * @see {@link NumberEncoder}\n */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/**\n * Represents a decoder for numbers and bigints.\n *\n * This type supports decoding values as either `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberDecoder}\n */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/**\n * Represents a fixed-size decoder for numbers and bigints.\n *\n * This decoder reads a fixed number of bytes (`TSize`) and converts them into a `number` or `bigint`.\n *\n * @typeParam TSize - The number of bytes expected for decoding.\n *\n * @see {@link NumberDecoder}\n */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/**\n * Represents a codec for encoding and decoding numbers and bigints.\n *\n * - The encoded value can be either a `number` or a `bigint`.\n * - The decoded value will always be either a `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberCodec}\n */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/**\n * Represents a fixed-size codec for encoding and decoding numbers and bigints.\n *\n * This codec uses a specific number of bytes (`TSize`) for serialization.\n * The encoded value can be either a `number` or `bigint`, but the decoded value will always be a `number` or `bigint`,\n * depending on the implementation.\n *\n * @typeParam TSize - The number of bytes used for encoding and decoding.\n *\n * @see {@link NumberCodec}\n */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/**\n * Configuration options for number codecs that use more than one byte.\n *\n * This configuration applies to all number codecs except `u8` and `i8`,\n * allowing the user to specify the endianness of serialization.\n */\nexport type NumberCodecConfig = {\n    /**\n     * Specifies whether numbers should be encoded in little-endian or big-endian format.\n     *\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/**\n * Defines the byte order used for number serialization.\n *\n * - `Little`: The least significant byte is stored first.\n * - `Big`: The most significant byte is stored first.\n */\nexport enum Endian {\n    Little,\n    Big,\n}\n", "import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit floating-point numbers (`f32`).\n *\n * This encoder serializes `f32` values using 4 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 4>` for encoding `f32` values.\n *\n * @example\n * Encoding an `f32` value.\n * ```ts\n * const encoder = getF32Encoder();\n * const bytes = encoder.encode(-1.5); // 0x0000c0bf\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit floating-point numbers (`f32`).\n *\n * This decoder deserializes `f32` values from 4 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `f32` values.\n *\n * @example\n * Decoding an `f32` value.\n * ```ts\n * const decoder = getF32Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0xc0, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit floating-point numbers (`f32`).\n *\n * This codec serializes `f32` values using 4 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 4>` for encoding and decoding `f32` values.\n *\n * @example\n * Encoding and decoding an `f32` value.\n * ```ts\n * const codec = getF32Codec();\n * const bytes = codec.encode(-1.5); // 0x0000c0bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbfc00000\n * ```\n *\n * @remarks\n * `f32` values follow the IEEE 754 single-precision floating-point standard.\n * Precision loss may occur for certain values.\n *\n * - If you need higher precision, consider using {@link getF64Codec}.\n * - If you need integer values, consider using {@link getI32Codec} or {@link getU32Codec}.\n *\n * Separate {@link getF32Encoder} and {@link getF32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF32Encoder().encode(-1.5);\n * const value = getF32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF32Encoder}\n * @see {@link getF32Decoder}\n */\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit floating-point numbers (`f64`).\n *\n * This encoder serializes `f64` values using 8 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 8>` for encoding `f64` values.\n *\n * @example\n * Encoding an `f64` value.\n * ```ts\n * const encoder = getF64Encoder();\n * const bytes = encoder.encode(-1.5); // 0x000000000000f8bf\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit floating-point numbers (`f64`).\n *\n * This decoder deserializes `f64` values from 8 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 8>` for decoding `f64` values.\n *\n * @example\n * Decoding an `f64` value.\n * ```ts\n * const decoder = getF64Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit floating-point numbers (`f64`).\n *\n * This codec serializes `f64` values using 8 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 8>` for encoding and decoding `f64` values.\n *\n * @example\n * Encoding and decoding an `f64` value.\n * ```ts\n * const codec = getF64Codec();\n * const bytes = codec.encode(-1.5); // 0x000000000000f8bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbff8000000000000\n * ```\n *\n * @remarks\n * `f64` values follow the IEEE 754 double-precision floating-point standard.\n * Precision loss may still occur but is significantly lower than `f32`.\n *\n * - If you need smaller floating-point values, consider using {@link getF32Codec}.\n * - If you need integer values, consider using {@link getI64Codec} or {@link getU64Codec}.\n *\n * Separate {@link getF64Encoder} and {@link getF64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF64Encoder().encode(-1.5);\n * const value = getF64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF64Encoder}\n * @see {@link getF64Decoder}\n */\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit signed integers (`i128`).\n *\n * This encoder serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `i128` values.\n *\n * @example\n * Encoding an `i128` value.\n * ```ts\n * const encoder = getI128Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit signed integers (`i128`).\n *\n * This decoder deserializes `i128` values from 16 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `i128` values.\n *\n * @example\n * Decoding an `i128` value.\n * ```ts\n * const decoder = getI128Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n *   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit signed integers (`i128`).\n *\n * This codec serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `i128` values.\n *\n * @example\n * Encoding and decoding an `i128` value.\n * ```ts\n * const codec = getI128Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^127` and `2^127 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI64Codec} or {@link getI32Codec}.\n * - If you need a larger signed integer, consider using a custom codec.\n * - If you need unsigned integers, consider using {@link getU128Codec}.\n *\n * Separate {@link getI128Encoder} and {@link getI128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI128Encoder().encode(-42);\n * const value = getI128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI128Encoder}\n * @see {@link getI128Decoder}\n */\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit signed integers (`i16`).\n *\n * This encoder serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `i16` values.\n *\n * @example\n * Encoding an `i16` value.\n * ```ts\n * const encoder = getI16Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ff\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit signed integers (`i16`).\n *\n * This decoder deserializes `i16` values from 2 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `i16` values.\n *\n * @example\n * Decoding an `i16` value.\n * ```ts\n * const decoder = getI16Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff])); // -42\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit signed integers (`i16`).\n *\n * This codec serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `i16` values.\n *\n * @example\n * Encoding and decoding an `i16` value.\n * ```ts\n * const codec = getI16Codec();\n * const bytes = codec.encode(-42); // 0xd6ff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^15` (`-32,768`) and `2^15 - 1` (`32,767`).\n *\n * - If you need a smaller signed integer, consider using {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI32Codec}.\n * - If you need unsigned integers, consider using {@link getU16Codec}.\n *\n * Separate {@link getI16Encoder} and {@link getI16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI16Encoder().encode(-42);\n * const value = getI16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI16Encoder}\n * @see {@link getI16Decoder}\n */\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit signed integers (`i32`).\n *\n * This encoder serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 4>` for encoding `i32` values.\n *\n * @example\n * Encoding an `i32` value.\n * ```ts\n * const encoder = getI32Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ffffff\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit signed integers (`i32`).\n *\n * This decoder deserializes `i32` values from 4 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `i32` values.\n *\n * @example\n * Decoding an `i32` value.\n * ```ts\n * const decoder = getI32Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff, 0xff, 0xff])); // -42\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit signed integers (`i32`).\n *\n * This codec serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 4>` for encoding and decoding `i32` values.\n *\n * @example\n * Encoding and decoding an `i32` value.\n * ```ts\n * const codec = getI32Codec();\n * const bytes = codec.encode(-42); // 0xd6ffffff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^31` (`-2,147,483,648`) and `2^31 - 1` (`2,147,483,647`).\n *\n * - If you need a smaller signed integer, consider using {@link getI16Codec} or {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI64Codec}.\n * - If you need unsigned integers, consider using {@link getU32Codec}.\n *\n * Separate {@link getI32Encoder} and {@link getI32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI32Encoder().encode(-42);\n * const value = getI32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI32Encoder}\n * @see {@link getI32Decoder}\n */\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit signed integers (`i64`).\n *\n * This encoder serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `i64` values.\n *\n * @example\n * Encoding an `i64` value.\n * ```ts\n * const encoder = getI64Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffff\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit signed integers (`i64`).\n *\n * This decoder deserializes `i64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `i64` values.\n *\n * @example\n * Decoding an `i64` value.\n * ```ts\n * const decoder = getI64Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit signed integers (`i64`).\n *\n * This codec serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `i64` values.\n *\n * @example\n * Encoding and decoding an `i64` value.\n * ```ts\n * const codec = getI64Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^63` and `2^63 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI32Codec} or {@link getI16Codec}.\n * - If you need a larger signed integer, consider using {@link getI128Codec}.\n * - If you need unsigned integers, consider using {@link getU64Codec}.\n *\n * Separate {@link getI64Encoder} and {@link getI64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI64Encoder().encode(-42);\n * const value = getI64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI64Encoder}\n * @see {@link getI64Decoder}\n */\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit signed integers (`i8`).\n *\n * This encoder serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `i8` values.\n *\n * @example\n * Encoding an `i8` value.\n * ```ts\n * const encoder = getI8Encoder();\n * const bytes = encoder.encode(-42); // 0xd6\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit signed integers (`i8`).\n *\n * This decoder deserializes `i8` values from 1 byte.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `i8` values.\n *\n * @example\n * Decoding an `i8` value.\n * ```ts\n * const decoder = getI8Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6])); // -42\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit signed integers (`i8`).\n *\n * This codec serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `i8` values.\n *\n * @example\n * Encoding and decoding an `i8` value.\n * ```ts\n * const codec = getI8Codec();\n * const bytes = codec.encode(-42); // 0xd6\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @remarks\n * This codec supports values between `-2^7` (`-128`) and `2^7 - 1` (`127`).\n *\n * - If you need a larger signed integer, consider using {@link getI16Codec}.\n * - If you need an unsigned integer, consider using {@link getU8Codec}.\n *\n * Separate {@link getI8Encoder} and {@link getI8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI8Encoder().encode(-42);\n * const value = getI8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI8Encoder}\n * @see {@link getI8Decoder}\n */\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Returns an encoder for `shortU16` values.\n *\n * This encoder serializes `shortU16` values using **1 to 3 bytes**.\n * Smaller values use fewer bytes, while larger values take up more space.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeEncoder<number | bigint>` for encoding `shortU16` values.\n *\n * @example\n * Encoding a `shortU16` value.\n * ```ts\n * const encoder = getShortU16Encoder();\n * encoder.encode(42);    // 0x2a\n * encoder.encode(128);   // 0x8001\n * encoder.encode(16384); // 0x808001\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Returns a decoder for `shortU16` values.\n *\n * This decoder deserializes `shortU16` values from **1 to 3 bytes**.\n * The number of bytes used depends on the encoded value.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeDecoder<number>` for decoding `shortU16` values.\n *\n * @example\n * Decoding a `shortU16` value.\n * ```ts\n * const decoder = getShortU16Decoder();\n * decoder.decode(new Uint8Array([0x2a]));             // 42\n * decoder.decode(new Uint8Array([0x80, 0x01]));       // 128\n * decoder.decode(new Uint8Array([0x80, 0x80, 0x01])); // 16384\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding `shortU16` values.\n *\n * It serializes unsigned integers using **1 to 3 bytes** based on the encoded value.\n * The larger the value, the more bytes it uses.\n *\n * - If the value is `<= 0x7f` (127), it is stored in a **single byte**\n *   and the first bit is set to `0` to indicate the end of the value.\n * - Otherwise, the first bit is set to `1` to indicate that the value continues in the next byte, which follows the same pattern.\n * - This process repeats until the value is fully encoded in up to 3 bytes. The third and last byte, if needed, uses all 8 bits to store the remaining value.\n *\n * In other words, the encoding scheme follows this structure:\n *\n * ```txt\n * 0XXXXXXX                   <- Values 0 to 127 (1 byte)\n * 1XXXXXXX 0XXXXXXX          <- Values 128 to 16,383 (2 bytes)\n * 1XXXXXXX 1XXXXXXX XXXXXXXX <- Values 16,384 to 4,194,303 (3 bytes)\n * ```\n *\n * @returns A `VariableSizeCodec<number | bigint, number>` for encoding and decoding `shortU16` values.\n *\n * @example\n * Encoding and decoding `shortU16` values.\n * ```ts\n * const codec = getShortU16Codec();\n * const bytes1 = codec.encode(42);    // 0x2a\n * const bytes2 = codec.encode(128);   // 0x8001\n * const bytes3 = codec.encode(16384); // 0x808001\n *\n * codec.decode(bytes1); // 42\n * codec.decode(bytes2); // 128\n * codec.decode(bytes3); // 16384\n * ```\n *\n * @remarks\n * This codec efficiently stores small numbers, making it useful for transactions and compact representations.\n *\n * If you need a fixed-size `u16` codec, consider using {@link getU16Codec}.\n *\n * Separate {@link getShortU16Encoder} and {@link getShortU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getShortU16Encoder().encode(42);\n * const value = getShortU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getShortU16Encoder}\n * @see {@link getShortU16Decoder}\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit unsigned integers (`u128`).\n *\n * This encoder serializes `u128` values using sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `u128` values.\n *\n * @example\n * Encoding a `u128` value.\n * ```ts\n * const encoder = getU128Encoder();\n * const bytes = encoder.encode(42n); // 0x2a000000000000000000000000000000\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit unsigned integers (`u128`).\n *\n * This decoder deserializes `u128` values from sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `u128` values.\n *\n * @example\n * Decoding a `u128` value.\n * ```ts\n * const decoder = getU128Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit unsigned integers (`u128`).\n *\n * This codec serializes `u128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `u128` values.\n *\n * @example\n * Encoding and decoding a `u128` value.\n * ```ts\n * const codec = getU128Codec();\n * const bytes = codec.encode(42); // 0x2a000000000000000000000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000000000000000000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^128 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU64Codec} or {@link getU32Codec}.\n * - If you need signed integers, consider using {@link getI128Codec}.\n *\n * Separate {@link getU128Encoder} and {@link getU128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU128Encoder().encode(42);\n * const value = getU128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU128Encoder}\n * @see {@link getU128Decoder}\n */\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit unsigned integers (`u16`).\n *\n * This encoder serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `u16` values.\n *\n * @example\n * Encoding a `u16` value.\n * ```ts\n * const encoder = getU16Encoder();\n * const bytes = encoder.encode(42); // 0x2a00\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit unsigned integers (`u16`).\n *\n * This decoder deserializes `u16` values from two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `u16` values.\n *\n * @example\n * Decoding a `u16` value.\n * ```ts\n * const decoder = getU16Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit unsigned integers (`u16`).\n *\n * This codec serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `u16` values.\n *\n * @example\n * Encoding and decoding a `u16` value.\n * ```ts\n * const codec = getU16Codec();\n * const bytes = codec.encode(42); // 0x2a00 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^16 - 1`.\n * If you need a larger range, consider using {@link getU32Codec} or {@link getU64Codec}.\n * For signed integers, use {@link getI16Codec}.\n *\n * Separate {@link getU16Encoder} and {@link getU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU16Encoder().encode(42);\n * const value = getU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU16Encoder}\n * @see {@link getU16Decoder}\n */\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit unsigned integers (`u32`).\n *\n * This encoder serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<bigint | number, 4>` for encoding `u32` values.\n *\n * @example\n * Encoding a `u32` value.\n * ```ts\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42); // 0x2a000000\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit unsigned integers (`u32`).\n *\n * This decoder deserializes `u32` values from four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `u32` values.\n *\n * @example\n * Decoding a `u32` value.\n * ```ts\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit unsigned integers (`u32`).\n *\n * This codec serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<bigint | number, number, 4>` for encoding and decoding `u32` values.\n *\n * @example\n * Encoding and decoding a `u32` value.\n * ```ts\n * const codec = getU32Codec();\n * const bytes = codec.encode(42); // 0x2a000000 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000002a\n * ```\n *\n * @remarks\n * This codec only supports values between `0` and `2^32 - 1`.\n * If you need a larger range, consider using {@link getU64Codec} or {@link getU128Codec}.\n * For signed integers, use {@link getI32Codec}.\n *\n * Separate {@link getU32Encoder} and {@link getU32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU32Encoder().encode(42);\n * const value = getU32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU32Encoder}\n * @see {@link getU32Decoder}\n */\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit unsigned integers (`u64`).\n *\n * This encoder serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `u64` values.\n *\n * @example\n * Encoding a `u64` value.\n * ```ts\n * const encoder = getU64Encoder();\n * const bytes = encoder.encode(42); // 0x2a00000000000000\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit unsigned integers (`u64`).\n *\n * This decoder deserializes `u64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `u64` values.\n *\n * @example\n * Decoding a `u64` value.\n * ```ts\n * const decoder = getU64Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit unsigned integers (`u64`).\n *\n * This codec serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `u64` values.\n *\n * @example\n * Encoding and decoding a `u64` value.\n * ```ts\n * const codec = getU64Codec();\n * const bytes = codec.encode(42); // 0x2a00000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^64 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU32Codec} or {@link getU16Codec}.\n * - If you need a larger unsigned integer, consider using {@link getU128Codec}.\n * - If you need signed integers, consider using {@link getI64Codec}.\n *\n * Separate {@link getU64Encoder} and {@link getU64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU64Encoder().encode(42);\n * const value = getU64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU64Encoder}\n * @see {@link getU64Decoder}\n */\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit unsigned integers (`u8`).\n *\n * This encoder serializes `u8` values using a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `u8` values.\n *\n * @example\n * Encoding a `u8` value.\n * ```ts\n * const encoder = getU8Encoder();\n * const bytes = encoder.encode(42); // 0x2a\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit unsigned integers (`u8`).\n *\n * This decoder deserializes `u8` values from a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `u8` values.\n *\n * @example\n * Decoding a `u8` value.\n * ```ts\n * const decoder = getU8Decoder();\n * const value = decoder.decode(new Uint8Array([0xff])); // 255\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit unsigned integers (`u8`).\n *\n * This codec serializes `u8` values using a single byte.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `u8` values.\n *\n * @example\n * Encoding and decoding a `u8` value.\n * ```ts\n * const codec = getU8Codec();\n * const bytes = codec.encode(255); // 0xff\n * const value = codec.decode(bytes); // 255\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^8 - 1` (0 to 255).\n * If you need larger integers, consider using {@link getU16Codec}, {@link getU32Codec}, or {@link getU64Codec}.\n * For signed integers, use {@link getI8Codec}.\n *\n * Separate {@link getU8Encoder} and {@link getU8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU8Encoder().encode(42);\n * const value = getU8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU8Encoder}\n * @see {@link getU8Decoder}\n */\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n", "import {ed25519} from '@noble/curves/ed25519';\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */\ntype Ed25519SecretKey = Uint8Array;\n\n/**\n * Ed25519 Keypair\n */\nexport interface Ed25519Keypair {\n  publicKey: Uint8Array;\n  secretKey: Ed25519SecretKey;\n}\n\nexport const generatePrivateKey = ed25519.utils.randomPrivateKey;\nexport const generateKeypair = (): Ed25519Keypair => {\n  const privateScalar = ed25519.utils.randomPrivateKey();\n  const publicKey = getPublicKey(privateScalar);\n  const secretKey = new Uint8Array(64);\n  secretKey.set(privateScalar);\n  secretKey.set(publicKey, 32);\n  return {\n    publicKey,\n    secretKey,\n  };\n};\nexport const getPublicKey = ed25519.getPublicKey;\nexport function isOnCurve(publicKey: Uint8Array): boolean {\n  try {\n    ed25519.ExtendedPoint.fromHex(publicKey);\n    return true;\n  } catch {\n    return false;\n  }\n}\nexport const sign = (\n  message: Parameters<typeof ed25519.sign>[0],\n  secretKey: Ed25519SecretKey,\n) => ed25519.sign(message, secretKey.slice(0, 32));\nexport const verify = ed25519.verify;\n", "import {Buffer} from 'buffer';\n\nexport const toBuffer = (arr: Buffer | Uint8Array | Array<number>): Buffer => {\n  if (Buffer.isBuffer(arr)) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return Buffer.from(arr);\n  }\n};\n", "import {Buffer} from 'buffer';\nimport {serialize, deserialize, deserializeUnchecked} from 'borsh';\n\n// Class wrapping a plain object\nexport class Struct {\n  constructor(properties: any) {\n    Object.assign(this, properties);\n  }\n\n  encode(): Buffer {\n    return Buffer.from(serialize(SOLANA_SCHEMA, this));\n  }\n\n  static decode(data: Buffer): any {\n    return deserialize(SOLANA_SCHEMA, this, data);\n  }\n\n  static decodeUnchecked(data: Buffer): any {\n    return deserializeUnchecked(SOLANA_SCHEMA, this, data);\n  }\n}\n\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nexport class Enum extends Struct {\n  enum: string = '';\n  constructor(properties: any) {\n    super(properties);\n    if (Object.keys(properties).length !== 1) {\n      throw new Error('Enum can only take single value');\n    }\n    Object.keys(properties).map(key => {\n      this.enum = key;\n    });\n  }\n}\n\nexport const SOLANA_SCHEMA: Map<Function, any> = new Map();\n", "import BN from 'bn.js';\nimport bs58 from 'bs58';\nimport {Buffer} from 'buffer';\nimport {sha256} from '@noble/hashes/sha256';\n\nimport {isOnCurve} from './utils/ed25519';\nimport {Struct, SOLANA_SCHEMA} from './utils/borsh-schema';\nimport {toBuffer} from './utils/to-buffer';\n\n/**\n * Maximum length of derived pubkey seed\n */\nexport const MAX_SEED_LENGTH = 32;\n\n/**\n * Size of public key in bytes\n */\nexport const PUBLIC_KEY_LENGTH = 32;\n\n/**\n * Value to be converted into public key\n */\nexport type PublicKeyInitData =\n  | number\n  | string\n  | Uint8Array\n  | Array<number>\n  | PublicKeyData;\n\n/**\n * JSON object representation of PublicKey class\n */\nexport type PublicKeyData = {\n  /** @internal */\n  _bn: BN;\n};\n\nfunction isPublicKeyData(value: PublicKeyInitData): value is PublicKeyData {\n  return (value as PublicKeyData)._bn !== undefined;\n}\n\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n\n/**\n * A public key\n */\nexport class PublicKey extends Struct {\n  /** @internal */\n  _bn: BN;\n\n  /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */\n  constructor(value: PublicKeyInitData) {\n    super({});\n    if (isPublicKeyData(value)) {\n      this._bn = value._bn;\n    } else {\n      if (typeof value === 'string') {\n        // assume base 58 encoding by default\n        const decoded = bs58.decode(value);\n        if (decoded.length != PUBLIC_KEY_LENGTH) {\n          throw new Error(`Invalid public key input`);\n        }\n        this._bn = new BN(decoded);\n      } else {\n        this._bn = new BN(value);\n      }\n\n      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n        throw new Error(`Invalid public key input`);\n      }\n    }\n  }\n\n  /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */\n  static unique(): PublicKey {\n    const key = new PublicKey(uniquePublicKeyCounter);\n    uniquePublicKeyCounter += 1;\n    return new PublicKey(key.toBuffer());\n  }\n\n  /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */\n  static default: PublicKey = new PublicKey('11111111111111111111111111111111');\n\n  /**\n   * Checks if two publicKeys are equal\n   */\n  equals(publicKey: PublicKey): boolean {\n    return this._bn.eq(publicKey._bn);\n  }\n\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toBase58(): string {\n    return bs58.encode(this.toBytes());\n  }\n\n  toJSON(): string {\n    return this.toBase58();\n  }\n\n  /**\n   * Return the byte array representation of the public key in big endian\n   */\n  toBytes(): Uint8Array {\n    const buf = this.toBuffer();\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n\n  /**\n   * Return the Buffer representation of the public key in big endian\n   */\n  toBuffer(): Buffer {\n    const b = this._bn.toArrayLike(Buffer);\n    if (b.length === PUBLIC_KEY_LENGTH) {\n      return b;\n    }\n\n    const zeroPad = Buffer.alloc(32);\n    b.copy(zeroPad, 32 - b.length);\n    return zeroPad;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return `PublicKey(${this.toString()})`;\n  }\n\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toString(): string {\n    return this.toBase58();\n  }\n\n  /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */\n  /* eslint-disable require-await */\n  static async createWithSeed(\n    fromPublicKey: PublicKey,\n    seed: string,\n    programId: PublicKey,\n  ): Promise<PublicKey> {\n    const buffer = Buffer.concat([\n      fromPublicKey.toBuffer(),\n      Buffer.from(seed),\n      programId.toBuffer(),\n    ]);\n    const publicKeyBytes = sha256(buffer);\n    return new PublicKey(publicKeyBytes);\n  }\n\n  /**\n   * Derive a program address from seeds and a program ID.\n   */\n  /* eslint-disable require-await */\n  static createProgramAddressSync(\n    seeds: Array<Buffer | Uint8Array>,\n    programId: PublicKey,\n  ): PublicKey {\n    let buffer = Buffer.alloc(0);\n    seeds.forEach(function (seed) {\n      if (seed.length > MAX_SEED_LENGTH) {\n        throw new TypeError(`Max seed length exceeded`);\n      }\n      buffer = Buffer.concat([buffer, toBuffer(seed)]);\n    });\n    buffer = Buffer.concat([\n      buffer,\n      programId.toBuffer(),\n      Buffer.from('ProgramDerivedAddress'),\n    ]);\n    const publicKeyBytes = sha256(buffer);\n    if (isOnCurve(publicKeyBytes)) {\n      throw new Error(`Invalid seeds, address must fall off the curve`);\n    }\n    return new PublicKey(publicKeyBytes);\n  }\n\n  /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */\n  /* eslint-disable require-await */\n  static async createProgramAddress(\n    seeds: Array<Buffer | Uint8Array>,\n    programId: PublicKey,\n  ): Promise<PublicKey> {\n    return this.createProgramAddressSync(seeds, programId);\n  }\n\n  /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */\n  static findProgramAddressSync(\n    seeds: Array<Buffer | Uint8Array>,\n    programId: PublicKey,\n  ): [PublicKey, number] {\n    let nonce = 255;\n    let address;\n    while (nonce != 0) {\n      try {\n        const seedsWithNonce = seeds.concat(Buffer.from([nonce]));\n        address = this.createProgramAddressSync(seedsWithNonce, programId);\n      } catch (err) {\n        if (err instanceof TypeError) {\n          throw err;\n        }\n        nonce--;\n        continue;\n      }\n      return [address, nonce];\n    }\n    throw new Error(`Unable to find a viable program address nonce`);\n  }\n\n  /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */\n  static async findProgramAddress(\n    seeds: Array<Buffer | Uint8Array>,\n    programId: PublicKey,\n  ): Promise<[PublicKey, number]> {\n    return this.findProgramAddressSync(seeds, programId);\n  }\n\n  /**\n   * Check that a pubkey is on the ed25519 curve.\n   */\n  static isOnCurve(pubkeyData: PublicKeyInitData): boolean {\n    const pubkey = new PublicKey(pubkeyData);\n    return isOnCurve(pubkey.toBytes());\n  }\n}\n\nSOLANA_SCHEMA.set(PublicKey, {\n  kind: 'struct',\n  fields: [['_bn', 'u256']],\n});\n", "import {Buffer} from 'buffer';\n\nimport {generatePrivateKey, getPublicKey} from './utils/ed25519';\nimport {toBuffer} from './utils/to-buffer';\nimport {PublicKey} from './publickey';\n\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */\nexport class Account {\n  /** @internal */\n  private _publicKey: Buffer;\n  /** @internal */\n  private _secretKey: Buffer;\n\n  /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */\n  constructor(secretKey?: Uint8Array | Array<number>) {\n    if (secretKey) {\n      const secretKeyBuffer = toBuffer(secretKey);\n      if (secretKey.length !== 64) {\n        throw new Error('bad secret key size');\n      }\n      this._publicKey = secretKeyBuffer.slice(32, 64);\n      this._secretKey = secretKeyBuffer.slice(0, 32);\n    } else {\n      this._secretKey = toBuffer(generatePrivateKey());\n      this._publicKey = toBuffer(getPublicKey(this._secretKey));\n    }\n  }\n\n  /**\n   * The public key for this account\n   */\n  get publicKey(): PublicKey {\n    return new PublicKey(this._publicKey);\n  }\n\n  /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */\n  get secretKey(): Buffer {\n    return Buffer.concat([this._secretKey, this._publicKey], 64);\n  }\n}\n", "import {PublicKey} from './publickey';\n\nexport const BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey(\n  'BPFLoader1111111111111111111111111111111111',\n);\n", "/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */\nexport const PACKET_DATA_SIZE = 1280 - 40 - 8;\n\nexport const VERSION_PREFIX_MASK = 0x7f;\n\nexport const SIGNATURE_LENGTH_IN_BYTES = 64;\n", "export class TransactionExpiredBlockheightExceededError extends Error {\n  signature: string;\n\n  constructor(signature: string) {\n    super(`Signature ${signature} has expired: block height exceeded.`);\n    this.signature = signature;\n  }\n}\n\nObject.defineProperty(\n  TransactionExpiredBlockheightExceededError.prototype,\n  'name',\n  {\n    value: 'TransactionExpiredBlockheightExceededError',\n  },\n);\n\nexport class TransactionExpiredTimeoutError extends Error {\n  signature: string;\n\n  constructor(signature: string, timeoutSeconds: number) {\n    super(\n      `Transaction was not confirmed in ${timeoutSeconds.toFixed(\n        2,\n      )} seconds. It is ` +\n        'unknown if it succeeded or failed. Check signature ' +\n        `${signature} using the Solana Explorer or CLI tools.`,\n    );\n    this.signature = signature;\n  }\n}\n\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {\n  value: 'TransactionExpiredTimeoutError',\n});\n\nexport class TransactionExpiredNonceInvalidError extends Error {\n  signature: string;\n\n  constructor(signature: string) {\n    super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n    this.signature = signature;\n  }\n}\n\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, 'name', {\n  value: 'TransactionExpiredNonceInvalidError',\n});\n", "import {LoadedAddresses} from '../connection';\nimport {PublicKey} from '../publickey';\nimport {TransactionInstruction} from '../transaction';\nimport {MessageCompiledInstruction} from './index';\n\nexport type AccountKeysFromLookups = LoadedAddresses;\n\nexport class MessageAccountKeys {\n  staticAccountKeys: Array<PublicKey>;\n  accountKeysFromLookups?: AccountKeysFromLookups;\n\n  constructor(\n    staticAccountKeys: Array<PublicKey>,\n    accountKeysFromLookups?: AccountKeysFromLookups,\n  ) {\n    this.staticAccountKeys = staticAccountKeys;\n    this.accountKeysFromLookups = accountKeysFromLookups;\n  }\n\n  keySegments(): Array<Array<PublicKey>> {\n    const keySegments = [this.staticAccountKeys];\n    if (this.accountKeysFromLookups) {\n      keySegments.push(this.accountKeysFromLookups.writable);\n      keySegments.push(this.accountKeysFromLookups.readonly);\n    }\n    return keySegments;\n  }\n\n  get(index: number): PublicKey | undefined {\n    for (const keySegment of this.keySegments()) {\n      if (index < keySegment.length) {\n        return keySegment[index];\n      } else {\n        index -= keySegment.length;\n      }\n    }\n    return;\n  }\n\n  get length(): number {\n    return this.keySegments().flat().length;\n  }\n\n  compileInstructions(\n    instructions: Array<TransactionInstruction>,\n  ): Array<MessageCompiledInstruction> {\n    // Bail early if any account indexes would overflow a u8\n    const U8_MAX = 255;\n    if (this.length > U8_MAX + 1) {\n      throw new Error('Account index overflow encountered during compilation');\n    }\n\n    const keyIndexMap = new Map();\n    this.keySegments()\n      .flat()\n      .forEach((key, index) => {\n        keyIndexMap.set(key.toBase58(), index);\n      });\n\n    const findKeyIndex = (key: PublicKey) => {\n      const keyIndex = keyIndexMap.get(key.toBase58());\n      if (keyIndex === undefined)\n        throw new Error(\n          'Encountered an unknown instruction account key during compilation',\n        );\n      return keyIndex;\n    };\n\n    return instructions.map((instruction): MessageCompiledInstruction => {\n      return {\n        programIdIndex: findKeyIndex(instruction.programId),\n        accountKeyIndexes: instruction.keys.map(meta =>\n          findKeyIndex(meta.pubkey),\n        ),\n        data: instruction.data,\n      };\n    });\n  }\n}\n", "import {Buffer} from 'buffer';\nimport * as BufferLayout from '@solana/buffer-layout';\n\nimport {VoteAuthorizeWithSeedArgs} from './programs/vote';\n\n/**\n * Layout for a public key\n */\nexport const publicKey = (property: string = 'publicKey') => {\n  return BufferLayout.blob(32, property);\n};\n\n/**\n * Layout for a signature\n */\nexport const signature = (property: string = 'signature') => {\n  return BufferLayout.blob(64, property);\n};\n\n/**\n * Layout for a 64bit unsigned value\n */\nexport const uint64 = (property: string = 'uint64') => {\n  return BufferLayout.blob(8, property);\n};\n\ninterface IRustStringShim\n  extends Omit<\n    BufferLayout.Structure<\n      Readonly<{\n        length: number;\n        lengthPadding: number;\n        chars: Uint8Array;\n      }>\n    >,\n    'decode' | 'encode' | 'replicate'\n  > {\n  alloc: (str: string) => number;\n  decode: (b: Uint8Array, offset?: number) => string;\n  encode: (str: string, b: Uint8Array, offset?: number) => number;\n  replicate: (property: string) => this;\n}\n\n/**\n * Layout for a Rust String type\n */\nexport const rustString = (\n  property: string = 'string',\n): BufferLayout.Layout<string> => {\n  const rsl = BufferLayout.struct<\n    Readonly<{\n      length?: number;\n      lengthPadding?: number;\n      chars: Uint8Array;\n    }>\n  >(\n    [\n      BufferLayout.u32('length'),\n      BufferLayout.u32('lengthPadding'),\n      BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars'),\n    ],\n    property,\n  );\n  const _decode = rsl.decode.bind(rsl);\n  const _encode = rsl.encode.bind(rsl);\n\n  const rslShim = rsl as unknown as IRustStringShim;\n\n  rslShim.decode = (b: Uint8Array, offset?: number) => {\n    const data = _decode(b, offset);\n    return data['chars'].toString();\n  };\n\n  rslShim.encode = (str: string, b: Uint8Array, offset?: number) => {\n    const data = {\n      chars: Buffer.from(str, 'utf8'),\n    };\n    return _encode(data, b, offset);\n  };\n\n  rslShim.alloc = (str: string) => {\n    return (\n      BufferLayout.u32().span +\n      BufferLayout.u32().span +\n      Buffer.from(str, 'utf8').length\n    );\n  };\n\n  return rslShim;\n};\n\n/**\n * Layout for an Authorized object\n */\nexport const authorized = (property: string = 'authorized') => {\n  return BufferLayout.struct<\n    Readonly<{\n      staker: Uint8Array;\n      withdrawer: Uint8Array;\n    }>\n  >([publicKey('staker'), publicKey('withdrawer')], property);\n};\n\n/**\n * Layout for a Lockup object\n */\nexport const lockup = (property: string = 'lockup') => {\n  return BufferLayout.struct<\n    Readonly<{\n      custodian: Uint8Array;\n      epoch: number;\n      unixTimestamp: number;\n    }>\n  >(\n    [\n      BufferLayout.ns64('unixTimestamp'),\n      BufferLayout.ns64('epoch'),\n      publicKey('custodian'),\n    ],\n    property,\n  );\n};\n\n/**\n *  Layout for a VoteInit object\n */\nexport const voteInit = (property: string = 'voteInit') => {\n  return BufferLayout.struct<\n    Readonly<{\n      authorizedVoter: Uint8Array;\n      authorizedWithdrawer: Uint8Array;\n      commission: number;\n      nodePubkey: Uint8Array;\n    }>\n  >(\n    [\n      publicKey('nodePubkey'),\n      publicKey('authorizedVoter'),\n      publicKey('authorizedWithdrawer'),\n      BufferLayout.u8('commission'),\n    ],\n    property,\n  );\n};\n\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */\nexport const voteAuthorizeWithSeedArgs = (\n  property: string = 'voteAuthorizeWithSeedArgs',\n) => {\n  return BufferLayout.struct<VoteAuthorizeWithSeedArgs>(\n    [\n      BufferLayout.u32('voteAuthorizationType'),\n      publicKey('currentAuthorityDerivedKeyOwnerPubkey'),\n      rustString('currentAuthorityDerivedKeySeed'),\n      publicKey('newAuthorized'),\n    ],\n    property,\n  );\n};\n\nexport function getAlloc(type: any, fields: any): number {\n  const getItemAlloc = (item: any): number => {\n    if (item.span >= 0) {\n      return item.span;\n    } else if (typeof item.alloc === 'function') {\n      return item.alloc(fields[item.property]);\n    } else if ('count' in item && 'elementLayout' in item) {\n      const field = fields[item.property];\n      if (Array.isArray(field)) {\n        return field.length * getItemAlloc(item.elementLayout);\n      }\n    } else if ('fields' in item) {\n      // This is a `Structure` whose size needs to be recursively measured.\n      return getAlloc({layout: item}, fields[item.property]);\n    }\n    // Couldn't determine allocated size of layout\n    return 0;\n  };\n\n  let alloc = 0;\n  type.layout.fields.forEach((item: any) => {\n    alloc += getItemAlloc(item);\n  });\n\n  return alloc;\n}\n", "export function decodeLength(bytes: Array<number>): number {\n  let len = 0;\n  let size = 0;\n  for (;;) {\n    let elem = bytes.shift() as number;\n    len |= (elem & 0x7f) << (size * 7);\n    size += 1;\n    if ((elem & 0x80) === 0) {\n      break;\n    }\n  }\n  return len;\n}\n\nexport function encodeLength(bytes: Array<number>, len: number) {\n  let rem_len = len;\n  for (;;) {\n    let elem = rem_len & 0x7f;\n    rem_len >>= 7;\n    if (rem_len == 0) {\n      bytes.push(elem);\n      break;\n    } else {\n      elem |= 0x80;\n      bytes.push(elem);\n    }\n  }\n}\n", "export default function (\n  condition: unknown,\n  message?: string,\n): asserts condition {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n", "import {MessageHeader, MessageAddressTableLookup} from './index';\nimport {AccountKeysFromLookups} from './account-keys';\nimport {AddressLookupTableAccount} from '../programs';\nimport {TransactionInstruction} from '../transaction';\nimport assert from '../utils/assert';\nimport {PublicKey} from '../publickey';\n\nexport type CompiledKeyMeta = {\n  isSigner: boolean;\n  isWritable: boolean;\n  isInvoked: boolean;\n};\n\ntype KeyMetaMap = Map<string, CompiledKeyMeta>;\n\nexport class CompiledKeys {\n  payer: PublicKey;\n  keyMetaMap: KeyMetaMap;\n\n  constructor(payer: PublicKey, keyMetaMap: KeyMetaMap) {\n    this.payer = payer;\n    this.keyMetaMap = keyMetaMap;\n  }\n\n  static compile(\n    instructions: Array<TransactionInstruction>,\n    payer: PublicKey,\n  ): CompiledKeys {\n    const keyMetaMap: KeyMetaMap = new Map();\n    const getOrInsertDefault = (pubkey: PublicKey): CompiledKeyMeta => {\n      const address = pubkey.toBase58();\n      let keyMeta = keyMetaMap.get(address);\n      if (keyMeta === undefined) {\n        keyMeta = {\n          isSigner: false,\n          isWritable: false,\n          isInvoked: false,\n        };\n        keyMetaMap.set(address, keyMeta);\n      }\n      return keyMeta;\n    };\n\n    const payerKeyMeta = getOrInsertDefault(payer);\n    payerKeyMeta.isSigner = true;\n    payerKeyMeta.isWritable = true;\n\n    for (const ix of instructions) {\n      getOrInsertDefault(ix.programId).isInvoked = true;\n      for (const accountMeta of ix.keys) {\n        const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n        keyMeta.isSigner ||= accountMeta.isSigner;\n        keyMeta.isWritable ||= accountMeta.isWritable;\n      }\n    }\n\n    return new CompiledKeys(payer, keyMetaMap);\n  }\n\n  getMessageComponents(): [MessageHeader, Array<PublicKey>] {\n    const mapEntries = [...this.keyMetaMap.entries()];\n    assert(mapEntries.length <= 256, 'Max static account keys length exceeded');\n\n    const writableSigners = mapEntries.filter(\n      ([, meta]) => meta.isSigner && meta.isWritable,\n    );\n    const readonlySigners = mapEntries.filter(\n      ([, meta]) => meta.isSigner && !meta.isWritable,\n    );\n    const writableNonSigners = mapEntries.filter(\n      ([, meta]) => !meta.isSigner && meta.isWritable,\n    );\n    const readonlyNonSigners = mapEntries.filter(\n      ([, meta]) => !meta.isSigner && !meta.isWritable,\n    );\n\n    const header: MessageHeader = {\n      numRequiredSignatures: writableSigners.length + readonlySigners.length,\n      numReadonlySignedAccounts: readonlySigners.length,\n      numReadonlyUnsignedAccounts: readonlyNonSigners.length,\n    };\n\n    // sanity checks\n    {\n      assert(\n        writableSigners.length > 0,\n        'Expected at least one writable signer key',\n      );\n      const [payerAddress] = writableSigners[0];\n      assert(\n        payerAddress === this.payer.toBase58(),\n        'Expected first writable signer key to be the fee payer',\n      );\n    }\n\n    const staticAccountKeys = [\n      ...writableSigners.map(([address]) => new PublicKey(address)),\n      ...readonlySigners.map(([address]) => new PublicKey(address)),\n      ...writableNonSigners.map(([address]) => new PublicKey(address)),\n      ...readonlyNonSigners.map(([address]) => new PublicKey(address)),\n    ];\n\n    return [header, staticAccountKeys];\n  }\n\n  extractTableLookup(\n    lookupTable: AddressLookupTableAccount,\n  ): [MessageAddressTableLookup, AccountKeysFromLookups] | undefined {\n    const [writableIndexes, drainedWritableKeys] =\n      this.drainKeysFoundInLookupTable(\n        lookupTable.state.addresses,\n        keyMeta =>\n          !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable,\n      );\n    const [readonlyIndexes, drainedReadonlyKeys] =\n      this.drainKeysFoundInLookupTable(\n        lookupTable.state.addresses,\n        keyMeta =>\n          !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable,\n      );\n\n    // Don't extract lookup if no keys were found\n    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n      return;\n    }\n\n    return [\n      {\n        accountKey: lookupTable.key,\n        writableIndexes,\n        readonlyIndexes,\n      },\n      {\n        writable: drainedWritableKeys,\n        readonly: drainedReadonlyKeys,\n      },\n    ];\n  }\n\n  /** @internal */\n  private drainKeysFoundInLookupTable(\n    lookupTableEntries: Array<PublicKey>,\n    keyMetaFilter: (keyMeta: CompiledKeyMeta) => boolean,\n  ): [Array<number>, Array<PublicKey>] {\n    const lookupTableIndexes = new Array();\n    const drainedKeys = new Array();\n\n    for (const [address, keyMeta] of this.keyMetaMap.entries()) {\n      if (keyMetaFilter(keyMeta)) {\n        const key = new PublicKey(address);\n        const lookupTableIndex = lookupTableEntries.findIndex(entry =>\n          entry.equals(key),\n        );\n        if (lookupTableIndex >= 0) {\n          assert(lookupTableIndex < 256, 'Max lookup table index exceeded');\n          lookupTableIndexes.push(lookupTableIndex);\n          drainedKeys.push(key);\n          this.keyMetaMap.delete(address);\n        }\n      }\n    }\n\n    return [lookupTableIndexes, drainedKeys];\n  }\n}\n", "const END_OF_BUFFER_ERROR_MESSAGE = 'Reached end of buffer unexpectedly';\n\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */\nexport function guardedShift<T>(byteArray: T[]): T {\n  if (byteArray.length === 0) {\n    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n  }\n  return byteArray.shift() as T;\n}\n\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */\nexport function guardedSplice<T>(\n  byteArray: T[],\n  ...args:\n    | [start: number, deleteCount?: number]\n    | [start: number, deleteCount: number, ...items: T[]]\n): T[] {\n  const [start] = args;\n  if (\n    args.length === 2 // Implies that `deleteCount` was supplied\n      ? start + (args[1] ?? 0) > byteArray.length\n      : start >= byteArray.length\n  ) {\n    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n  }\n  return byteArray.splice(\n    ...(args as Parameters<typeof Array.prototype.splice>),\n  );\n}\n", "import bs58 from 'bs58';\nimport {Buffer} from 'buffer';\nimport * as BufferLayout from '@solana/buffer-layout';\n\nimport {PublicKey, PUBLIC_KEY_LENGTH} from '../publickey';\nimport type {Blockhash} from '../blockhash';\nimport * as Layout from '../layout';\nimport {PACKET_DATA_SIZE, VERSION_PREFIX_MASK} from '../transaction/constants';\nimport * as shortvec from '../utils/shortvec-encoding';\nimport {toBuffer} from '../utils/to-buffer';\nimport {\n  MessageHeader,\n  MessageAddressTableLookup,\n  MessageCompiledInstruction,\n} from './index';\nimport {TransactionInstruction} from '../transaction';\nimport {CompiledKeys} from './compiled-keys';\nimport {MessageAccountKeys} from './account-keys';\nimport {guardedShift, guardedSplice} from '../utils/guarded-array-utils';\n\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */\nexport type CompiledInstruction = {\n  /** Index into the transaction keys array indicating the program account that executes this instruction */\n  programIdIndex: number;\n  /** Ordered indices into the transaction keys array indicating which accounts to pass to the program */\n  accounts: number[];\n  /** The program input data encoded as base 58 */\n  data: string;\n};\n\n/**\n * Message constructor arguments\n */\nexport type MessageArgs = {\n  /** The message header, identifying signed and read-only `accountKeys` */\n  header: MessageHeader;\n  /** All the account keys used by this transaction */\n  accountKeys: string[] | PublicKey[];\n  /** The hash of a recent ledger block */\n  recentBlockhash: Blockhash;\n  /** Instructions that will be executed in sequence and committed in one atomic transaction if all succeed. */\n  instructions: CompiledInstruction[];\n};\n\nexport type CompileLegacyArgs = {\n  payerKey: PublicKey;\n  instructions: Array<TransactionInstruction>;\n  recentBlockhash: Blockhash;\n};\n\n/**\n * List of instructions to be processed atomically\n */\nexport class Message {\n  header: MessageHeader;\n  accountKeys: PublicKey[];\n  recentBlockhash: Blockhash;\n  instructions: CompiledInstruction[];\n\n  private indexToProgramIds: Map<number, PublicKey> = new Map<\n    number,\n    PublicKey\n  >();\n\n  constructor(args: MessageArgs) {\n    this.header = args.header;\n    this.accountKeys = args.accountKeys.map(account => new PublicKey(account));\n    this.recentBlockhash = args.recentBlockhash;\n    this.instructions = args.instructions;\n    this.instructions.forEach(ix =>\n      this.indexToProgramIds.set(\n        ix.programIdIndex,\n        this.accountKeys[ix.programIdIndex],\n      ),\n    );\n  }\n\n  get version(): 'legacy' {\n    return 'legacy';\n  }\n\n  get staticAccountKeys(): Array<PublicKey> {\n    return this.accountKeys;\n  }\n\n  get compiledInstructions(): Array<MessageCompiledInstruction> {\n    return this.instructions.map(\n      (ix): MessageCompiledInstruction => ({\n        programIdIndex: ix.programIdIndex,\n        accountKeyIndexes: ix.accounts,\n        data: bs58.decode(ix.data),\n      }),\n    );\n  }\n\n  get addressTableLookups(): Array<MessageAddressTableLookup> {\n    return [];\n  }\n\n  getAccountKeys(): MessageAccountKeys {\n    return new MessageAccountKeys(this.staticAccountKeys);\n  }\n\n  static compile(args: CompileLegacyArgs): Message {\n    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n    const accountKeys = new MessageAccountKeys(staticAccountKeys);\n    const instructions = accountKeys.compileInstructions(args.instructions).map(\n      (ix: MessageCompiledInstruction): CompiledInstruction => ({\n        programIdIndex: ix.programIdIndex,\n        accounts: ix.accountKeyIndexes,\n        data: bs58.encode(ix.data),\n      }),\n    );\n    return new Message({\n      header,\n      accountKeys: staticAccountKeys,\n      recentBlockhash: args.recentBlockhash,\n      instructions,\n    });\n  }\n\n  isAccountSigner(index: number): boolean {\n    return index < this.header.numRequiredSignatures;\n  }\n\n  isAccountWritable(index: number): boolean {\n    const numSignedAccounts = this.header.numRequiredSignatures;\n    if (index >= this.header.numRequiredSignatures) {\n      const unsignedAccountIndex = index - numSignedAccounts;\n      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n      const numWritableUnsignedAccounts =\n        numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n      return unsignedAccountIndex < numWritableUnsignedAccounts;\n    } else {\n      const numWritableSignedAccounts =\n        numSignedAccounts - this.header.numReadonlySignedAccounts;\n      return index < numWritableSignedAccounts;\n    }\n  }\n\n  isProgramId(index: number): boolean {\n    return this.indexToProgramIds.has(index);\n  }\n\n  programIds(): PublicKey[] {\n    return [...this.indexToProgramIds.values()];\n  }\n\n  nonProgramIds(): PublicKey[] {\n    return this.accountKeys.filter((_, index) => !this.isProgramId(index));\n  }\n\n  serialize(): Buffer {\n    const numKeys = this.accountKeys.length;\n\n    let keyCount: number[] = [];\n    shortvec.encodeLength(keyCount, numKeys);\n\n    const instructions = this.instructions.map(instruction => {\n      const {accounts, programIdIndex} = instruction;\n      const data = Array.from(bs58.decode(instruction.data));\n\n      let keyIndicesCount: number[] = [];\n      shortvec.encodeLength(keyIndicesCount, accounts.length);\n\n      let dataCount: number[] = [];\n      shortvec.encodeLength(dataCount, data.length);\n\n      return {\n        programIdIndex,\n        keyIndicesCount: Buffer.from(keyIndicesCount),\n        keyIndices: accounts,\n        dataLength: Buffer.from(dataCount),\n        data,\n      };\n    });\n\n    let instructionCount: number[] = [];\n    shortvec.encodeLength(instructionCount, instructions.length);\n    let instructionBuffer = Buffer.alloc(PACKET_DATA_SIZE);\n    Buffer.from(instructionCount).copy(instructionBuffer);\n    let instructionBufferLength = instructionCount.length;\n\n    instructions.forEach(instruction => {\n      const instructionLayout = BufferLayout.struct<\n        Readonly<{\n          data: number[];\n          dataLength: Uint8Array;\n          keyIndices: number[];\n          keyIndicesCount: Uint8Array;\n          programIdIndex: number;\n        }>\n      >([\n        BufferLayout.u8('programIdIndex'),\n\n        BufferLayout.blob(\n          instruction.keyIndicesCount.length,\n          'keyIndicesCount',\n        ),\n        BufferLayout.seq(\n          BufferLayout.u8('keyIndex'),\n          instruction.keyIndices.length,\n          'keyIndices',\n        ),\n        BufferLayout.blob(instruction.dataLength.length, 'dataLength'),\n        BufferLayout.seq(\n          BufferLayout.u8('userdatum'),\n          instruction.data.length,\n          'data',\n        ),\n      ]);\n      const length = instructionLayout.encode(\n        instruction,\n        instructionBuffer,\n        instructionBufferLength,\n      );\n      instructionBufferLength += length;\n    });\n    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n\n    const signDataLayout = BufferLayout.struct<\n      Readonly<{\n        keyCount: Uint8Array;\n        keys: Uint8Array[];\n        numReadonlySignedAccounts: Uint8Array;\n        numReadonlyUnsignedAccounts: Uint8Array;\n        numRequiredSignatures: Uint8Array;\n        recentBlockhash: Uint8Array;\n      }>\n    >([\n      BufferLayout.blob(1, 'numRequiredSignatures'),\n      BufferLayout.blob(1, 'numReadonlySignedAccounts'),\n      BufferLayout.blob(1, 'numReadonlyUnsignedAccounts'),\n      BufferLayout.blob(keyCount.length, 'keyCount'),\n      BufferLayout.seq(Layout.publicKey('key'), numKeys, 'keys'),\n      Layout.publicKey('recentBlockhash'),\n    ]);\n\n    const transaction = {\n      numRequiredSignatures: Buffer.from([this.header.numRequiredSignatures]),\n      numReadonlySignedAccounts: Buffer.from([\n        this.header.numReadonlySignedAccounts,\n      ]),\n      numReadonlyUnsignedAccounts: Buffer.from([\n        this.header.numReadonlyUnsignedAccounts,\n      ]),\n      keyCount: Buffer.from(keyCount),\n      keys: this.accountKeys.map(key => toBuffer(key.toBytes())),\n      recentBlockhash: bs58.decode(this.recentBlockhash),\n    };\n\n    let signData = Buffer.alloc(2048);\n    const length = signDataLayout.encode(transaction, signData);\n    instructionBuffer.copy(signData, length);\n    return signData.slice(0, length + instructionBuffer.length);\n  }\n\n  /**\n   * Decode a compiled message into a Message object.\n   */\n  static from(buffer: Buffer | Uint8Array | Array<number>): Message {\n    // Slice up wire data\n    let byteArray = [...buffer];\n\n    const numRequiredSignatures = guardedShift(byteArray);\n    if (\n      numRequiredSignatures !==\n      (numRequiredSignatures & VERSION_PREFIX_MASK)\n    ) {\n      throw new Error(\n        'Versioned messages must be deserialized with VersionedMessage.deserialize()',\n      );\n    }\n\n    const numReadonlySignedAccounts = guardedShift(byteArray);\n    const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n\n    const accountCount = shortvec.decodeLength(byteArray);\n    let accountKeys = [];\n    for (let i = 0; i < accountCount; i++) {\n      const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n      accountKeys.push(new PublicKey(Buffer.from(account)));\n    }\n\n    const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n\n    const instructionCount = shortvec.decodeLength(byteArray);\n    let instructions: CompiledInstruction[] = [];\n    for (let i = 0; i < instructionCount; i++) {\n      const programIdIndex = guardedShift(byteArray);\n      const accountCount = shortvec.decodeLength(byteArray);\n      const accounts = guardedSplice(byteArray, 0, accountCount);\n      const dataLength = shortvec.decodeLength(byteArray);\n      const dataSlice = guardedSplice(byteArray, 0, dataLength);\n      const data = bs58.encode(Buffer.from(dataSlice));\n      instructions.push({\n        programIdIndex,\n        accounts,\n        data,\n      });\n    }\n\n    const messageArgs = {\n      header: {\n        numRequiredSignatures,\n        numReadonlySignedAccounts,\n        numReadonlyUnsignedAccounts,\n      },\n      recentBlockhash: bs58.encode(Buffer.from(recentBlockhash)),\n      accountKeys,\n      instructions,\n    };\n\n    return new Message(messageArgs);\n  }\n}\n", "import bs58 from 'bs58';\nimport * as BufferLayout from '@solana/buffer-layout';\n\nimport * as Layout from '../layout';\nimport {Blockhash} from '../blockhash';\nimport {\n  MessageHeader,\n  MessageAddressTableLookup,\n  MessageCompiledInstruction,\n} from './index';\nimport {PublicKey, PUBLIC_KEY_LENGTH} from '../publickey';\nimport * as shortvec from '../utils/shortvec-encoding';\nimport assert from '../utils/assert';\nimport {PACKET_DATA_SIZE, VERSION_PREFIX_MASK} from '../transaction/constants';\nimport {TransactionInstruction} from '../transaction';\nimport {AddressLookupTableAccount} from '../programs';\nimport {CompiledKeys} from './compiled-keys';\nimport {AccountKeysFromLookups, MessageAccountKeys} from './account-keys';\nimport {guardedShift, guardedSplice} from '../utils/guarded-array-utils';\n\n/**\n * Message constructor arguments\n */\nexport type MessageV0Args = {\n  /** The message header, identifying signed and read-only `accountKeys` */\n  header: MessageHeader;\n  /** The static account keys used by this transaction */\n  staticAccountKeys: PublicKey[];\n  /** The hash of a recent ledger block */\n  recentBlockhash: Blockhash;\n  /** Instructions that will be executed in sequence and committed in one atomic transaction if all succeed. */\n  compiledInstructions: MessageCompiledInstruction[];\n  /** Instructions that will be executed in sequence and committed in one atomic transaction if all succeed. */\n  addressTableLookups: MessageAddressTableLookup[];\n};\n\nexport type CompileV0Args = {\n  payerKey: PublicKey;\n  instructions: Array<TransactionInstruction>;\n  recentBlockhash: Blockhash;\n  addressLookupTableAccounts?: Array<AddressLookupTableAccount>;\n};\n\nexport type GetAccountKeysArgs =\n  | {\n      accountKeysFromLookups?: AccountKeysFromLookups | null;\n    }\n  | {\n      addressLookupTableAccounts?: AddressLookupTableAccount[] | null;\n    };\n\nexport class MessageV0 {\n  header: MessageHeader;\n  staticAccountKeys: Array<PublicKey>;\n  recentBlockhash: Blockhash;\n  compiledInstructions: Array<MessageCompiledInstruction>;\n  addressTableLookups: Array<MessageAddressTableLookup>;\n\n  constructor(args: MessageV0Args) {\n    this.header = args.header;\n    this.staticAccountKeys = args.staticAccountKeys;\n    this.recentBlockhash = args.recentBlockhash;\n    this.compiledInstructions = args.compiledInstructions;\n    this.addressTableLookups = args.addressTableLookups;\n  }\n\n  get version(): 0 {\n    return 0;\n  }\n\n  get numAccountKeysFromLookups(): number {\n    let count = 0;\n    for (const lookup of this.addressTableLookups) {\n      count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n    }\n    return count;\n  }\n\n  getAccountKeys(args?: GetAccountKeysArgs): MessageAccountKeys {\n    let accountKeysFromLookups: AccountKeysFromLookups | undefined;\n    if (\n      args &&\n      'accountKeysFromLookups' in args &&\n      args.accountKeysFromLookups\n    ) {\n      if (\n        this.numAccountKeysFromLookups !=\n        args.accountKeysFromLookups.writable.length +\n          args.accountKeysFromLookups.readonly.length\n      ) {\n        throw new Error(\n          'Failed to get account keys because of a mismatch in the number of account keys from lookups',\n        );\n      }\n      accountKeysFromLookups = args.accountKeysFromLookups;\n    } else if (\n      args &&\n      'addressLookupTableAccounts' in args &&\n      args.addressLookupTableAccounts\n    ) {\n      accountKeysFromLookups = this.resolveAddressTableLookups(\n        args.addressLookupTableAccounts,\n      );\n    } else if (this.addressTableLookups.length > 0) {\n      throw new Error(\n        'Failed to get account keys because address table lookups were not resolved',\n      );\n    }\n    return new MessageAccountKeys(\n      this.staticAccountKeys,\n      accountKeysFromLookups,\n    );\n  }\n\n  isAccountSigner(index: number): boolean {\n    return index < this.header.numRequiredSignatures;\n  }\n\n  isAccountWritable(index: number): boolean {\n    const numSignedAccounts = this.header.numRequiredSignatures;\n    const numStaticAccountKeys = this.staticAccountKeys.length;\n    if (index >= numStaticAccountKeys) {\n      const lookupAccountKeysIndex = index - numStaticAccountKeys;\n      const numWritableLookupAccountKeys = this.addressTableLookups.reduce(\n        (count, lookup) => count + lookup.writableIndexes.length,\n        0,\n      );\n      return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n    } else if (index >= this.header.numRequiredSignatures) {\n      const unsignedAccountIndex = index - numSignedAccounts;\n      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n      const numWritableUnsignedAccounts =\n        numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n      return unsignedAccountIndex < numWritableUnsignedAccounts;\n    } else {\n      const numWritableSignedAccounts =\n        numSignedAccounts - this.header.numReadonlySignedAccounts;\n      return index < numWritableSignedAccounts;\n    }\n  }\n\n  resolveAddressTableLookups(\n    addressLookupTableAccounts: AddressLookupTableAccount[],\n  ): AccountKeysFromLookups {\n    const accountKeysFromLookups: AccountKeysFromLookups = {\n      writable: [],\n      readonly: [],\n    };\n\n    for (const tableLookup of this.addressTableLookups) {\n      const tableAccount = addressLookupTableAccounts.find(account =>\n        account.key.equals(tableLookup.accountKey),\n      );\n      if (!tableAccount) {\n        throw new Error(\n          `Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`,\n        );\n      }\n\n      for (const index of tableLookup.writableIndexes) {\n        if (index < tableAccount.state.addresses.length) {\n          accountKeysFromLookups.writable.push(\n            tableAccount.state.addresses[index],\n          );\n        } else {\n          throw new Error(\n            `Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`,\n          );\n        }\n      }\n\n      for (const index of tableLookup.readonlyIndexes) {\n        if (index < tableAccount.state.addresses.length) {\n          accountKeysFromLookups.readonly.push(\n            tableAccount.state.addresses[index],\n          );\n        } else {\n          throw new Error(\n            `Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`,\n          );\n        }\n      }\n    }\n\n    return accountKeysFromLookups;\n  }\n\n  static compile(args: CompileV0Args): MessageV0 {\n    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n\n    const addressTableLookups = new Array<MessageAddressTableLookup>();\n    const accountKeysFromLookups: AccountKeysFromLookups = {\n      writable: new Array(),\n      readonly: new Array(),\n    };\n    const lookupTableAccounts = args.addressLookupTableAccounts || [];\n    for (const lookupTable of lookupTableAccounts) {\n      const extractResult = compiledKeys.extractTableLookup(lookupTable);\n      if (extractResult !== undefined) {\n        const [addressTableLookup, {writable, readonly}] = extractResult;\n        addressTableLookups.push(addressTableLookup);\n        accountKeysFromLookups.writable.push(...writable);\n        accountKeysFromLookups.readonly.push(...readonly);\n      }\n    }\n\n    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n    const accountKeys = new MessageAccountKeys(\n      staticAccountKeys,\n      accountKeysFromLookups,\n    );\n    const compiledInstructions = accountKeys.compileInstructions(\n      args.instructions,\n    );\n    return new MessageV0({\n      header,\n      staticAccountKeys,\n      recentBlockhash: args.recentBlockhash,\n      compiledInstructions,\n      addressTableLookups,\n    });\n  }\n\n  serialize(): Uint8Array {\n    const encodedStaticAccountKeysLength = Array<number>();\n    shortvec.encodeLength(\n      encodedStaticAccountKeysLength,\n      this.staticAccountKeys.length,\n    );\n\n    const serializedInstructions = this.serializeInstructions();\n    const encodedInstructionsLength = Array<number>();\n    shortvec.encodeLength(\n      encodedInstructionsLength,\n      this.compiledInstructions.length,\n    );\n\n    const serializedAddressTableLookups = this.serializeAddressTableLookups();\n    const encodedAddressTableLookupsLength = Array<number>();\n    shortvec.encodeLength(\n      encodedAddressTableLookupsLength,\n      this.addressTableLookups.length,\n    );\n\n    const messageLayout = BufferLayout.struct<{\n      prefix: number;\n      header: MessageHeader;\n      staticAccountKeysLength: Uint8Array;\n      staticAccountKeys: Array<Uint8Array>;\n      recentBlockhash: Uint8Array;\n      instructionsLength: Uint8Array;\n      serializedInstructions: Uint8Array;\n      addressTableLookupsLength: Uint8Array;\n      serializedAddressTableLookups: Uint8Array;\n    }>([\n      BufferLayout.u8('prefix'),\n      BufferLayout.struct<MessageHeader>(\n        [\n          BufferLayout.u8('numRequiredSignatures'),\n          BufferLayout.u8('numReadonlySignedAccounts'),\n          BufferLayout.u8('numReadonlyUnsignedAccounts'),\n        ],\n        'header',\n      ),\n      BufferLayout.blob(\n        encodedStaticAccountKeysLength.length,\n        'staticAccountKeysLength',\n      ),\n      BufferLayout.seq(\n        Layout.publicKey(),\n        this.staticAccountKeys.length,\n        'staticAccountKeys',\n      ),\n      Layout.publicKey('recentBlockhash'),\n      BufferLayout.blob(encodedInstructionsLength.length, 'instructionsLength'),\n      BufferLayout.blob(\n        serializedInstructions.length,\n        'serializedInstructions',\n      ),\n      BufferLayout.blob(\n        encodedAddressTableLookupsLength.length,\n        'addressTableLookupsLength',\n      ),\n      BufferLayout.blob(\n        serializedAddressTableLookups.length,\n        'serializedAddressTableLookups',\n      ),\n    ]);\n\n    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n    const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n    const serializedMessageLength = messageLayout.encode(\n      {\n        prefix: MESSAGE_VERSION_0_PREFIX,\n        header: this.header,\n        staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n        staticAccountKeys: this.staticAccountKeys.map(key => key.toBytes()),\n        recentBlockhash: bs58.decode(this.recentBlockhash),\n        instructionsLength: new Uint8Array(encodedInstructionsLength),\n        serializedInstructions,\n        addressTableLookupsLength: new Uint8Array(\n          encodedAddressTableLookupsLength,\n        ),\n        serializedAddressTableLookups,\n      },\n      serializedMessage,\n    );\n    return serializedMessage.slice(0, serializedMessageLength);\n  }\n\n  private serializeInstructions(): Uint8Array {\n    let serializedLength = 0;\n    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n    for (const instruction of this.compiledInstructions) {\n      const encodedAccountKeyIndexesLength = Array<number>();\n      shortvec.encodeLength(\n        encodedAccountKeyIndexesLength,\n        instruction.accountKeyIndexes.length,\n      );\n\n      const encodedDataLength = Array<number>();\n      shortvec.encodeLength(encodedDataLength, instruction.data.length);\n\n      const instructionLayout = BufferLayout.struct<{\n        programIdIndex: number;\n        encodedAccountKeyIndexesLength: Uint8Array;\n        accountKeyIndexes: number[];\n        encodedDataLength: Uint8Array;\n        data: Uint8Array;\n      }>([\n        BufferLayout.u8('programIdIndex'),\n        BufferLayout.blob(\n          encodedAccountKeyIndexesLength.length,\n          'encodedAccountKeyIndexesLength',\n        ),\n        BufferLayout.seq(\n          BufferLayout.u8(),\n          instruction.accountKeyIndexes.length,\n          'accountKeyIndexes',\n        ),\n        BufferLayout.blob(encodedDataLength.length, 'encodedDataLength'),\n        BufferLayout.blob(instruction.data.length, 'data'),\n      ]);\n\n      serializedLength += instructionLayout.encode(\n        {\n          programIdIndex: instruction.programIdIndex,\n          encodedAccountKeyIndexesLength: new Uint8Array(\n            encodedAccountKeyIndexesLength,\n          ),\n          accountKeyIndexes: instruction.accountKeyIndexes,\n          encodedDataLength: new Uint8Array(encodedDataLength),\n          data: instruction.data,\n        },\n        serializedInstructions,\n        serializedLength,\n      );\n    }\n\n    return serializedInstructions.slice(0, serializedLength);\n  }\n\n  private serializeAddressTableLookups(): Uint8Array {\n    let serializedLength = 0;\n    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n    for (const lookup of this.addressTableLookups) {\n      const encodedWritableIndexesLength = Array<number>();\n      shortvec.encodeLength(\n        encodedWritableIndexesLength,\n        lookup.writableIndexes.length,\n      );\n\n      const encodedReadonlyIndexesLength = Array<number>();\n      shortvec.encodeLength(\n        encodedReadonlyIndexesLength,\n        lookup.readonlyIndexes.length,\n      );\n\n      const addressTableLookupLayout = BufferLayout.struct<{\n        accountKey: Uint8Array;\n        encodedWritableIndexesLength: Uint8Array;\n        writableIndexes: number[];\n        encodedReadonlyIndexesLength: Uint8Array;\n        readonlyIndexes: number[];\n      }>([\n        Layout.publicKey('accountKey'),\n        BufferLayout.blob(\n          encodedWritableIndexesLength.length,\n          'encodedWritableIndexesLength',\n        ),\n        BufferLayout.seq(\n          BufferLayout.u8(),\n          lookup.writableIndexes.length,\n          'writableIndexes',\n        ),\n        BufferLayout.blob(\n          encodedReadonlyIndexesLength.length,\n          'encodedReadonlyIndexesLength',\n        ),\n        BufferLayout.seq(\n          BufferLayout.u8(),\n          lookup.readonlyIndexes.length,\n          'readonlyIndexes',\n        ),\n      ]);\n\n      serializedLength += addressTableLookupLayout.encode(\n        {\n          accountKey: lookup.accountKey.toBytes(),\n          encodedWritableIndexesLength: new Uint8Array(\n            encodedWritableIndexesLength,\n          ),\n          writableIndexes: lookup.writableIndexes,\n          encodedReadonlyIndexesLength: new Uint8Array(\n            encodedReadonlyIndexesLength,\n          ),\n          readonlyIndexes: lookup.readonlyIndexes,\n        },\n        serializedAddressTableLookups,\n        serializedLength,\n      );\n    }\n\n    return serializedAddressTableLookups.slice(0, serializedLength);\n  }\n\n  static deserialize(serializedMessage: Uint8Array): MessageV0 {\n    let byteArray = [...serializedMessage];\n\n    const prefix = guardedShift(byteArray);\n    const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n    assert(\n      prefix !== maskedPrefix,\n      `Expected versioned message but received legacy message`,\n    );\n\n    const version = maskedPrefix;\n    assert(\n      version === 0,\n      `Expected versioned message with version 0 but found version ${version}`,\n    );\n\n    const header: MessageHeader = {\n      numRequiredSignatures: guardedShift(byteArray),\n      numReadonlySignedAccounts: guardedShift(byteArray),\n      numReadonlyUnsignedAccounts: guardedShift(byteArray),\n    };\n\n    const staticAccountKeys = [];\n    const staticAccountKeysLength = shortvec.decodeLength(byteArray);\n    for (let i = 0; i < staticAccountKeysLength; i++) {\n      staticAccountKeys.push(\n        new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)),\n      );\n    }\n\n    const recentBlockhash = bs58.encode(\n      guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH),\n    );\n\n    const instructionCount = shortvec.decodeLength(byteArray);\n    const compiledInstructions: MessageCompiledInstruction[] = [];\n    for (let i = 0; i < instructionCount; i++) {\n      const programIdIndex = guardedShift(byteArray);\n      const accountKeyIndexesLength = shortvec.decodeLength(byteArray);\n      const accountKeyIndexes = guardedSplice(\n        byteArray,\n        0,\n        accountKeyIndexesLength,\n      );\n      const dataLength = shortvec.decodeLength(byteArray);\n      const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n      compiledInstructions.push({\n        programIdIndex,\n        accountKeyIndexes,\n        data,\n      });\n    }\n\n    const addressTableLookupsCount = shortvec.decodeLength(byteArray);\n    const addressTableLookups: MessageAddressTableLookup[] = [];\n    for (let i = 0; i < addressTableLookupsCount; i++) {\n      const accountKey = new PublicKey(\n        guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH),\n      );\n      const writableIndexesLength = shortvec.decodeLength(byteArray);\n      const writableIndexes = guardedSplice(\n        byteArray,\n        0,\n        writableIndexesLength,\n      );\n      const readonlyIndexesLength = shortvec.decodeLength(byteArray);\n      const readonlyIndexes = guardedSplice(\n        byteArray,\n        0,\n        readonlyIndexesLength,\n      );\n      addressTableLookups.push({\n        accountKey,\n        writableIndexes,\n        readonlyIndexes,\n      });\n    }\n\n    return new MessageV0({\n      header,\n      staticAccountKeys,\n      recentBlockhash,\n      compiledInstructions,\n      addressTableLookups,\n    });\n  }\n}\n", "import {VERSION_PREFIX_MASK} from '../transaction/constants';\nimport {Message} from './legacy';\nimport {MessageV0} from './v0';\n\nexport type VersionedMessage = Message | MessageV0;\n// eslint-disable-next-line no-redeclare\nexport const VersionedMessage = {\n  deserializeMessageVersion(serializedMessage: Uint8Array): 'legacy' | number {\n    const prefix = serializedMessage[0];\n    const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n\n    // if the highest bit of the prefix is not set, the message is not versioned\n    if (maskedPrefix === prefix) {\n      return 'legacy';\n    }\n\n    // the lower 7 bits of the prefix indicate the message version\n    return maskedPrefix;\n  },\n\n  deserialize: (serializedMessage: Uint8Array): VersionedMessage => {\n    const version =\n      VersionedMessage.deserializeMessageVersion(serializedMessage);\n    if (version === 'legacy') {\n      return Message.from(serializedMessage);\n    }\n\n    if (version === 0) {\n      return MessageV0.deserialize(serializedMessage);\n    } else {\n      throw new Error(\n        `Transaction message version ${version} deserialization is not supported`,\n      );\n    }\n  },\n};\n", "import bs58 from 'bs58';\nimport {Buffer} from 'buffer';\n\nimport {PACKET_DATA_SIZE, SIGNATURE_LENGTH_IN_BYTES} from './constants';\nimport {Connection} from '../connection';\nimport {Message} from '../message';\nimport {PublicKey} from '../publickey';\nimport * as shortvec from '../utils/shortvec-encoding';\nimport {toBuffer} from '../utils/to-buffer';\nimport invariant from '../utils/assert';\nimport type {Signer} from '../keypair';\nimport type {Blockhash} from '../blockhash';\nimport type {CompiledInstruction} from '../message';\nimport {sign, verify} from '../utils/ed25519';\nimport {guardedSplice} from '../utils/guarded-array-utils';\n\n/** @internal */\ntype MessageSignednessErrors = {\n  invalid?: PublicKey[];\n  missing?: PublicKey[];\n};\n\n/**\n * Transaction signature as base-58 encoded string\n */\nexport type TransactionSignature = string;\n\nexport const enum TransactionStatus {\n  BLOCKHEIGHT_EXCEEDED,\n  PROCESSED,\n  TIMED_OUT,\n  NONCE_INVALID,\n}\n\n/**\n * Default (empty) signature\n */\nconst DEFAULT_SIGNATURE = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n\n/**\n * Account metadata used to define instructions\n */\nexport type AccountMeta = {\n  /** An account's public key */\n  pubkey: PublicKey;\n  /** True if an instruction requires a transaction signature matching `pubkey` */\n  isSigner: boolean;\n  /** True if the `pubkey` can be loaded as a read-write account. */\n  isWritable: boolean;\n};\n\n/**\n * List of TransactionInstruction object fields that may be initialized at construction\n */\nexport type TransactionInstructionCtorFields = {\n  keys: Array<AccountMeta>;\n  programId: PublicKey;\n  data?: Buffer;\n};\n\n/**\n * Configuration object for Transaction.serialize()\n */\nexport type SerializeConfig = {\n  /** Require all transaction signatures be present (default: true) */\n  requireAllSignatures?: boolean;\n  /** Verify provided signatures (default: true) */\n  verifySignatures?: boolean;\n};\n\n/**\n * @internal\n */\nexport interface TransactionInstructionJSON {\n  keys: {\n    pubkey: string;\n    isSigner: boolean;\n    isWritable: boolean;\n  }[];\n  programId: string;\n  data: number[];\n}\n\n/**\n * Transaction Instruction class\n */\nexport class TransactionInstruction {\n  /**\n   * Public keys to include in this transaction\n   * Boolean represents whether this pubkey needs to sign the transaction\n   */\n  keys: Array<AccountMeta>;\n\n  /**\n   * Program Id to execute\n   */\n  programId: PublicKey;\n\n  /**\n   * Program input\n   */\n  data: Buffer = Buffer.alloc(0);\n\n  constructor(opts: TransactionInstructionCtorFields) {\n    this.programId = opts.programId;\n    this.keys = opts.keys;\n    if (opts.data) {\n      this.data = opts.data;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  toJSON(): TransactionInstructionJSON {\n    return {\n      keys: this.keys.map(({pubkey, isSigner, isWritable}) => ({\n        pubkey: pubkey.toJSON(),\n        isSigner,\n        isWritable,\n      })),\n      programId: this.programId.toJSON(),\n      data: [...this.data],\n    };\n  }\n}\n\n/**\n * Pair of signature and corresponding public key\n */\nexport type SignaturePubkeyPair = {\n  signature: Buffer | null;\n  publicKey: PublicKey;\n};\n\n/**\n * List of Transaction object fields that may be initialized at construction\n */\nexport type TransactionCtorFields_DEPRECATED = {\n  /** Optional nonce information used for offline nonce'd transactions */\n  nonceInfo?: NonceInformation | null;\n  /** The transaction fee payer */\n  feePayer?: PublicKey | null;\n  /** One or more signatures */\n  signatures?: Array<SignaturePubkeyPair>;\n  /** A recent blockhash */\n  recentBlockhash?: Blockhash;\n};\n\n// For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\nexport type TransactionCtorFields = TransactionCtorFields_DEPRECATED;\n\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */\nexport type TransactionBlockhashCtor = {\n  /** The transaction fee payer */\n  feePayer?: PublicKey | null;\n  /** One or more signatures */\n  signatures?: Array<SignaturePubkeyPair>;\n  /** A recent blockhash */\n  blockhash: Blockhash;\n  /** the last block chain can advance to before tx is declared expired */\n  lastValidBlockHeight: number;\n};\n\n/**\n * Use these options to construct a durable nonce transaction.\n */\nexport type TransactionNonceCtor = {\n  /** The transaction fee payer */\n  feePayer?: PublicKey | null;\n  minContextSlot: number;\n  nonceInfo: NonceInformation;\n  /** One or more signatures */\n  signatures?: Array<SignaturePubkeyPair>;\n};\n\n/**\n * Nonce information to be used to build an offline Transaction.\n */\nexport type NonceInformation = {\n  /** The current blockhash stored in the nonce */\n  nonce: Blockhash;\n  /** AdvanceNonceAccount Instruction */\n  nonceInstruction: TransactionInstruction;\n};\n\n/**\n * @internal\n */\nexport interface TransactionJSON {\n  recentBlockhash: string | null;\n  feePayer: string | null;\n  nonceInfo: {\n    nonce: string;\n    nonceInstruction: TransactionInstructionJSON;\n  } | null;\n  instructions: TransactionInstructionJSON[];\n  signers: string[];\n}\n\n/**\n * Transaction class\n */\nexport class Transaction {\n  /**\n   * Signatures for the transaction.  Typically created by invoking the\n   * `sign()` method\n   */\n  signatures: Array<SignaturePubkeyPair> = [];\n\n  /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */\n  get signature(): Buffer | null {\n    if (this.signatures.length > 0) {\n      return this.signatures[0].signature;\n    }\n    return null;\n  }\n\n  /**\n   * The transaction fee payer\n   */\n  feePayer?: PublicKey;\n\n  /**\n   * The instructions to atomically execute\n   */\n  instructions: Array<TransactionInstruction> = [];\n\n  /**\n   * A recent transaction id. Must be populated by the caller\n   */\n  recentBlockhash?: Blockhash;\n\n  /**\n   * the last block chain can advance to before tx is declared expired\n   * */\n  lastValidBlockHeight?: number;\n\n  /**\n   * Optional Nonce information. If populated, transaction will use a durable\n   * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n   */\n  nonceInfo?: NonceInformation;\n\n  /**\n   * If this is a nonce transaction this represents the minimum slot from which\n   * to evaluate if the nonce has advanced when attempting to confirm the\n   * transaction. This protects against a case where the transaction confirmation\n   * logic loads the nonce account from an old slot and assumes the mismatch in\n   * nonce value implies that the nonce has been advanced.\n   */\n  minNonceContextSlot?: number;\n\n  /**\n   * @internal\n   */\n  _message?: Message;\n\n  /**\n   * @internal\n   */\n  _json?: TransactionJSON;\n\n  // Construct a transaction with a blockhash and lastValidBlockHeight\n  constructor(opts?: TransactionBlockhashCtor);\n\n  // Construct a transaction using a durable nonce\n  constructor(opts?: TransactionNonceCtor);\n\n  /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */\n  constructor(opts?: TransactionCtorFields_DEPRECATED);\n\n  /**\n   * Construct an empty Transaction\n   */\n  constructor(\n    opts?:\n      | TransactionBlockhashCtor\n      | TransactionNonceCtor\n      | TransactionCtorFields_DEPRECATED,\n  ) {\n    if (!opts) {\n      return;\n    }\n    if (opts.feePayer) {\n      this.feePayer = opts.feePayer;\n    }\n    if (opts.signatures) {\n      this.signatures = opts.signatures;\n    }\n    if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {\n      const {minContextSlot, nonceInfo} = opts as TransactionNonceCtor;\n      this.minNonceContextSlot = minContextSlot;\n      this.nonceInfo = nonceInfo;\n    } else if (\n      Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')\n    ) {\n      const {blockhash, lastValidBlockHeight} =\n        opts as TransactionBlockhashCtor;\n      this.recentBlockhash = blockhash;\n      this.lastValidBlockHeight = lastValidBlockHeight;\n    } else {\n      const {recentBlockhash, nonceInfo} =\n        opts as TransactionCtorFields_DEPRECATED;\n      if (nonceInfo) {\n        this.nonceInfo = nonceInfo;\n      }\n      this.recentBlockhash = recentBlockhash;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  toJSON(): TransactionJSON {\n    return {\n      recentBlockhash: this.recentBlockhash || null,\n      feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n      nonceInfo: this.nonceInfo\n        ? {\n            nonce: this.nonceInfo.nonce,\n            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),\n          }\n        : null,\n      instructions: this.instructions.map(instruction => instruction.toJSON()),\n      signers: this.signatures.map(({publicKey}) => {\n        return publicKey.toJSON();\n      }),\n    };\n  }\n\n  /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */\n  add(\n    ...items: Array<\n      Transaction | TransactionInstruction | TransactionInstructionCtorFields\n    >\n  ): Transaction {\n    if (items.length === 0) {\n      throw new Error('No instructions');\n    }\n\n    items.forEach((item: any) => {\n      if ('instructions' in item) {\n        this.instructions = this.instructions.concat(item.instructions);\n      } else if ('data' in item && 'programId' in item && 'keys' in item) {\n        this.instructions.push(item);\n      } else {\n        this.instructions.push(new TransactionInstruction(item));\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Compile transaction data\n   */\n  compileMessage(): Message {\n    if (\n      this._message &&\n      JSON.stringify(this.toJSON()) === JSON.stringify(this._json)\n    ) {\n      return this._message;\n    }\n\n    let recentBlockhash;\n    let instructions: TransactionInstruction[];\n    if (this.nonceInfo) {\n      recentBlockhash = this.nonceInfo.nonce;\n      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];\n      } else {\n        instructions = this.instructions;\n      }\n    } else {\n      recentBlockhash = this.recentBlockhash;\n      instructions = this.instructions;\n    }\n    if (!recentBlockhash) {\n      throw new Error('Transaction recentBlockhash required');\n    }\n\n    if (instructions.length < 1) {\n      console.warn('No instructions provided');\n    }\n\n    let feePayer: PublicKey;\n    if (this.feePayer) {\n      feePayer = this.feePayer;\n    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n      // Use implicit fee payer\n      feePayer = this.signatures[0].publicKey;\n    } else {\n      throw new Error('Transaction fee payer required');\n    }\n\n    for (let i = 0; i < instructions.length; i++) {\n      if (instructions[i].programId === undefined) {\n        throw new Error(\n          `Transaction instruction index ${i} has undefined program id`,\n        );\n      }\n    }\n\n    const programIds: string[] = [];\n    const accountMetas: AccountMeta[] = [];\n    instructions.forEach(instruction => {\n      instruction.keys.forEach(accountMeta => {\n        accountMetas.push({...accountMeta});\n      });\n\n      const programId = instruction.programId.toString();\n      if (!programIds.includes(programId)) {\n        programIds.push(programId);\n      }\n    });\n\n    // Append programID account metas\n    programIds.forEach(programId => {\n      accountMetas.push({\n        pubkey: new PublicKey(programId),\n        isSigner: false,\n        isWritable: false,\n      });\n    });\n\n    // Cull duplicate account metas\n    const uniqueMetas: AccountMeta[] = [];\n    accountMetas.forEach(accountMeta => {\n      const pubkeyString = accountMeta.pubkey.toString();\n      const uniqueIndex = uniqueMetas.findIndex(x => {\n        return x.pubkey.toString() === pubkeyString;\n      });\n      if (uniqueIndex > -1) {\n        uniqueMetas[uniqueIndex].isWritable =\n          uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n        uniqueMetas[uniqueIndex].isSigner =\n          uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n      } else {\n        uniqueMetas.push(accountMeta);\n      }\n    });\n\n    // Sort. Prioritizing first by signer, then by writable\n    uniqueMetas.sort(function (x, y) {\n      if (x.isSigner !== y.isSigner) {\n        // Signers always come before non-signers\n        return x.isSigner ? -1 : 1;\n      }\n      if (x.isWritable !== y.isWritable) {\n        // Writable accounts always come before read-only accounts\n        return x.isWritable ? -1 : 1;\n      }\n      // Otherwise, sort by pubkey, stringwise.\n      const options = {\n        localeMatcher: 'best fit',\n        usage: 'sort',\n        sensitivity: 'variant',\n        ignorePunctuation: false,\n        numeric: false,\n        caseFirst: 'lower',\n      } as Intl.CollatorOptions;\n      return x.pubkey\n        .toBase58()\n        .localeCompare(y.pubkey.toBase58(), 'en', options);\n    });\n\n    // Move fee payer to the front\n    const feePayerIndex = uniqueMetas.findIndex(x => {\n      return x.pubkey.equals(feePayer);\n    });\n    if (feePayerIndex > -1) {\n      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n      payerMeta.isSigner = true;\n      payerMeta.isWritable = true;\n      uniqueMetas.unshift(payerMeta);\n    } else {\n      uniqueMetas.unshift({\n        pubkey: feePayer,\n        isSigner: true,\n        isWritable: true,\n      });\n    }\n\n    // Disallow unknown signers\n    for (const signature of this.signatures) {\n      const uniqueIndex = uniqueMetas.findIndex(x => {\n        return x.pubkey.equals(signature.publicKey);\n      });\n      if (uniqueIndex > -1) {\n        if (!uniqueMetas[uniqueIndex].isSigner) {\n          uniqueMetas[uniqueIndex].isSigner = true;\n          console.warn(\n            'Transaction references a signature that is unnecessary, ' +\n              'only the fee payer and instruction signer accounts should sign a transaction. ' +\n              'This behavior is deprecated and will throw an error in the next major version release.',\n          );\n        }\n      } else {\n        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n      }\n    }\n\n    let numRequiredSignatures = 0;\n    let numReadonlySignedAccounts = 0;\n    let numReadonlyUnsignedAccounts = 0;\n\n    // Split out signing from non-signing keys and count header values\n    const signedKeys: string[] = [];\n    const unsignedKeys: string[] = [];\n    uniqueMetas.forEach(({pubkey, isSigner, isWritable}) => {\n      if (isSigner) {\n        signedKeys.push(pubkey.toString());\n        numRequiredSignatures += 1;\n        if (!isWritable) {\n          numReadonlySignedAccounts += 1;\n        }\n      } else {\n        unsignedKeys.push(pubkey.toString());\n        if (!isWritable) {\n          numReadonlyUnsignedAccounts += 1;\n        }\n      }\n    });\n\n    const accountKeys = signedKeys.concat(unsignedKeys);\n    const compiledInstructions: CompiledInstruction[] = instructions.map(\n      instruction => {\n        const {data, programId} = instruction;\n        return {\n          programIdIndex: accountKeys.indexOf(programId.toString()),\n          accounts: instruction.keys.map(meta =>\n            accountKeys.indexOf(meta.pubkey.toString()),\n          ),\n          data: bs58.encode(data),\n        };\n      },\n    );\n\n    compiledInstructions.forEach(instruction => {\n      invariant(instruction.programIdIndex >= 0);\n      instruction.accounts.forEach(keyIndex => invariant(keyIndex >= 0));\n    });\n\n    return new Message({\n      header: {\n        numRequiredSignatures,\n        numReadonlySignedAccounts,\n        numReadonlyUnsignedAccounts,\n      },\n      accountKeys,\n      recentBlockhash,\n      instructions: compiledInstructions,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _compile(): Message {\n    const message = this.compileMessage();\n    const signedKeys = message.accountKeys.slice(\n      0,\n      message.header.numRequiredSignatures,\n    );\n\n    if (this.signatures.length === signedKeys.length) {\n      const valid = this.signatures.every((pair, index) => {\n        return signedKeys[index].equals(pair.publicKey);\n      });\n\n      if (valid) return message;\n    }\n\n    this.signatures = signedKeys.map(publicKey => ({\n      signature: null,\n      publicKey,\n    }));\n\n    return message;\n  }\n\n  /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */\n  serializeMessage(): Buffer {\n    return this._compile().serialize();\n  }\n\n  /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */\n  async getEstimatedFee(connection: Connection): Promise<number | null> {\n    return (await connection.getFeeForMessage(this.compileMessage())).value;\n  }\n\n  /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */\n  setSigners(...signers: Array<PublicKey>) {\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n\n    const seen = new Set();\n    this.signatures = signers\n      .filter(publicKey => {\n        const key = publicKey.toString();\n        if (seen.has(key)) {\n          return false;\n        } else {\n          seen.add(key);\n          return true;\n        }\n      })\n      .map(publicKey => ({signature: null, publicKey}));\n  }\n\n  /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */\n  sign(...signers: Array<Signer>) {\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n\n    // Dedupe signers\n    const seen = new Set();\n    const uniqueSigners = [];\n    for (const signer of signers) {\n      const key = signer.publicKey.toString();\n      if (seen.has(key)) {\n        continue;\n      } else {\n        seen.add(key);\n        uniqueSigners.push(signer);\n      }\n    }\n\n    this.signatures = uniqueSigners.map(signer => ({\n      signature: null,\n      publicKey: signer.publicKey,\n    }));\n\n    const message = this._compile();\n    this._partialSign(message, ...uniqueSigners);\n  }\n\n  /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */\n  partialSign(...signers: Array<Signer>) {\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n\n    // Dedupe signers\n    const seen = new Set();\n    const uniqueSigners = [];\n    for (const signer of signers) {\n      const key = signer.publicKey.toString();\n      if (seen.has(key)) {\n        continue;\n      } else {\n        seen.add(key);\n        uniqueSigners.push(signer);\n      }\n    }\n\n    const message = this._compile();\n    this._partialSign(message, ...uniqueSigners);\n  }\n\n  /**\n   * @internal\n   */\n  _partialSign(message: Message, ...signers: Array<Signer>) {\n    const signData = message.serialize();\n    signers.forEach(signer => {\n      const signature = sign(signData, signer.secretKey);\n      this._addSignature(signer.publicKey, toBuffer(signature));\n    });\n  }\n\n  /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */\n  addSignature(pubkey: PublicKey, signature: Buffer) {\n    this._compile(); // Ensure signatures array is populated\n    this._addSignature(pubkey, signature);\n  }\n\n  /**\n   * @internal\n   */\n  _addSignature(pubkey: PublicKey, signature: Buffer) {\n    invariant(signature.length === 64);\n\n    const index = this.signatures.findIndex(sigpair =>\n      pubkey.equals(sigpair.publicKey),\n    );\n    if (index < 0) {\n      throw new Error(`unknown signer: ${pubkey.toString()}`);\n    }\n\n    this.signatures[index].signature = Buffer.from(signature);\n  }\n\n  /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */\n  verifySignatures(requireAllSignatures: boolean = true): boolean {\n    const signatureErrors = this._getMessageSignednessErrors(\n      this.serializeMessage(),\n      requireAllSignatures,\n    );\n    return !signatureErrors;\n  }\n\n  /**\n   * @internal\n   */\n  _getMessageSignednessErrors(\n    message: Uint8Array,\n    requireAllSignatures: boolean,\n  ): MessageSignednessErrors | undefined {\n    const errors: MessageSignednessErrors = {};\n    for (const {signature, publicKey} of this.signatures) {\n      if (signature === null) {\n        if (requireAllSignatures) {\n          (errors.missing ||= []).push(publicKey);\n        }\n      } else {\n        if (!verify(signature, message, publicKey.toBytes())) {\n          (errors.invalid ||= []).push(publicKey);\n        }\n      }\n    }\n    return errors.invalid || errors.missing ? errors : undefined;\n  }\n\n  /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */\n  serialize(config?: SerializeConfig): Buffer {\n    const {requireAllSignatures, verifySignatures} = Object.assign(\n      {requireAllSignatures: true, verifySignatures: true},\n      config,\n    );\n\n    const signData = this.serializeMessage();\n    if (verifySignatures) {\n      const sigErrors = this._getMessageSignednessErrors(\n        signData,\n        requireAllSignatures,\n      );\n      if (sigErrors) {\n        let errorMessage = 'Signature verification failed.';\n        if (sigErrors.invalid) {\n          errorMessage += `\\nInvalid signature for public key${\n            sigErrors.invalid.length === 1 ? '' : '(s)'\n          } [\\`${sigErrors.invalid.map(p => p.toBase58()).join('`, `')}\\`].`;\n        }\n        if (sigErrors.missing) {\n          errorMessage += `\\nMissing signature for public key${\n            sigErrors.missing.length === 1 ? '' : '(s)'\n          } [\\`${sigErrors.missing.map(p => p.toBase58()).join('`, `')}\\`].`;\n        }\n        throw new Error(errorMessage);\n      }\n    }\n\n    return this._serialize(signData);\n  }\n\n  /**\n   * @internal\n   */\n  _serialize(signData: Buffer): Buffer {\n    const {signatures} = this;\n    const signatureCount: number[] = [];\n    shortvec.encodeLength(signatureCount, signatures.length);\n    const transactionLength =\n      signatureCount.length + signatures.length * 64 + signData.length;\n    const wireTransaction = Buffer.alloc(transactionLength);\n    invariant(signatures.length < 256);\n    Buffer.from(signatureCount).copy(wireTransaction, 0);\n    signatures.forEach(({signature}, index) => {\n      if (signature !== null) {\n        invariant(signature.length === 64, `signature has invalid length`);\n        Buffer.from(signature).copy(\n          wireTransaction,\n          signatureCount.length + index * 64,\n        );\n      }\n    });\n    signData.copy(\n      wireTransaction,\n      signatureCount.length + signatures.length * 64,\n    );\n    invariant(\n      wireTransaction.length <= PACKET_DATA_SIZE,\n      `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`,\n    );\n    return wireTransaction;\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get keys(): Array<PublicKey> {\n    invariant(this.instructions.length === 1);\n    return this.instructions[0].keys.map(keyObj => keyObj.pubkey);\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get programId(): PublicKey {\n    invariant(this.instructions.length === 1);\n    return this.instructions[0].programId;\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get data(): Buffer {\n    invariant(this.instructions.length === 1);\n    return this.instructions[0].data;\n  }\n\n  /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */\n  static from(buffer: Buffer | Uint8Array | Array<number>): Transaction {\n    // Slice up wire data\n    let byteArray = [...buffer];\n\n    const signatureCount = shortvec.decodeLength(byteArray);\n    let signatures = [];\n    for (let i = 0; i < signatureCount; i++) {\n      const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n      signatures.push(bs58.encode(Buffer.from(signature)));\n    }\n\n    return Transaction.populate(Message.from(byteArray), signatures);\n  }\n\n  /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */\n  static populate(\n    message: Message,\n    signatures: Array<string> = [],\n  ): Transaction {\n    const transaction = new Transaction();\n    transaction.recentBlockhash = message.recentBlockhash;\n    if (message.header.numRequiredSignatures > 0) {\n      transaction.feePayer = message.accountKeys[0];\n    }\n    signatures.forEach((signature, index) => {\n      const sigPubkeyPair = {\n        signature:\n          signature == bs58.encode(DEFAULT_SIGNATURE)\n            ? null\n            : bs58.decode(signature),\n        publicKey: message.accountKeys[index],\n      };\n      transaction.signatures.push(sigPubkeyPair);\n    });\n\n    message.instructions.forEach(instruction => {\n      const keys = instruction.accounts.map(account => {\n        const pubkey = message.accountKeys[account];\n        return {\n          pubkey,\n          isSigner:\n            transaction.signatures.some(\n              keyObj => keyObj.publicKey.toString() === pubkey.toString(),\n            ) || message.isAccountSigner(account),\n          isWritable: message.isAccountWritable(account),\n        };\n      });\n\n      transaction.instructions.push(\n        new TransactionInstruction({\n          keys,\n          programId: message.accountKeys[instruction.programIdIndex],\n          data: bs58.decode(instruction.data),\n        }),\n      );\n    });\n\n    transaction._message = message;\n    transaction._json = transaction.toJSON();\n\n    return transaction;\n  }\n}\n", "import {AccountKeysFromLookups} from '../message/account-keys';\nimport assert from '../utils/assert';\nimport {toBuffer} from '../utils/to-buffer';\nimport {Blockhash} from '../blockhash';\nimport {Message, MessageV0, VersionedMessage} from '../message';\nimport {PublicKey} from '../publickey';\nimport {AddressLookupTableAccount} from '../programs';\nimport {AccountMeta, TransactionInstruction} from './legacy';\n\nexport type TransactionMessageArgs = {\n  payerKey: PublicKey;\n  instructions: Array<TransactionInstruction>;\n  recentBlockhash: Blockhash;\n};\n\nexport type DecompileArgs =\n  | {\n      accountKeysFromLookups: AccountKeysFromLookups;\n    }\n  | {\n      addressLookupTableAccounts: AddressLookupTableAccount[];\n    };\n\nexport class TransactionMessage {\n  payerKey: PublicKey;\n  instructions: Array<TransactionInstruction>;\n  recentBlockhash: Blockhash;\n\n  constructor(args: TransactionMessageArgs) {\n    this.payerKey = args.payerKey;\n    this.instructions = args.instructions;\n    this.recentBlockhash = args.recentBlockhash;\n  }\n\n  static decompile(\n    message: VersionedMessage,\n    args?: DecompileArgs,\n  ): TransactionMessage {\n    const {header, compiledInstructions, recentBlockhash} = message;\n\n    const {\n      numRequiredSignatures,\n      numReadonlySignedAccounts,\n      numReadonlyUnsignedAccounts,\n    } = header;\n\n    const numWritableSignedAccounts =\n      numRequiredSignatures - numReadonlySignedAccounts;\n    assert(numWritableSignedAccounts > 0, 'Message header is invalid');\n\n    const numWritableUnsignedAccounts =\n      message.staticAccountKeys.length -\n      numRequiredSignatures -\n      numReadonlyUnsignedAccounts;\n    assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');\n\n    const accountKeys = message.getAccountKeys(args);\n    const payerKey = accountKeys.get(0);\n    if (payerKey === undefined) {\n      throw new Error(\n        'Failed to decompile message because no account keys were found',\n      );\n    }\n\n    const instructions: TransactionInstruction[] = [];\n    for (const compiledIx of compiledInstructions) {\n      const keys: AccountMeta[] = [];\n\n      for (const keyIndex of compiledIx.accountKeyIndexes) {\n        const pubkey = accountKeys.get(keyIndex);\n        if (pubkey === undefined) {\n          throw new Error(\n            `Failed to find key for account key index ${keyIndex}`,\n          );\n        }\n\n        const isSigner = keyIndex < numRequiredSignatures;\n\n        let isWritable;\n        if (isSigner) {\n          isWritable = keyIndex < numWritableSignedAccounts;\n        } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n          isWritable =\n            keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n        } else {\n          isWritable =\n            keyIndex - accountKeys.staticAccountKeys.length <\n            // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n            accountKeys.accountKeysFromLookups!.writable.length;\n        }\n\n        keys.push({\n          pubkey,\n          isSigner: keyIndex < header.numRequiredSignatures,\n          isWritable,\n        });\n      }\n\n      const programId = accountKeys.get(compiledIx.programIdIndex);\n      if (programId === undefined) {\n        throw new Error(\n          `Failed to find program id for program id index ${compiledIx.programIdIndex}`,\n        );\n      }\n\n      instructions.push(\n        new TransactionInstruction({\n          programId,\n          data: toBuffer(compiledIx.data),\n          keys,\n        }),\n      );\n    }\n\n    return new TransactionMessage({\n      payerKey,\n      instructions,\n      recentBlockhash,\n    });\n  }\n\n  compileToLegacyMessage(): Message {\n    return Message.compile({\n      payerKey: this.payerKey,\n      recentBlockhash: this.recentBlockhash,\n      instructions: this.instructions,\n    });\n  }\n\n  compileToV0Message(\n    addressLookupTableAccounts?: AddressLookupTableAccount[],\n  ): MessageV0 {\n    return MessageV0.compile({\n      payerKey: this.payerKey,\n      recentBlockhash: this.recentBlockhash,\n      instructions: this.instructions,\n      addressLookupTableAccounts,\n    });\n  }\n}\n", "import * as BufferLayout from '@solana/buffer-layout';\n\nimport {Signer} from '../keypair';\nimport assert from '../utils/assert';\nimport {VersionedMessage} from '../message/versioned';\nimport {SIGNATURE_LENGTH_IN_BYTES} from './constants';\nimport * as shortvec from '../utils/shortvec-encoding';\nimport * as Layout from '../layout';\nimport {sign} from '../utils/ed25519';\nimport {PublicKey} from '../publickey';\nimport {guardedSplice} from '../utils/guarded-array-utils';\n\nexport type TransactionVersion = 'legacy' | 0;\n\n/**\n * Versioned transaction class\n */\nexport class VersionedTransaction {\n  signatures: Array<Uint8Array>;\n  message: VersionedMessage;\n\n  get version(): TransactionVersion {\n    return this.message.version;\n  }\n\n  constructor(message: VersionedMessage, signatures?: Array<Uint8Array>) {\n    if (signatures !== undefined) {\n      assert(\n        signatures.length === message.header.numRequiredSignatures,\n        'Expected signatures length to be equal to the number of required signatures',\n      );\n      this.signatures = signatures;\n    } else {\n      const defaultSignatures = [];\n      for (let i = 0; i < message.header.numRequiredSignatures; i++) {\n        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n      }\n      this.signatures = defaultSignatures;\n    }\n    this.message = message;\n  }\n\n  serialize(): Uint8Array {\n    const serializedMessage = this.message.serialize();\n\n    const encodedSignaturesLength = Array<number>();\n    shortvec.encodeLength(encodedSignaturesLength, this.signatures.length);\n\n    const transactionLayout = BufferLayout.struct<{\n      encodedSignaturesLength: Uint8Array;\n      signatures: Array<Uint8Array>;\n      serializedMessage: Uint8Array;\n    }>([\n      BufferLayout.blob(\n        encodedSignaturesLength.length,\n        'encodedSignaturesLength',\n      ),\n      BufferLayout.seq(\n        Layout.signature(),\n        this.signatures.length,\n        'signatures',\n      ),\n      BufferLayout.blob(serializedMessage.length, 'serializedMessage'),\n    ]);\n\n    const serializedTransaction = new Uint8Array(2048);\n    const serializedTransactionLength = transactionLayout.encode(\n      {\n        encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n        signatures: this.signatures,\n        serializedMessage,\n      },\n      serializedTransaction,\n    );\n\n    return serializedTransaction.slice(0, serializedTransactionLength);\n  }\n\n  static deserialize(serializedTransaction: Uint8Array): VersionedTransaction {\n    let byteArray = [...serializedTransaction];\n\n    const signatures = [];\n    const signaturesLength = shortvec.decodeLength(byteArray);\n    for (let i = 0; i < signaturesLength; i++) {\n      signatures.push(\n        new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)),\n      );\n    }\n\n    const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n    return new VersionedTransaction(message, signatures);\n  }\n\n  sign(signers: Array<Signer>) {\n    const messageData = this.message.serialize();\n    const signerPubkeys = this.message.staticAccountKeys.slice(\n      0,\n      this.message.header.numRequiredSignatures,\n    );\n    for (const signer of signers) {\n      const signerIndex = signerPubkeys.findIndex(pubkey =>\n        pubkey.equals(signer.publicKey),\n      );\n      assert(\n        signerIndex >= 0,\n        `Cannot sign with non signer key ${signer.publicKey.toBase58()}`,\n      );\n      this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n    }\n  }\n\n  addSignature(publicKey: PublicKey, signature: Uint8Array) {\n    assert(signature.byteLength === 64, 'Signature must be 64 bytes long');\n    const signerPubkeys = this.message.staticAccountKeys.slice(\n      0,\n      this.message.header.numRequiredSignatures,\n    );\n    const signerIndex = signerPubkeys.findIndex(pubkey =>\n      pubkey.equals(publicKey),\n    );\n    assert(\n      signerIndex >= 0,\n      `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`,\n    );\n    this.signatures[signerIndex] = signature;\n  }\n}\n", "// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n\n/**\n * @internal\n */\nexport const NUM_TICKS_PER_SECOND = 160;\n\n/**\n * @internal\n */\nexport const DEFAULT_TICKS_PER_SLOT = 64;\n\n/**\n * @internal\n */\nexport const NUM_SLOTS_PER_SECOND =\n  NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n\n/**\n * @internal\n */\nexport const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\n", "import {PublicKey} from './publickey';\n\nexport const SYSVAR_CLOCK_PUBKEY = new PublicKey(\n  'SysvarC1ock11111111111111111111111111111111',\n);\n\nexport const SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\n  'SysvarEpochSchedu1e111111111111111111111111',\n);\n\nexport const SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\n  'Sysvar1nstructions1111111111111111111111111',\n);\n\nexport const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\n  'SysvarRecentB1ockHashes11111111111111111111',\n);\n\nexport const SYSVAR_RENT_PUBKEY = new PublicKey(\n  'SysvarRent111111111111111111111111111111111',\n);\n\nexport const SYSVAR_REWARDS_PUBKEY = new PublicKey(\n  'SysvarRewards111111111111111111111111111111',\n);\n\nexport const SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\n  'SysvarS1otHashes111111111111111111111111111',\n);\n\nexport const SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\n  'SysvarS1otHistory11111111111111111111111111',\n);\n\nexport const SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\n  'SysvarStakeHistory1111111111111111111111111',\n);\n", "import {Connection} from './connection';\nimport {TransactionSignature} from './transaction';\n\nexport class SendTransactionError extends Error {\n  private signature: TransactionSignature;\n  private transactionMessage: string;\n  private transactionLogs: string[] | Promise<string[]> | undefined;\n\n  constructor({\n    action,\n    signature,\n    transactionMessage,\n    logs,\n  }: {\n    action: 'send' | 'simulate';\n    signature: TransactionSignature;\n    transactionMessage: string;\n    logs?: string[];\n  }) {\n    const maybeLogsOutput = logs\n      ? `Logs: \\n${JSON.stringify(logs.slice(-10), null, 2)}. `\n      : '';\n    const guideText =\n      '\\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.';\n    let message: string;\n    switch (action) {\n      case 'send':\n        message =\n          `Transaction ${signature} resulted in an error. \\n` +\n          `${transactionMessage}. ` +\n          maybeLogsOutput +\n          guideText;\n        break;\n      case 'simulate':\n        message =\n          `Simulation failed. \\nMessage: ${transactionMessage}. \\n` +\n          maybeLogsOutput +\n          guideText;\n        break;\n      default: {\n        message = `Unknown action '${((a: never) => a)(action)}'`;\n      }\n    }\n    super(message);\n\n    this.signature = signature;\n    this.transactionMessage = transactionMessage;\n    this.transactionLogs = logs ? logs : undefined;\n  }\n\n  get transactionError(): {message: string; logs?: string[]} {\n    return {\n      message: this.transactionMessage,\n      logs: Array.isArray(this.transactionLogs)\n        ? this.transactionLogs\n        : undefined,\n    };\n  }\n\n  /* @deprecated Use `await getLogs()` instead */\n  get logs(): string[] | undefined {\n    const cachedLogs = this.transactionLogs;\n    if (\n      cachedLogs != null &&\n      typeof cachedLogs === 'object' &&\n      'then' in cachedLogs\n    ) {\n      return undefined;\n    }\n    return cachedLogs;\n  }\n\n  async getLogs(connection: Connection): Promise<string[]> {\n    if (!Array.isArray(this.transactionLogs)) {\n      this.transactionLogs = new Promise((resolve, reject) => {\n        connection\n          .getTransaction(this.signature)\n          .then(tx => {\n            if (tx && tx.meta && tx.meta.logMessages) {\n              const logs = tx.meta.logMessages;\n              this.transactionLogs = logs;\n              resolve(logs);\n            } else {\n              reject(new Error('Log messages not found'));\n            }\n          })\n          .catch(reject);\n      });\n    }\n    return await this.transactionLogs;\n  }\n}\n\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nexport const SolanaJSONRPCErrorCode = {\n  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n  JSON_RPC_SCAN_ERROR: -32012,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016,\n} as const;\nexport type SolanaJSONRPCErrorCodeEnum =\n  (typeof SolanaJSONRPCErrorCode)[keyof typeof SolanaJSONRPCErrorCode];\n\nexport class SolanaJSONRPCError extends Error {\n  code: SolanaJSONRPCErrorCodeEnum | unknown;\n  data?: any;\n  constructor(\n    {\n      code,\n      message,\n      data,\n    }: Readonly<{code: unknown; message: string; data?: any}>,\n    customMessage?: string,\n  ) {\n    super(customMessage != null ? `${customMessage}: ${message}` : message);\n    this.code = code;\n    this.data = data;\n    this.name = 'SolanaJSONRPCError';\n  }\n}\n", "import {Connection, SignatureResult} from '../connection';\nimport {Transaction} from '../transaction';\nimport type {ConfirmOptions} from '../connection';\nimport type {Signer} from '../keypair';\nimport type {TransactionSignature} from '../transaction';\nimport {SendTransactionError} from '../errors';\n\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\nexport async function sendAndConfirmTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  signers: Array<Signer>,\n  options?: ConfirmOptions &\n    Readonly<{\n      // A signal that, when aborted, cancels any outstanding transaction confirmation operations\n      abortSignal?: AbortSignal;\n    }>,\n): Promise<TransactionSignature> {\n  const sendOptions = options && {\n    skipPreflight: options.skipPreflight,\n    preflightCommitment: options.preflightCommitment || options.commitment,\n    maxRetries: options.maxRetries,\n    minContextSlot: options.minContextSlot,\n  };\n\n  const signature = await connection.sendTransaction(\n    transaction,\n    signers,\n    sendOptions,\n  );\n\n  let status: SignatureResult;\n  if (\n    transaction.recentBlockhash != null &&\n    transaction.lastValidBlockHeight != null\n  ) {\n    status = (\n      await connection.confirmTransaction(\n        {\n          abortSignal: options?.abortSignal,\n          signature: signature,\n          blockhash: transaction.recentBlockhash,\n          lastValidBlockHeight: transaction.lastValidBlockHeight,\n        },\n        options && options.commitment,\n      )\n    ).value;\n  } else if (\n    transaction.minNonceContextSlot != null &&\n    transaction.nonceInfo != null\n  ) {\n    const {nonceInstruction} = transaction.nonceInfo;\n    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n    status = (\n      await connection.confirmTransaction(\n        {\n          abortSignal: options?.abortSignal,\n          minContextSlot: transaction.minNonceContextSlot,\n          nonceAccountPubkey,\n          nonceValue: transaction.nonceInfo.nonce,\n          signature,\n        },\n        options && options.commitment,\n      )\n    ).value;\n  } else {\n    if (options?.abortSignal != null) {\n      console.warn(\n        'sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' +\n          'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' +\n          'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.',\n      );\n    }\n    status = (\n      await connection.confirmTransaction(\n        signature,\n        options && options.commitment,\n      )\n    ).value;\n  }\n\n  if (status.err) {\n    if (signature != null) {\n      throw new SendTransactionError({\n        action: 'send',\n        signature: signature,\n        transactionMessage: `Status: (${JSON.stringify(status)})`,\n      });\n    }\n    throw new Error(\n      `Transaction ${signature} failed (${JSON.stringify(status)})`,\n    );\n  }\n\n  return signature;\n}\n", "// zzz\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n", "import {Buffer} from 'buffer';\nimport * as BufferLayout from '@solana/buffer-layout';\n\nimport * as Layout from './layout';\n\nexport interface IInstructionInputData {\n  readonly instruction: number;\n}\n\n/**\n * @internal\n */\nexport type InstructionType<TInputData extends IInstructionInputData> = {\n  /** The Instruction index (from solana upstream program) */\n  index: number;\n  /** The BufferLayout to use to build data */\n  layout: BufferLayout.Layout<TInputData>;\n};\n\n/**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */\nexport function encodeData<TInputData extends IInstructionInputData>(\n  type: InstructionType<TInputData>,\n  fields?: any,\n): Buffer {\n  const allocLength =\n    type.layout.span >= 0 ? type.layout.span : Layout.getAlloc(type, fields);\n  const data = Buffer.alloc(allocLength);\n  const layoutFields = Object.assign({instruction: type.index}, fields);\n  type.layout.encode(layoutFields, data);\n  return data;\n}\n\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */\nexport function decodeData<TInputData extends IInstructionInputData>(\n  type: InstructionType<TInputData>,\n  buffer: Buffer,\n): TInputData {\n  let data: TInputData;\n  try {\n    data = type.layout.decode(buffer);\n  } catch (err) {\n    throw new Error('invalid instruction; ' + err);\n  }\n\n  if (data.instruction !== type.index) {\n    throw new Error(\n      `invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`,\n    );\n  }\n\n  return data;\n}\n", "import * as BufferLayout from '@solana/buffer-layout';\n\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */\nexport const FeeCalculatorLayout = BufferLayout.nu64('lamportsPerSignature');\n\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */\nexport interface FeeCalculator {\n  /** Cost in lamports to validate a signature. */\n  lamportsPerSignature: number;\n}\n", "import * as BufferLayout from '@solana/buffer-layout';\nimport {Buffer} from 'buffer';\n\nimport * as Layout from './layout';\nimport {PublicKey} from './publickey';\nimport type {FeeCalculator} from './fee-calculator';\nimport {FeeCalculatorLayout} from './fee-calculator';\nimport {toBuffer} from './utils/to-buffer';\n\n/**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */\nconst NonceAccountLayout = BufferLayout.struct<\n  Readonly<{\n    authorizedPubkey: Uint8Array;\n    feeCalculator: Readonly<{\n      lamportsPerSignature: number;\n    }>;\n    nonce: Uint8Array;\n    state: number;\n    version: number;\n  }>\n>([\n  BufferLayout.u32('version'),\n  BufferLayout.u32('state'),\n  Layout.publicKey('authorizedPubkey'),\n  Layout.publicKey('nonce'),\n  BufferLayout.struct<Readonly<{lamportsPerSignature: number}>>(\n    [FeeCalculatorLayout],\n    'feeCalculator',\n  ),\n]);\n\nexport const NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */\nexport type DurableNonce = string;\n\ntype NonceAccountArgs = {\n  authorizedPubkey: PublicKey;\n  nonce: DurableNonce;\n  feeCalculator: FeeCalculator;\n};\n\n/**\n * NonceAccount class\n */\nexport class NonceAccount {\n  authorizedPubkey: PublicKey;\n  nonce: DurableNonce;\n  feeCalculator: FeeCalculator;\n\n  /**\n   * @internal\n   */\n  constructor(args: NonceAccountArgs) {\n    this.authorizedPubkey = args.authorizedPubkey;\n    this.nonce = args.nonce;\n    this.feeCalculator = args.feeCalculator;\n  }\n\n  /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */\n  static fromAccountData(\n    buffer: Buffer | Uint8Array | Array<number>,\n  ): NonceAccount {\n    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n    return new NonceAccount({\n      authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n      nonce: new PublicKey(nonceAccount.nonce).toString(),\n      feeCalculator: nonceAccount.feeCalculator,\n    });\n  }\n}\n", "import {Buffer} from 'buffer';\nimport {blob, Layout} from '@solana/buffer-layout';\nimport {getU64Codec} from '@solana/codecs-numbers';\n\nexport function u64(property?: string): Layout<bigint> {\n  const layout = blob(8 /* bytes */, property);\n  const decode = layout.decode.bind(layout);\n  const encode = layout.encode.bind(layout);\n\n  const bigIntLayout = layout as Layout<unknown> as Layout<bigint>;\n  const codec = getU64Codec();\n\n  bigIntLayout.decode = (buffer: Buffer, offset: number) => {\n    const src = decode(buffer as Uint8Array, offset);\n    return codec.decode(src);\n  };\n\n  bigIntLayout.encode = (bigInt: bigint, buffer: Buffer, offset: number) => {\n    const src = codec.encode(bigInt) as Uint8Array;\n    return encode(src, buffer as Uint8Array, offset);\n  };\n\n  return bigIntLayout;\n}\n", "import * as BufferLayout from '@solana/buffer-layout';\n\nimport {\n  encodeData,\n  decodeData,\n  InstructionType,\n  IInstructionInputData,\n} from '../instruction';\nimport * as Layout from '../layout';\nimport {NONCE_ACCOUNT_LENGTH} from '../nonce-account';\nimport {PublicKey} from '../publickey';\nimport {SYSVAR_RECENT_BLOCKHASHES_PUBKEY, SYSVAR_RENT_PUBKEY} from '../sysvar';\nimport {Transaction, TransactionInstruction} from '../transaction';\nimport {toBuffer} from '../utils/to-buffer';\nimport {u64} from '../utils/bigint';\n\n/**\n * Create account system transaction params\n */\nexport type CreateAccountParams = {\n  /** The account that will transfer lamports to the created account */\n  fromPubkey: PublicKey;\n  /** Public key of the created account */\n  newAccountPubkey: PublicKey;\n  /** Amount of lamports to transfer to the created account */\n  lamports: number;\n  /** Amount of space in bytes to allocate to the created account */\n  space: number;\n  /** Public key of the program to assign as the owner of the created account */\n  programId: PublicKey;\n};\n\n/**\n * Transfer system transaction params\n */\nexport type TransferParams = {\n  /** Account that will transfer lamports */\n  fromPubkey: PublicKey;\n  /** Account that will receive transferred lamports */\n  toPubkey: PublicKey;\n  /** Amount of lamports to transfer */\n  lamports: number | bigint;\n};\n\n/**\n * Assign system transaction params\n */\nexport type AssignParams = {\n  /** Public key of the account which will be assigned a new owner */\n  accountPubkey: PublicKey;\n  /** Public key of the program to assign as the owner */\n  programId: PublicKey;\n};\n\n/**\n * Create account with seed system transaction params\n */\nexport type CreateAccountWithSeedParams = {\n  /** The account that will transfer lamports to the created account */\n  fromPubkey: PublicKey;\n  /** Public key of the created account. Must be pre-calculated with PublicKey.createWithSeed() */\n  newAccountPubkey: PublicKey;\n  /** Base public key to use to derive the address of the created account. Must be the same as the base key used to create `newAccountPubkey` */\n  basePubkey: PublicKey;\n  /** Seed to use to derive the address of the created account. Must be the same as the seed used to create `newAccountPubkey` */\n  seed: string;\n  /** Amount of lamports to transfer to the created account */\n  lamports: number;\n  /** Amount of space in bytes to allocate to the created account */\n  space: number;\n  /** Public key of the program to assign as the owner of the created account */\n  programId: PublicKey;\n};\n\n/**\n * Create nonce account system transaction params\n */\nexport type CreateNonceAccountParams = {\n  /** The account that will transfer lamports to the created nonce account */\n  fromPubkey: PublicKey;\n  /** Public key of the created nonce account */\n  noncePubkey: PublicKey;\n  /** Public key to set as authority of the created nonce account */\n  authorizedPubkey: PublicKey;\n  /** Amount of lamports to transfer to the created nonce account */\n  lamports: number;\n};\n\n/**\n * Create nonce account with seed system transaction params\n */\nexport type CreateNonceAccountWithSeedParams = {\n  /** The account that will transfer lamports to the created nonce account */\n  fromPubkey: PublicKey;\n  /** Public key of the created nonce account */\n  noncePubkey: PublicKey;\n  /** Public key to set as authority of the created nonce account */\n  authorizedPubkey: PublicKey;\n  /** Amount of lamports to transfer to the created nonce account */\n  lamports: number;\n  /** Base public key to use to derive the address of the nonce account */\n  basePubkey: PublicKey;\n  /** Seed to use to derive the address of the nonce account */\n  seed: string;\n};\n\n/**\n * Initialize nonce account system instruction params\n */\nexport type InitializeNonceParams = {\n  /** Nonce account which will be initialized */\n  noncePubkey: PublicKey;\n  /** Public key to set as authority of the initialized nonce account */\n  authorizedPubkey: PublicKey;\n};\n\n/**\n * Advance nonce account system instruction params\n */\nexport type AdvanceNonceParams = {\n  /** Nonce account */\n  noncePubkey: PublicKey;\n  /** Public key of the nonce authority */\n  authorizedPubkey: PublicKey;\n};\n\n/**\n * Withdraw nonce account system transaction params\n */\nexport type WithdrawNonceParams = {\n  /** Nonce account */\n  noncePubkey: PublicKey;\n  /** Public key of the nonce authority */\n  authorizedPubkey: PublicKey;\n  /** Public key of the account which will receive the withdrawn nonce account balance */\n  toPubkey: PublicKey;\n  /** Amount of lamports to withdraw from the nonce account */\n  lamports: number;\n};\n\n/**\n * Authorize nonce account system transaction params\n */\nexport type AuthorizeNonceParams = {\n  /** Nonce account */\n  noncePubkey: PublicKey;\n  /** Public key of the current nonce authority */\n  authorizedPubkey: PublicKey;\n  /** Public key to set as the new nonce authority */\n  newAuthorizedPubkey: PublicKey;\n};\n\n/**\n * Allocate account system transaction params\n */\nexport type AllocateParams = {\n  /** Account to allocate */\n  accountPubkey: PublicKey;\n  /** Amount of space in bytes to allocate */\n  space: number;\n};\n\n/**\n * Allocate account with seed system transaction params\n */\nexport type AllocateWithSeedParams = {\n  /** Account to allocate */\n  accountPubkey: PublicKey;\n  /** Base public key to use to derive the address of the allocated account */\n  basePubkey: PublicKey;\n  /** Seed to use to derive the address of the allocated account */\n  seed: string;\n  /** Amount of space in bytes to allocate */\n  space: number;\n  /** Public key of the program to assign as the owner of the allocated account */\n  programId: PublicKey;\n};\n\n/**\n * Assign account with seed system transaction params\n */\nexport type AssignWithSeedParams = {\n  /** Public key of the account which will be assigned a new owner */\n  accountPubkey: PublicKey;\n  /** Base public key to use to derive the address of the assigned account */\n  basePubkey: PublicKey;\n  /** Seed to use to derive the address of the assigned account */\n  seed: string;\n  /** Public key of the program to assign as the owner */\n  programId: PublicKey;\n};\n\n/**\n * Transfer with seed system transaction params\n */\nexport type TransferWithSeedParams = {\n  /** Account that will transfer lamports */\n  fromPubkey: PublicKey;\n  /** Base public key to use to derive the funding account address */\n  basePubkey: PublicKey;\n  /** Account that will receive transferred lamports */\n  toPubkey: PublicKey;\n  /** Amount of lamports to transfer */\n  lamports: number | bigint;\n  /** Seed to use to derive the funding account address */\n  seed: string;\n  /** Program id to use to derive the funding account address */\n  programId: PublicKey;\n};\n\n/** Decoded transfer system transaction instruction */\nexport type DecodedTransferInstruction = {\n  /** Account that will transfer lamports */\n  fromPubkey: PublicKey;\n  /** Account that will receive transferred lamports */\n  toPubkey: PublicKey;\n  /** Amount of lamports to transfer */\n  lamports: bigint;\n};\n\n/** Decoded transferWithSeed system transaction instruction */\nexport type DecodedTransferWithSeedInstruction = {\n  /** Account that will transfer lamports */\n  fromPubkey: PublicKey;\n  /** Base public key to use to derive the funding account address */\n  basePubkey: PublicKey;\n  /** Account that will receive transferred lamports */\n  toPubkey: PublicKey;\n  /** Amount of lamports to transfer */\n  lamports: bigint;\n  /** Seed to use to derive the funding account address */\n  seed: string;\n  /** Program id to use to derive the funding account address */\n  programId: PublicKey;\n};\n\n/**\n * System Instruction class\n */\nexport class SystemInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a system instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(\n    instruction: TransactionInstruction,\n  ): SystemInstructionType {\n    this.checkProgramId(instruction.programId);\n\n    const instructionTypeLayout = BufferLayout.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n\n    let type: SystemInstructionType | undefined;\n    for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType as SystemInstructionType;\n        break;\n      }\n    }\n\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a SystemInstruction');\n    }\n\n    return type;\n  }\n\n  /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */\n  static decodeCreateAccount(\n    instruction: TransactionInstruction,\n  ): CreateAccountParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n\n    const {lamports, space, programId} = decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.Create,\n      instruction.data,\n    );\n\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      newAccountPubkey: instruction.keys[1].pubkey,\n      lamports,\n      space,\n      programId: new PublicKey(programId),\n    };\n  }\n\n  /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */\n  static decodeTransfer(\n    instruction: TransactionInstruction,\n  ): DecodedTransferInstruction {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n\n    const {lamports} = decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.Transfer,\n      instruction.data,\n    );\n\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      toPubkey: instruction.keys[1].pubkey,\n      lamports,\n    };\n  }\n\n  /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */\n  static decodeTransferWithSeed(\n    instruction: TransactionInstruction,\n  ): DecodedTransferWithSeedInstruction {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n\n    const {lamports, seed, programId} = decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed,\n      instruction.data,\n    );\n\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      basePubkey: instruction.keys[1].pubkey,\n      toPubkey: instruction.keys[2].pubkey,\n      lamports,\n      seed,\n      programId: new PublicKey(programId),\n    };\n  }\n\n  /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */\n  static decodeAllocate(instruction: TransactionInstruction): AllocateParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n\n    const {space} = decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.Allocate,\n      instruction.data,\n    );\n\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      space,\n    };\n  }\n\n  /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */\n  static decodeAllocateWithSeed(\n    instruction: TransactionInstruction,\n  ): AllocateWithSeedParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n\n    const {base, seed, space, programId} = decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed,\n      instruction.data,\n    );\n\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      space,\n      programId: new PublicKey(programId),\n    };\n  }\n\n  /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */\n  static decodeAssign(instruction: TransactionInstruction): AssignParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n\n    const {programId} = decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.Assign,\n      instruction.data,\n    );\n\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      programId: new PublicKey(programId),\n    };\n  }\n\n  /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */\n  static decodeAssignWithSeed(\n    instruction: TransactionInstruction,\n  ): AssignWithSeedParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n\n    const {base, seed, programId} = decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed,\n      instruction.data,\n    );\n\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      programId: new PublicKey(programId),\n    };\n  }\n\n  /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */\n  static decodeCreateWithSeed(\n    instruction: TransactionInstruction,\n  ): CreateAccountWithSeedParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n\n    const {base, seed, lamports, space, programId} = decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed,\n      instruction.data,\n    );\n\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      newAccountPubkey: instruction.keys[1].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      lamports,\n      space,\n      programId: new PublicKey(programId),\n    };\n  }\n\n  /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */\n  static decodeNonceInitialize(\n    instruction: TransactionInstruction,\n  ): InitializeNonceParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n\n    const {authorized} = decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount,\n      instruction.data,\n    );\n\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: new PublicKey(authorized),\n    };\n  }\n\n  /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */\n  static decodeNonceAdvance(\n    instruction: TransactionInstruction,\n  ): AdvanceNonceParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n\n    decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount,\n      instruction.data,\n    );\n\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey,\n    };\n  }\n\n  /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */\n  static decodeNonceWithdraw(\n    instruction: TransactionInstruction,\n  ): WithdrawNonceParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 5);\n\n    const {lamports} = decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount,\n      instruction.data,\n    );\n\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      toPubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[4].pubkey,\n      lamports,\n    };\n  }\n\n  /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */\n  static decodeNonceAuthorize(\n    instruction: TransactionInstruction,\n  ): AuthorizeNonceParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n\n    const {authorized} = decodeData(\n      SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount,\n      instruction.data,\n    );\n\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[1].pubkey,\n      newAuthorizedPubkey: new PublicKey(authorized),\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId: PublicKey) {\n    if (!programId.equals(SystemProgram.programId)) {\n      throw new Error('invalid instruction; programId is not SystemProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys: Array<any>, expectedLength: number) {\n    if (keys.length < expectedLength) {\n      throw new Error(\n        `invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`,\n      );\n    }\n  }\n}\n\n/**\n * An enumeration of valid SystemInstructionType's\n */\nexport type SystemInstructionType =\n  // FIXME\n  // It would be preferable for this type to be `keyof SystemInstructionInputData`\n  // but Typedoc does not transpile `keyof` expressions.\n  // See https://github.com/TypeStrong/typedoc/issues/1894\n  | 'AdvanceNonceAccount'\n  | 'Allocate'\n  | 'AllocateWithSeed'\n  | 'Assign'\n  | 'AssignWithSeed'\n  | 'AuthorizeNonceAccount'\n  | 'Create'\n  | 'CreateWithSeed'\n  | 'InitializeNonceAccount'\n  | 'Transfer'\n  | 'TransferWithSeed'\n  | 'WithdrawNonceAccount'\n  | 'UpgradeNonceAccount';\n\ntype SystemInstructionInputData = {\n  AdvanceNonceAccount: IInstructionInputData;\n  Allocate: IInstructionInputData & {\n    space: number;\n  };\n  AllocateWithSeed: IInstructionInputData & {\n    base: Uint8Array;\n    programId: Uint8Array;\n    seed: string;\n    space: number;\n  };\n  Assign: IInstructionInputData & {\n    programId: Uint8Array;\n  };\n  AssignWithSeed: IInstructionInputData & {\n    base: Uint8Array;\n    seed: string;\n    programId: Uint8Array;\n  };\n  AuthorizeNonceAccount: IInstructionInputData & {\n    authorized: Uint8Array;\n  };\n  Create: IInstructionInputData & {\n    lamports: number;\n    programId: Uint8Array;\n    space: number;\n  };\n  CreateWithSeed: IInstructionInputData & {\n    base: Uint8Array;\n    lamports: number;\n    programId: Uint8Array;\n    seed: string;\n    space: number;\n  };\n  InitializeNonceAccount: IInstructionInputData & {\n    authorized: Uint8Array;\n  };\n  Transfer: IInstructionInputData & {\n    lamports: bigint;\n  };\n  TransferWithSeed: IInstructionInputData & {\n    lamports: bigint;\n    programId: Uint8Array;\n    seed: string;\n  };\n  WithdrawNonceAccount: IInstructionInputData & {\n    lamports: number;\n  };\n  UpgradeNonceAccount: IInstructionInputData;\n};\n\n/**\n * An enumeration of valid system InstructionType's\n * @internal\n */\nexport const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze<{\n  [Instruction in SystemInstructionType]: InstructionType<\n    SystemInstructionInputData[Instruction]\n  >;\n}>({\n  Create: {\n    index: 0,\n    layout: BufferLayout.struct<SystemInstructionInputData['Create']>([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('lamports'),\n      BufferLayout.ns64('space'),\n      Layout.publicKey('programId'),\n    ]),\n  },\n  Assign: {\n    index: 1,\n    layout: BufferLayout.struct<SystemInstructionInputData['Assign']>([\n      BufferLayout.u32('instruction'),\n      Layout.publicKey('programId'),\n    ]),\n  },\n  Transfer: {\n    index: 2,\n    layout: BufferLayout.struct<SystemInstructionInputData['Transfer']>([\n      BufferLayout.u32('instruction'),\n      u64('lamports'),\n    ]),\n  },\n  CreateWithSeed: {\n    index: 3,\n    layout: BufferLayout.struct<SystemInstructionInputData['CreateWithSeed']>([\n      BufferLayout.u32('instruction'),\n      Layout.publicKey('base'),\n      Layout.rustString('seed'),\n      BufferLayout.ns64('lamports'),\n      BufferLayout.ns64('space'),\n      Layout.publicKey('programId'),\n    ]),\n  },\n  AdvanceNonceAccount: {\n    index: 4,\n    layout: BufferLayout.struct<\n      SystemInstructionInputData['AdvanceNonceAccount']\n    >([BufferLayout.u32('instruction')]),\n  },\n  WithdrawNonceAccount: {\n    index: 5,\n    layout: BufferLayout.struct<\n      SystemInstructionInputData['WithdrawNonceAccount']\n    >([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')]),\n  },\n  InitializeNonceAccount: {\n    index: 6,\n    layout: BufferLayout.struct<\n      SystemInstructionInputData['InitializeNonceAccount']\n    >([BufferLayout.u32('instruction'), Layout.publicKey('authorized')]),\n  },\n  AuthorizeNonceAccount: {\n    index: 7,\n    layout: BufferLayout.struct<\n      SystemInstructionInputData['AuthorizeNonceAccount']\n    >([BufferLayout.u32('instruction'), Layout.publicKey('authorized')]),\n  },\n  Allocate: {\n    index: 8,\n    layout: BufferLayout.struct<SystemInstructionInputData['Allocate']>([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('space'),\n    ]),\n  },\n  AllocateWithSeed: {\n    index: 9,\n    layout: BufferLayout.struct<SystemInstructionInputData['AllocateWithSeed']>(\n      [\n        BufferLayout.u32('instruction'),\n        Layout.publicKey('base'),\n        Layout.rustString('seed'),\n        BufferLayout.ns64('space'),\n        Layout.publicKey('programId'),\n      ],\n    ),\n  },\n  AssignWithSeed: {\n    index: 10,\n    layout: BufferLayout.struct<SystemInstructionInputData['AssignWithSeed']>([\n      BufferLayout.u32('instruction'),\n      Layout.publicKey('base'),\n      Layout.rustString('seed'),\n      Layout.publicKey('programId'),\n    ]),\n  },\n  TransferWithSeed: {\n    index: 11,\n    layout: BufferLayout.struct<SystemInstructionInputData['TransferWithSeed']>(\n      [\n        BufferLayout.u32('instruction'),\n        u64('lamports'),\n        Layout.rustString('seed'),\n        Layout.publicKey('programId'),\n      ],\n    ),\n  },\n  UpgradeNonceAccount: {\n    index: 12,\n    layout: BufferLayout.struct<\n      SystemInstructionInputData['UpgradeNonceAccount']\n    >([BufferLayout.u32('instruction')]),\n  },\n});\n\n/**\n * Factory class for transactions to interact with the System program\n */\nexport class SystemProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the System program\n   */\n  static programId: PublicKey = new PublicKey(\n    '11111111111111111111111111111111',\n  );\n\n  /**\n   * Generate a transaction instruction that creates a new account\n   */\n  static createAccount(params: CreateAccountParams): TransactionInstruction {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n    const data = encodeData(type, {\n      lamports: params.lamports,\n      space: params.space,\n      programId: toBuffer(params.programId.toBuffer()),\n    });\n\n    return new TransactionInstruction({\n      keys: [\n        {pubkey: params.fromPubkey, isSigner: true, isWritable: true},\n        {pubkey: params.newAccountPubkey, isSigner: true, isWritable: true},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */\n  static transfer(\n    params: TransferParams | TransferWithSeedParams,\n  ): TransactionInstruction {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n      data = encodeData(type, {\n        lamports: BigInt(params.lamports),\n        seed: params.seed,\n        programId: toBuffer(params.programId.toBuffer()),\n      });\n      keys = [\n        {pubkey: params.fromPubkey, isSigner: false, isWritable: true},\n        {pubkey: params.basePubkey, isSigner: true, isWritable: false},\n        {pubkey: params.toPubkey, isSigner: false, isWritable: true},\n      ];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n      data = encodeData(type, {lamports: BigInt(params.lamports)});\n      keys = [\n        {pubkey: params.fromPubkey, isSigner: true, isWritable: true},\n        {pubkey: params.toPubkey, isSigner: false, isWritable: true},\n      ];\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that assigns an account to a program\n   */\n  static assign(\n    params: AssignParams | AssignWithSeedParams,\n  ): TransactionInstruction {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n      data = encodeData(type, {\n        base: toBuffer(params.basePubkey.toBuffer()),\n        seed: params.seed,\n        programId: toBuffer(params.programId.toBuffer()),\n      });\n      keys = [\n        {pubkey: params.accountPubkey, isSigner: false, isWritable: true},\n        {pubkey: params.basePubkey, isSigner: true, isWritable: false},\n      ];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n      data = encodeData(type, {\n        programId: toBuffer(params.programId.toBuffer()),\n      });\n      keys = [{pubkey: params.accountPubkey, isSigner: true, isWritable: true}];\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */\n  static createAccountWithSeed(\n    params: CreateAccountWithSeedParams,\n  ): TransactionInstruction {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n    const data = encodeData(type, {\n      base: toBuffer(params.basePubkey.toBuffer()),\n      seed: params.seed,\n      lamports: params.lamports,\n      space: params.space,\n      programId: toBuffer(params.programId.toBuffer()),\n    });\n    let keys = [\n      {pubkey: params.fromPubkey, isSigner: true, isWritable: true},\n      {pubkey: params.newAccountPubkey, isSigner: false, isWritable: true},\n    ];\n    if (!params.basePubkey.equals(params.fromPubkey)) {\n      keys.push({\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false,\n      });\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a transaction that creates a new Nonce account\n   */\n  static createNonceAccount(\n    params: CreateNonceAccountParams | CreateNonceAccountWithSeedParams,\n  ): Transaction {\n    const transaction = new Transaction();\n    if ('basePubkey' in params && 'seed' in params) {\n      transaction.add(\n        SystemProgram.createAccountWithSeed({\n          fromPubkey: params.fromPubkey,\n          newAccountPubkey: params.noncePubkey,\n          basePubkey: params.basePubkey,\n          seed: params.seed,\n          lamports: params.lamports,\n          space: NONCE_ACCOUNT_LENGTH,\n          programId: this.programId,\n        }),\n      );\n    } else {\n      transaction.add(\n        SystemProgram.createAccount({\n          fromPubkey: params.fromPubkey,\n          newAccountPubkey: params.noncePubkey,\n          lamports: params.lamports,\n          space: NONCE_ACCOUNT_LENGTH,\n          programId: this.programId,\n        }),\n      );\n    }\n\n    const initParams = {\n      noncePubkey: params.noncePubkey,\n      authorizedPubkey: params.authorizedPubkey,\n    };\n\n    transaction.add(this.nonceInitialize(initParams));\n    return transaction;\n  }\n\n  /**\n   * Generate an instruction to initialize a Nonce account\n   */\n  static nonceInitialize(\n    params: InitializeNonceParams,\n  ): TransactionInstruction {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n    const data = encodeData(type, {\n      authorized: toBuffer(params.authorizedPubkey.toBuffer()),\n    });\n    const instructionData = {\n      keys: [\n        {pubkey: params.noncePubkey, isSigner: false, isWritable: true},\n        {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */\n  static nonceAdvance(params: AdvanceNonceParams): TransactionInstruction {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n    const data = encodeData(type);\n    const instructionData = {\n      keys: [\n        {pubkey: params.noncePubkey, isSigner: false, isWritable: true},\n        {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {pubkey: params.authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */\n  static nonceWithdraw(params: WithdrawNonceParams): TransactionInstruction {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n    const data = encodeData(type, {lamports: params.lamports});\n\n    return new TransactionInstruction({\n      keys: [\n        {pubkey: params.noncePubkey, isSigner: false, isWritable: true},\n        {pubkey: params.toPubkey, isSigner: false, isWritable: true},\n        {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {pubkey: params.authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */\n  static nonceAuthorize(params: AuthorizeNonceParams): TransactionInstruction {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n    const data = encodeData(type, {\n      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer()),\n    });\n\n    return new TransactionInstruction({\n      keys: [\n        {pubkey: params.noncePubkey, isSigner: false, isWritable: true},\n        {pubkey: params.authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */\n  static allocate(\n    params: AllocateParams | AllocateWithSeedParams,\n  ): TransactionInstruction {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n      data = encodeData(type, {\n        base: toBuffer(params.basePubkey.toBuffer()),\n        seed: params.seed,\n        space: params.space,\n        programId: toBuffer(params.programId.toBuffer()),\n      });\n      keys = [\n        {pubkey: params.accountPubkey, isSigner: false, isWritable: true},\n        {pubkey: params.basePubkey, isSigner: true, isWritable: false},\n      ];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n      data = encodeData(type, {\n        space: params.space,\n      });\n      keys = [{pubkey: params.accountPubkey, isSigner: true, isWritable: true}];\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data,\n    });\n  }\n}\n", "import {Buffer} from 'buffer';\nimport * as BufferLayout from '@solana/buffer-layout';\n\nimport {PublicKey} from './publickey';\nimport {Transaction, PACKET_DATA_SIZE} from './transaction';\nimport {MS_PER_SLOT} from './timing';\nimport {SYSVAR_RENT_PUBKEY} from './sysvar';\nimport {sendAndConfirmTransaction} from './utils/send-and-confirm-transaction';\nimport {sleep} from './utils/sleep';\nimport type {Connection} from './connection';\nimport type {Signer} from './keypair';\nimport {SystemProgram} from './programs/system';\nimport {IInstructionInputData} from './instruction';\n\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n\n/**\n * Program loader interface\n */\nexport class Loader {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Amount of program data placed in each load Transaction\n   */\n  static chunkSize: number = CHUNK_SIZE;\n\n  /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */\n  static getMinNumSignatures(dataLength: number): number {\n    return (\n      2 * // Every transaction requires two signatures (payer + program)\n      (Math.ceil(dataLength / Loader.chunkSize) +\n        1 + // Add one for Create transaction\n        1) // Add one for Finalize transaction\n    );\n  }\n\n  /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */\n  static async load(\n    connection: Connection,\n    payer: Signer,\n    program: Signer,\n    programId: PublicKey,\n    data: Buffer | Uint8Array | Array<number>,\n  ): Promise<boolean> {\n    {\n      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(\n        data.length,\n      );\n\n      // Fetch program account info to check if it has already been created\n      const programInfo = await connection.getAccountInfo(\n        program.publicKey,\n        'confirmed',\n      );\n\n      let transaction: Transaction | null = null;\n      if (programInfo !== null) {\n        if (programInfo.executable) {\n          console.error('Program load failed, account is already executable');\n          return false;\n        }\n\n        if (programInfo.data.length !== data.length) {\n          transaction = transaction || new Transaction();\n          transaction.add(\n            SystemProgram.allocate({\n              accountPubkey: program.publicKey,\n              space: data.length,\n            }),\n          );\n        }\n\n        if (!programInfo.owner.equals(programId)) {\n          transaction = transaction || new Transaction();\n          transaction.add(\n            SystemProgram.assign({\n              accountPubkey: program.publicKey,\n              programId,\n            }),\n          );\n        }\n\n        if (programInfo.lamports < balanceNeeded) {\n          transaction = transaction || new Transaction();\n          transaction.add(\n            SystemProgram.transfer({\n              fromPubkey: payer.publicKey,\n              toPubkey: program.publicKey,\n              lamports: balanceNeeded - programInfo.lamports,\n            }),\n          );\n        }\n      } else {\n        transaction = new Transaction().add(\n          SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: program.publicKey,\n            lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n            space: data.length,\n            programId,\n          }),\n        );\n      }\n\n      // If the account is already created correctly, skip this step\n      // and proceed directly to loading instructions\n      if (transaction !== null) {\n        await sendAndConfirmTransaction(\n          connection,\n          transaction,\n          [payer, program],\n          {\n            commitment: 'confirmed',\n          },\n        );\n      }\n    }\n\n    const dataLayout = BufferLayout.struct<\n      Readonly<{\n        bytes: number[];\n        bytesLength: number;\n        bytesLengthPadding: number;\n        instruction: number;\n        offset: number;\n      }>\n    >([\n      BufferLayout.u32('instruction'),\n      BufferLayout.u32('offset'),\n      BufferLayout.u32('bytesLength'),\n      BufferLayout.u32('bytesLengthPadding'),\n      BufferLayout.seq(\n        BufferLayout.u8('byte'),\n        BufferLayout.offset(BufferLayout.u32(), -8),\n        'bytes',\n      ),\n    ]);\n\n    const chunkSize = Loader.chunkSize;\n    let offset = 0;\n    let array = data;\n    let transactions = [];\n    while (array.length > 0) {\n      const bytes = array.slice(0, chunkSize);\n      const data = Buffer.alloc(chunkSize + 16);\n      dataLayout.encode(\n        {\n          instruction: 0, // Load instruction\n          offset,\n          bytes: bytes as number[],\n          bytesLength: 0,\n          bytesLengthPadding: 0,\n        },\n        data,\n      );\n\n      const transaction = new Transaction().add({\n        keys: [{pubkey: program.publicKey, isSigner: true, isWritable: true}],\n        programId,\n        data,\n      });\n      transactions.push(\n        sendAndConfirmTransaction(connection, transaction, [payer, program], {\n          commitment: 'confirmed',\n        }),\n      );\n\n      // Delay between sends in an attempt to reduce rate limit errors\n      if (connection._rpcEndpoint.includes('solana.com')) {\n        const REQUESTS_PER_SECOND = 4;\n        await sleep(1000 / REQUESTS_PER_SECOND);\n      }\n\n      offset += chunkSize;\n      array = array.slice(chunkSize);\n    }\n    await Promise.all(transactions);\n\n    // Finalize the account loaded with program data for execution\n    {\n      const dataLayout = BufferLayout.struct<IInstructionInputData>([\n        BufferLayout.u32('instruction'),\n      ]);\n\n      const data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode(\n        {\n          instruction: 1, // Finalize instruction\n        },\n        data,\n      );\n\n      const transaction = new Transaction().add({\n        keys: [\n          {pubkey: program.publicKey, isSigner: true, isWritable: true},\n          {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n        ],\n        programId,\n        data,\n      });\n      const deployCommitment = 'processed';\n      const finalizeSignature = await connection.sendTransaction(\n        transaction,\n        [payer, program],\n        {preflightCommitment: deployCommitment},\n      );\n      const {context, value} = await connection.confirmTransaction(\n        {\n          signature: finalizeSignature,\n          lastValidBlockHeight: transaction.lastValidBlockHeight!,\n          blockhash: transaction.recentBlockhash!,\n        },\n        deployCommitment,\n      );\n      if (value.err) {\n        throw new Error(\n          `Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`,\n        );\n      }\n      // We prevent programs from being usable until the slot after their deployment.\n      // See https://github.com/solana-labs/solana/pull/29654\n      while (\n        true // eslint-disable-line no-constant-condition\n      ) {\n        try {\n          const currentSlot = await connection.getSlot({\n            commitment: deployCommitment,\n          });\n          if (currentSlot > context.slot) {\n            break;\n          }\n        } catch {\n          /* empty */\n        }\n        await new Promise(resolve =>\n          setTimeout(resolve, Math.round(MS_PER_SLOT / 2)),\n        );\n      }\n    }\n\n    // success\n    return true;\n  }\n}\n", "import type {Buffer} from 'buffer';\n\nimport {PublicKey} from './publickey';\nimport {Loader} from './loader';\nimport type {Connection} from './connection';\nimport type {Signer} from './keypair';\n\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */\nexport const BPF_LOADER_PROGRAM_ID = new PublicKey(\n  'BPFLoader2111111111111111111111111111111111',\n);\n\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */\nexport class BpfLoader {\n  /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */\n  static getMinNumSignatures(dataLength: number): number {\n    return Loader.getMinNumSignatures(dataLength);\n  }\n\n  /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */\n  static load(\n    connection: Connection,\n    payer: Signer,\n    program: Signer,\n    elf: Buffer | Uint8Array | Array<number>,\n    loaderProgramId: PublicKey,\n  ): Promise<boolean> {\n    return Loader.load(connection, payer, program, loaderProgramId, elf);\n  }\n}\n", "var objToString = Object.prototype.toString;\nvar objKeys = Object.keys || function(obj) {\n\t\tvar keys = [];\n\t\tfor (var name in obj) {\n\t\t\tkeys.push(name);\n\t\t}\n\t\treturn keys;\n\t};\n\nfunction stringify(val, isArrayProp) {\n\tvar i, max, str, keys, key, propVal, toStr;\n\tif (val === true) {\n\t\treturn \"true\";\n\t}\n\tif (val === false) {\n\t\treturn \"false\";\n\t}\n\tswitch (typeof val) {\n\t\tcase \"object\":\n\t\t\tif (val === null) {\n\t\t\t\treturn null;\n\t\t\t} else if (val.toJSON && typeof val.toJSON === \"function\") {\n\t\t\t\treturn stringify(val.toJSON(), isArrayProp);\n\t\t\t} else {\n\t\t\t\ttoStr = objToString.call(val);\n\t\t\t\tif (toStr === \"[object Array]\") {\n\t\t\t\t\tstr = '[';\n\t\t\t\t\tmax = val.length - 1;\n\t\t\t\t\tfor(i = 0; i < max; i++) {\n\t\t\t\t\t\tstr += stringify(val[i], true) + ',';\n\t\t\t\t\t}\n\t\t\t\t\tif (max > -1) {\n\t\t\t\t\t\tstr += stringify(val[i], true);\n\t\t\t\t\t}\n\t\t\t\t\treturn str + ']';\n\t\t\t\t} else if (toStr === \"[object Object]\") {\n\t\t\t\t\t// only object is left\n\t\t\t\t\tkeys = objKeys(val).sort();\n\t\t\t\t\tmax = keys.length;\n\t\t\t\t\tstr = \"\";\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (i < max) {\n\t\t\t\t\t\tkey = keys[i];\n\t\t\t\t\t\tpropVal = stringify(val[key], false);\n\t\t\t\t\t\tif (propVal !== undefined) {\n\t\t\t\t\t\t\tif (str) {\n\t\t\t\t\t\t\t\tstr += ',';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstr += JSON.stringify(key) + ':' + propVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\treturn '{' + str + '}';\n\t\t\t\t} else {\n\t\t\t\t\treturn JSON.stringify(val);\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"function\":\n\t\tcase \"undefined\":\n\t\t\treturn isArrayProp ? null : undefined;\n\t\tcase \"string\":\n\t\t\treturn JSON.stringify(val);\n\t\tdefault:\n\t\t\treturn isFinite(val) ? val : null;\n\t}\n}\n\nmodule.exports = function(val) {\n\tvar returnVal = stringify(val, false);\n\tif (returnVal !== undefined) {\n\t\treturn ''+ returnVal;\n\t}\n};\n", "const MINIMUM_SLOT_PER_EPOCH = 32;\n\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n: number) {\n  let trailingZeros = 0;\n  while (n > 1) {\n    n /= 2;\n    trailingZeros++;\n  }\n  return trailingZeros;\n}\n\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n: number) {\n  if (n === 0) return 1;\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n  return n + 1;\n}\n\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */\nexport class EpochSchedule {\n  /** The maximum number of slots in each epoch */\n  public slotsPerEpoch: number;\n  /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */\n  public leaderScheduleSlotOffset: number;\n  /** Indicates whether epochs start short and grow */\n  public warmup: boolean;\n  /** The first epoch with `slotsPerEpoch` slots */\n  public firstNormalEpoch: number;\n  /** The first slot of `firstNormalEpoch` */\n  public firstNormalSlot: number;\n\n  constructor(\n    slotsPerEpoch: number,\n    leaderScheduleSlotOffset: number,\n    warmup: boolean,\n    firstNormalEpoch: number,\n    firstNormalSlot: number,\n  ) {\n    this.slotsPerEpoch = slotsPerEpoch;\n    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n    this.warmup = warmup;\n    this.firstNormalEpoch = firstNormalEpoch;\n    this.firstNormalSlot = firstNormalSlot;\n  }\n\n  getEpoch(slot: number): number {\n    return this.getEpochAndSlotIndex(slot)[0];\n  }\n\n  getEpochAndSlotIndex(slot: number): [number, number] {\n    if (slot < this.firstNormalSlot) {\n      const epoch =\n        trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) -\n        trailingZeros(MINIMUM_SLOT_PER_EPOCH) -\n        1;\n\n      const epochLen = this.getSlotsInEpoch(epoch);\n      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n      return [epoch, slotIndex];\n    } else {\n      const normalSlotIndex = slot - this.firstNormalSlot;\n      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n      const epoch = this.firstNormalEpoch + normalEpochIndex;\n      const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n      return [epoch, slotIndex];\n    }\n  }\n\n  getFirstSlotInEpoch(epoch: number): number {\n    if (epoch <= this.firstNormalEpoch) {\n      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n    } else {\n      return (\n        (epoch - this.firstNormalEpoch) * this.slotsPerEpoch +\n        this.firstNormalSlot\n      );\n    }\n  }\n\n  getLastSlotInEpoch(epoch: number): number {\n    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n  }\n\n  getSlotsInEpoch(epoch: number) {\n    if (epoch < this.firstNormalEpoch) {\n      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n    } else {\n      return this.slotsPerEpoch;\n    }\n  }\n}\n", "export const Headers: typeof globalThis.Headers = globalThis.Headers;\nexport const Request: typeof globalThis.Request = globalThis.Request;\nexport const Response: typeof globalThis.Response = globalThis.Response;\nexport default globalThis.fetch;\n", "import {\n  CommonClient,\n  ICommonWebSocket,\n  IWSClientAdditionalOptions,\n  NodeWebSocketType,\n  NodeWebSocketTypeOptions,\n  WebSocket as createRpc,\n} from 'rpc-websockets';\n\ninterface IHasReadyState {\n  readyState: WebSocket['readyState'];\n}\n\nexport default class RpcWebSocketClient extends CommonClient {\n  private underlyingSocket: IHasReadyState | undefined;\n  constructor(\n    address?: string,\n    options?: IWSClientAdditionalOptions & NodeWebSocketTypeOptions,\n    generate_request_id?: (\n      method: string,\n      params: object | Array<any>,\n    ) => number,\n  ) {\n    const webSocketFactory = (url: string) => {\n      const rpc = createRpc(url, {\n        autoconnect: true,\n        max_reconnects: 5,\n        reconnect: true,\n        reconnect_interval: 1000,\n        ...options,\n      });\n      if ('socket' in rpc) {\n        this.underlyingSocket = rpc.socket as ReturnType<typeof createRpc>;\n      } else {\n        this.underlyingSocket = rpc as NodeWebSocketType;\n      }\n      return rpc as ICommonWebSocket;\n    };\n    super(webSocketFactory, address, options, generate_request_id);\n  }\n  call(\n    ...args: Parameters<CommonClient['call']>\n  ): ReturnType<CommonClient['call']> {\n    const readyState = this.underlyingSocket?.readyState;\n    if (readyState === 1 /* WebSocket.OPEN */) {\n      return super.call(...args);\n    }\n    return Promise.reject(\n      new Error(\n        'Tried to call a JSON-RPC method `' +\n          args[0] +\n          '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +\n          readyState +\n          ')',\n      ),\n    );\n  }\n  notify(\n    ...args: Parameters<CommonClient['notify']>\n  ): ReturnType<CommonClient['notify']> {\n    const readyState = this.underlyingSocket?.readyState;\n    if (readyState === 1 /* WebSocket.OPEN */) {\n      return super.notify(...args);\n    }\n    return Promise.reject(\n      new Error(\n        'Tried to send a JSON-RPC notification `' +\n          args[0] +\n          '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' +\n          readyState +\n          ')',\n      ),\n    );\n  }\n}\n", "import * as BufferLayout from '@solana/buffer-layout';\n\nexport interface IAccountStateData {\n  readonly typeIndex: number;\n}\n\n/**\n * @internal\n */\nexport type AccountType<TInputData extends IAccountStateData> = {\n  /** The account type index (from solana upstream program) */\n  index: number;\n  /** The BufferLayout to use to build data */\n  layout: BufferLayout.Layout<TInputData>;\n};\n\n/**\n * Decode account data buffer using an AccountType\n * @internal\n */\nexport function decodeData<TAccountStateData extends IAccountStateData>(\n  type: AccountType<TAccountStateData>,\n  data: Uint8Array,\n): TAccountStateData {\n  let decoded: TAccountStateData;\n  try {\n    decoded = type.layout.decode(data);\n  } catch (err) {\n    throw new Error('invalid instruction; ' + err);\n  }\n\n  if (decoded.typeIndex !== type.index) {\n    throw new Error(\n      `invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`,\n    );\n  }\n\n  return decoded;\n}\n", "import * as BufferLayout from '@solana/buffer-layout';\n\nimport assert from '../../utils/assert';\nimport * as Layout from '../../layout';\nimport {PublicKey} from '../../publickey';\nimport {u64} from '../../utils/bigint';\nimport {decodeData} from '../../account-data';\n\nexport type AddressLookupTableState = {\n  deactivationSlot: bigint;\n  lastExtendedSlot: number;\n  lastExtendedSlotStartIndex: number;\n  authority?: PublicKey;\n  addresses: Array<PublicKey>;\n};\n\nexport type AddressLookupTableAccountArgs = {\n  key: PublicKey;\n  state: AddressLookupTableState;\n};\n\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\n\nexport class AddressLookupTableAccount {\n  key: PublicKey;\n  state: AddressLookupTableState;\n\n  constructor(args: AddressLookupTableAccountArgs) {\n    this.key = args.key;\n    this.state = args.state;\n  }\n\n  isActive(): boolean {\n    const U64_MAX = BigInt('0xffffffffffffffff');\n    return this.state.deactivationSlot === U64_MAX;\n  }\n\n  static deserialize(accountData: Uint8Array): AddressLookupTableState {\n    const meta = decodeData(LookupTableMetaLayout, accountData);\n\n    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n    assert(serializedAddressesLen >= 0, 'lookup table is invalid');\n    assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');\n\n    const numSerializedAddresses = serializedAddressesLen / 32;\n    const {addresses} = BufferLayout.struct<{addresses: Array<Uint8Array>}>([\n      BufferLayout.seq(Layout.publicKey(), numSerializedAddresses, 'addresses'),\n    ]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n\n    return {\n      deactivationSlot: meta.deactivationSlot,\n      lastExtendedSlot: meta.lastExtendedSlot,\n      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n      authority:\n        meta.authority.length !== 0\n          ? new PublicKey(meta.authority[0])\n          : undefined,\n      addresses: addresses.map(address => new PublicKey(address)),\n    };\n  }\n}\n\nconst LookupTableMetaLayout = {\n  index: 1,\n  layout: BufferLayout.struct<{\n    typeIndex: number;\n    deactivationSlot: bigint;\n    lastExtendedSlot: number;\n    lastExtendedStartIndex: number;\n    authority: Array<Uint8Array>;\n  }>([\n    BufferLayout.u32('typeIndex'),\n    u64('deactivationSlot'),\n    BufferLayout.nu64('lastExtendedSlot'),\n    BufferLayout.u8('lastExtendedStartIndex'),\n    BufferLayout.u8(), // option\n    BufferLayout.seq(\n      Layout.publicKey(),\n      BufferLayout.offset(BufferLayout.u8(), -1),\n      'authority',\n    ),\n  ]),\n};\n", "const URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\n\nexport function makeWebsocketUrl(endpoint: string) {\n  const matches = endpoint.match(URL_RE);\n  if (matches == null) {\n    throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n  }\n  const [\n    _, // eslint-disable-line @typescript-eslint/no-unused-vars\n    hostish,\n    portWithColon,\n    rest,\n  ] = matches;\n  const protocol = endpoint.startsWith('https:') ? 'wss:' : 'ws:';\n  const startPort =\n    portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n  const websocketPort =\n    // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n    // we're directly trying to connect to agave-validator's ws listening port.\n    // When the endpoint omits the port, we're connecting to the protocol\n    // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n    // proxy which manages WebSocket upgrade and backend port redirection.\n    startPort == null ? '' : `:${startPort + 1}`;\n  return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\n", "import HttpKeepAliveAgent, {\n  HttpsAgent as HttpsKeepAliveAgent,\n} from 'agentkeepalive';\nimport bs58 from 'bs58';\nimport {Buffer} from 'buffer';\n// @ts-ignore\nimport fastStableStringify from 'fast-stable-stringify';\nimport type {Agent as NodeHttpAgent} from 'http';\nimport {Agent as NodeHttpsAgent} from 'https';\nimport {\n  type as pick,\n  number,\n  string,\n  array,\n  boolean,\n  literal,\n  record,\n  union,\n  optional,\n  nullable,\n  coerce,\n  instance,\n  create,\n  tuple,\n  unknown,\n  any,\n} from 'superstruct';\nimport type {Struct} from 'superstruct';\nimport RpcClient from 'jayson/lib/client/browser';\nimport {JSONRPCError} from 'jayson';\n\nimport {EpochSchedule} from './epoch-schedule';\nimport {SendTransactionError, SolanaJSONRPCError} from './errors';\nimport fetchImpl from './fetch-impl';\nimport {DurableNonce, NonceAccount} from './nonce-account';\nimport {PublicKey} from './publickey';\nimport {Signer} from './keypair';\nimport RpcWebSocketClient from './rpc-websocket';\nimport {MS_PER_SLOT} from './timing';\nimport {\n  Transaction,\n  TransactionStatus,\n  TransactionVersion,\n  VersionedTransaction,\n} from './transaction';\nimport {Message, MessageHeader, MessageV0, VersionedMessage} from './message';\nimport {AddressLookupTableAccount} from './programs/address-lookup-table/state';\nimport assert from './utils/assert';\nimport {sleep} from './utils/sleep';\nimport {toBuffer} from './utils/to-buffer';\nimport {\n  TransactionExpiredBlockheightExceededError,\n  TransactionExpiredNonceInvalidError,\n  TransactionExpiredTimeoutError,\n} from './transaction/expiry-custom-errors';\nimport {makeWebsocketUrl} from './utils/makeWebsocketUrl';\nimport type {Blockhash} from './blockhash';\nimport type {FeeCalculator} from './fee-calculator';\nimport type {TransactionSignature} from './transaction';\nimport type {CompiledInstruction} from './message';\n\nconst PublicKeyFromString = coerce(\n  instance(PublicKey),\n  string(),\n  value => new PublicKey(value),\n);\n\nconst RawAccountDataResult = tuple([string(), literal('base64')]);\n\nconst BufferFromRawAccountData = coerce(\n  instance(Buffer),\n  RawAccountDataResult,\n  value => Buffer.from(value[0], 'base64'),\n);\n\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */\nexport const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */\ninterface IWSRequestParams {\n  [x: string]: any;\n  [x: number]: any;\n}\n\ntype ClientSubscriptionId = number;\n/** @internal */ type ServerSubscriptionId = number;\n/** @internal */ type SubscriptionConfigHash = string;\n/** @internal */ type SubscriptionDisposeFn = () => Promise<void>;\n/** @internal */ type SubscriptionStateChangeCallback = (\n  nextState: StatefulSubscription['state'],\n) => void;\n/** @internal */ type SubscriptionStateChangeDisposeFn = () => void;\n/**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */\ntype BaseSubscription<TMethod = SubscriptionConfig['method']> = Readonly<{\n  args: IWSRequestParams;\n  callbacks: Set<Extract<SubscriptionConfig, {method: TMethod}>['callback']>;\n}>;\n/**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */\ntype StatefulSubscription = Readonly<\n  // New subscriptions that have not yet been\n  // sent to the server start in this state.\n  | {\n      state: 'pending';\n    }\n  // These subscriptions have been sent to the server\n  // and are waiting for the server to acknowledge them.\n  | {\n      state: 'subscribing';\n    }\n  // These subscriptions have been acknowledged by the\n  // server and have been assigned server subscription ids.\n  | {\n      serverSubscriptionId: ServerSubscriptionId;\n      state: 'subscribed';\n    }\n  // These subscriptions are intended to be torn down and\n  // are waiting on an acknowledgement from the server.\n  | {\n      serverSubscriptionId: ServerSubscriptionId;\n      state: 'unsubscribing';\n    }\n  // The request to tear down these subscriptions has been\n  // acknowledged by the server. The `serverSubscriptionId`\n  // is the id of the now-dead subscription.\n  | {\n      serverSubscriptionId: ServerSubscriptionId;\n      state: 'unsubscribed';\n    }\n>;\n/**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */\ntype SubscriptionConfig = Readonly<\n  | {\n      callback: AccountChangeCallback;\n      method: 'accountSubscribe';\n      unsubscribeMethod: 'accountUnsubscribe';\n    }\n  | {\n      callback: LogsCallback;\n      method: 'logsSubscribe';\n      unsubscribeMethod: 'logsUnsubscribe';\n    }\n  | {\n      callback: ProgramAccountChangeCallback;\n      method: 'programSubscribe';\n      unsubscribeMethod: 'programUnsubscribe';\n    }\n  | {\n      callback: RootChangeCallback;\n      method: 'rootSubscribe';\n      unsubscribeMethod: 'rootUnsubscribe';\n    }\n  | {\n      callback: SignatureSubscriptionCallback;\n      method: 'signatureSubscribe';\n      unsubscribeMethod: 'signatureUnsubscribe';\n    }\n  | {\n      callback: SlotChangeCallback;\n      method: 'slotSubscribe';\n      unsubscribeMethod: 'slotUnsubscribe';\n    }\n  | {\n      callback: SlotUpdateCallback;\n      method: 'slotsUpdatesSubscribe';\n      unsubscribeMethod: 'slotsUpdatesUnsubscribe';\n    }\n>;\n/**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */\ntype DistributiveOmit<T, K extends PropertyKey> = T extends unknown\n  ? Omit<T, K>\n  : never;\n/**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */\ntype Subscription = BaseSubscription &\n  StatefulSubscription &\n  DistributiveOmit<SubscriptionConfig, 'callback'>;\n\ntype RpcRequest = (methodName: string, args: Array<any>) => Promise<any>;\n\ntype RpcBatchRequest = (requests: RpcParams[]) => Promise<any[]>;\n\n/**\n * @internal\n */\nexport type RpcParams = {\n  methodName: string;\n  args: Array<any>;\n};\n\nexport type TokenAccountsFilter =\n  | {\n      mint: PublicKey;\n    }\n  | {\n      programId: PublicKey;\n    };\n\n/**\n * Extra contextual information for RPC responses\n */\nexport type Context = {\n  slot: number;\n};\n\n/**\n * Options for sending transactions\n */\nexport type SendOptions = {\n  /** disable transaction verification step */\n  skipPreflight?: boolean;\n  /** preflight commitment level */\n  preflightCommitment?: Commitment;\n  /** Maximum number of times for the RPC node to retry sending the transaction to the leader. */\n  maxRetries?: number;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Options for confirming transactions\n */\nexport type ConfirmOptions = {\n  /** disable transaction verification step */\n  skipPreflight?: boolean;\n  /** desired commitment level */\n  commitment?: Commitment;\n  /** preflight commitment level */\n  preflightCommitment?: Commitment;\n  /** Maximum number of times for the RPC node to retry sending the transaction to the leader. */\n  maxRetries?: number;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Options for getConfirmedSignaturesForAddress2\n */\nexport type ConfirmedSignaturesForAddress2Options = {\n  /**\n   * Start searching backwards from this transaction signature.\n   * @remarks If not provided the search starts from the highest max confirmed block.\n   */\n  before?: TransactionSignature;\n  /** Search until this transaction signature is reached, if found before `limit`. */\n  until?: TransactionSignature;\n  /** Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). */\n  limit?: number;\n};\n\n/**\n * Options for getSignaturesForAddress\n */\nexport type SignaturesForAddressOptions = {\n  /**\n   * Start searching backwards from this transaction signature.\n   * @remarks If not provided the search starts from the highest max confirmed block.\n   */\n  before?: TransactionSignature;\n  /** Search until this transaction signature is reached, if found before `limit`. */\n  until?: TransactionSignature;\n  /** Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). */\n  limit?: number;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * RPC Response with extra contextual information\n */\nexport type RpcResponseAndContext<T> = {\n  /** response context */\n  context: Context;\n  /** response value */\n  value: T;\n};\n\nexport type BlockhashWithExpiryBlockHeight = Readonly<{\n  blockhash: Blockhash;\n  lastValidBlockHeight: number;\n}>;\n\n/**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */\nexport type BlockheightBasedTransactionConfirmationStrategy =\n  BaseTransactionConfirmationStrategy & BlockhashWithExpiryBlockHeight;\n\n/**\n * A strategy for confirming durable nonce transactions.\n */\nexport type DurableNonceTransactionConfirmationStrategy =\n  BaseTransactionConfirmationStrategy & {\n    /**\n     * The lowest slot at which to fetch the nonce value from the\n     * nonce account. This should be no lower than the slot at\n     * which the last-known value of the nonce was fetched.\n     */\n    minContextSlot: number;\n    /**\n     * The account where the current value of the nonce is stored.\n     */\n    nonceAccountPubkey: PublicKey;\n    /**\n     * The nonce value that was used to sign the transaction\n     * for which confirmation is being sought.\n     */\n    nonceValue: DurableNonce;\n  };\n\n/**\n * Properties shared by all transaction confirmation strategies\n */\nexport type BaseTransactionConfirmationStrategy = Readonly<{\n  /** A signal that, when aborted, cancels any outstanding transaction confirmation operations */\n  abortSignal?: AbortSignal;\n  signature: TransactionSignature;\n}>;\n\n/**\n * This type represents all transaction confirmation strategies\n */\nexport type TransactionConfirmationStrategy =\n  | BlockheightBasedTransactionConfirmationStrategy\n  | DurableNonceTransactionConfirmationStrategy;\n\n/* @internal */\nfunction assertEndpointUrl(putativeUrl: string) {\n  if (/^https?:/.test(putativeUrl) === false) {\n    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');\n  }\n  return putativeUrl;\n}\n\n/** @internal */\nfunction extractCommitmentFromConfig<TConfig>(\n  commitmentOrConfig?: Commitment | ({commitment?: Commitment} & TConfig),\n) {\n  let commitment: Commitment | undefined;\n  let config: Omit<TConfig, 'commitment'> | undefined;\n  if (typeof commitmentOrConfig === 'string') {\n    commitment = commitmentOrConfig;\n  } else if (commitmentOrConfig) {\n    const {commitment: specifiedCommitment, ...specifiedConfig} =\n      commitmentOrConfig;\n    commitment = specifiedCommitment;\n    config = specifiedConfig;\n  }\n  return {commitment, config};\n}\n\n/**\n * @internal\n */\nfunction applyDefaultMemcmpEncodingToFilters(\n  filters: GetProgramAccountsFilter[],\n): GetProgramAccountsFilter[] {\n  return filters.map(filter =>\n    'memcmp' in filter\n      ? {\n          ...filter,\n          memcmp: {\n            ...filter.memcmp,\n            encoding: filter.memcmp.encoding ?? 'base58',\n          },\n        }\n      : filter,\n  );\n}\n\n/**\n * @internal\n */\nfunction createRpcResult<T, U>(result: Struct<T, U>) {\n  return union([\n    pick({\n      jsonrpc: literal('2.0'),\n      id: string(),\n      result,\n    }),\n    pick({\n      jsonrpc: literal('2.0'),\n      id: string(),\n      error: pick({\n        code: unknown(),\n        message: string(),\n        data: optional(any()),\n      }),\n    }),\n  ]);\n}\n\nconst UnknownRpcResult = createRpcResult(unknown());\n\n/**\n * @internal\n */\nfunction jsonRpcResult<T, U>(schema: Struct<T, U>) {\n  return coerce(createRpcResult(schema), UnknownRpcResult, value => {\n    if ('error' in value) {\n      return value;\n    } else {\n      return {\n        ...value,\n        result: create(value.result, schema),\n      };\n    }\n  });\n}\n\n/**\n * @internal\n */\nfunction jsonRpcResultAndContext<T, U>(value: Struct<T, U>) {\n  return jsonRpcResult(\n    pick({\n      context: pick({\n        slot: number(),\n      }),\n      value,\n    }),\n  );\n}\n\n/**\n * @internal\n */\nfunction notificationResultAndContext<T, U>(value: Struct<T, U>) {\n  return pick({\n    context: pick({\n      slot: number(),\n    }),\n    value,\n  });\n}\n\n/**\n * @internal\n */\nfunction versionedMessageFromResponse(\n  version: TransactionVersion | undefined,\n  response: MessageResponse,\n): VersionedMessage {\n  if (version === 0) {\n    return new MessageV0({\n      header: response.header,\n      staticAccountKeys: response.accountKeys.map(\n        accountKey => new PublicKey(accountKey),\n      ),\n      recentBlockhash: response.recentBlockhash,\n      compiledInstructions: response.instructions.map(ix => ({\n        programIdIndex: ix.programIdIndex,\n        accountKeyIndexes: ix.accounts,\n        data: bs58.decode(ix.data),\n      })),\n      addressTableLookups: response.addressTableLookups!,\n    });\n  } else {\n    return new Message(response);\n  }\n}\n\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */\nexport type Commitment =\n  | 'processed'\n  | 'confirmed'\n  | 'finalized'\n  | 'recent' // Deprecated as of v1.5.5\n  | 'single' // Deprecated as of v1.5.5\n  | 'singleGossip' // Deprecated as of v1.5.5\n  | 'root' // Deprecated as of v1.5.5\n  | 'max'; // Deprecated as of v1.5.5\n\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */\nexport type Finality = 'confirmed' | 'finalized';\n\n/**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */\nexport type LargestAccountsFilter = 'circulating' | 'nonCirculating';\n\n/**\n * Configuration object for changing `getAccountInfo` query behavior\n */\nexport type GetAccountInfoConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n  /** Optional data slice to limit the returned account data */\n  dataSlice?: DataSlice;\n};\n\n/**\n * Configuration object for changing `getBalance` query behavior\n */\nexport type GetBalanceConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for changing `getBlock` query behavior\n */\nexport type GetBlockConfig = {\n  /** The level of finality desired */\n  commitment?: Finality;\n  /**\n   * Whether to populate the rewards array. If parameter not provided, the default includes rewards.\n   */\n  rewards?: boolean;\n  /**\n   * Level of transaction detail to return, either \"full\", \"accounts\", \"signatures\", or \"none\". If\n   * parameter not provided, the default detail level is \"full\". If \"accounts\" are requested,\n   * transaction details only include signatures and an annotated list of accounts in each\n   * transaction. Transaction metadata is limited to only: fee, err, pre_balances, post_balances,\n   * pre_token_balances, and post_token_balances.\n   */\n  transactionDetails?: 'accounts' | 'full' | 'none' | 'signatures';\n};\n\n/**\n * Configuration object for changing `getBlock` query behavior\n */\nexport type GetVersionedBlockConfig = {\n  /** The level of finality desired */\n  commitment?: Finality;\n  /** The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned */\n  maxSupportedTransactionVersion?: number;\n  /**\n   * Whether to populate the rewards array. If parameter not provided, the default includes rewards.\n   */\n  rewards?: boolean;\n  /**\n   * Level of transaction detail to return, either \"full\", \"accounts\", \"signatures\", or \"none\". If\n   * parameter not provided, the default detail level is \"full\". If \"accounts\" are requested,\n   * transaction details only include signatures and an annotated list of accounts in each\n   * transaction. Transaction metadata is limited to only: fee, err, pre_balances, post_balances,\n   * pre_token_balances, and post_token_balances.\n   */\n  transactionDetails?: 'accounts' | 'full' | 'none' | 'signatures';\n};\n\n/**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */\nexport type GetStakeMinimumDelegationConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n};\n\n/**\n * Configuration object for changing `getBlockHeight` query behavior\n */\nexport type GetBlockHeightConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for changing `getEpochInfo` query behavior\n */\nexport type GetEpochInfoConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for changing `getInflationReward` query behavior\n */\nexport type GetInflationRewardConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n  /** An epoch for which the reward occurs. If omitted, the previous epoch will be used */\n  epoch?: number;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */\nexport type GetLatestBlockhashConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for changing `isBlockhashValid` query behavior\n */\nexport type IsBlockhashValidConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for changing `getSlot` query behavior\n */\nexport type GetSlotConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for changing `getSlotLeader` query behavior\n */\nexport type GetSlotLeaderConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for changing `getTransaction` query behavior\n */\nexport type GetTransactionConfig = {\n  /** The level of finality desired */\n  commitment?: Finality;\n};\n\n/**\n * Configuration object for changing `getTransaction` query behavior\n */\nexport type GetVersionedTransactionConfig = {\n  /** The level of finality desired */\n  commitment?: Finality;\n  /** The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned */\n  maxSupportedTransactionVersion?: number;\n};\n\n/**\n * Configuration object for changing `getLargestAccounts` query behavior\n */\nexport type GetLargestAccountsConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n  /** Filter largest accounts by whether they are part of the circulating supply */\n  filter?: LargestAccountsFilter;\n};\n\n/**\n * Configuration object for changing `getSupply` request behavior\n */\nexport type GetSupplyConfig = {\n  /** The level of commitment desired */\n  commitment?: Commitment;\n  /** Exclude non circulating accounts list from response */\n  excludeNonCirculatingAccountsList?: boolean;\n};\n\n/**\n * Configuration object for changing query behavior\n */\nexport type SignatureStatusConfig = {\n  /** enable searching status history, not needed for recent transactions */\n  searchTransactionHistory: boolean;\n};\n\n/**\n * Information describing a cluster node\n */\nexport type ContactInfo = {\n  /** Identity public key of the node */\n  pubkey: string;\n  /** Gossip network address for the node */\n  gossip: string | null;\n  /** TPU network address for the node (null if not available) */\n  tpu: string | null;\n  /** JSON RPC network address for the node (null if not available) */\n  rpc: string | null;\n  /** Software version of the node (null if not available) */\n  version: string | null;\n};\n\n/**\n * Information describing a vote account\n */\nexport type VoteAccountInfo = {\n  /** Public key of the vote account */\n  votePubkey: string;\n  /** Identity public key of the node voting with this account */\n  nodePubkey: string;\n  /** The stake, in lamports, delegated to this vote account and activated */\n  activatedStake: number;\n  /** Whether the vote account is staked for this epoch */\n  epochVoteAccount: boolean;\n  /** Recent epoch voting credit history for this voter */\n  epochCredits: Array<[number, number, number]>;\n  /** A percentage (0-100) of rewards payout owed to the voter */\n  commission: number;\n  /** Most recent slot voted on by this vote account */\n  lastVote: number;\n};\n\n/**\n * A collection of cluster vote accounts\n */\nexport type VoteAccountStatus = {\n  /** Active vote accounts */\n  current: Array<VoteAccountInfo>;\n  /** Inactive vote accounts */\n  delinquent: Array<VoteAccountInfo>;\n};\n\n/**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */\nexport type InflationGovernor = {\n  foundation: number;\n  foundationTerm: number;\n  initial: number;\n  taper: number;\n  terminal: number;\n};\n\nconst GetInflationGovernorResult = pick({\n  foundation: number(),\n  foundationTerm: number(),\n  initial: number(),\n  taper: number(),\n  terminal: number(),\n});\n\n/**\n * The inflation reward for an epoch\n */\nexport type InflationReward = {\n  /** epoch for which the reward occurs */\n  epoch: number;\n  /** the slot in which the rewards are effective */\n  effectiveSlot: number;\n  /** reward amount in lamports */\n  amount: number;\n  /** post balance of the account in lamports */\n  postBalance: number;\n  /** vote account commission when the reward was credited */\n  commission?: number | null;\n};\n\n/**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */\nconst GetInflationRewardResult = jsonRpcResult(\n  array(\n    nullable(\n      pick({\n        epoch: number(),\n        effectiveSlot: number(),\n        amount: number(),\n        postBalance: number(),\n        commission: optional(nullable(number())),\n      }),\n    ),\n  ),\n);\n\nexport type RecentPrioritizationFees = {\n  /** slot in which the fee was observed */\n  slot: number;\n  /** the per-compute-unit fee paid by at least one successfully landed transaction, specified in increments of 0.000001 lamports*/\n  prioritizationFee: number;\n};\n\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */\nexport type GetRecentPrioritizationFeesConfig = {\n  /**\n   * If this parameter is provided, the response will reflect a fee to land a transaction locking\n   * all of the provided accounts as writable.\n   */\n  lockedWritableAccounts?: PublicKey[];\n};\n\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */\nconst GetRecentPrioritizationFeesResult = array(\n  pick({\n    slot: number(),\n    prioritizationFee: number(),\n  }),\n);\n\nexport type InflationRate = {\n  /** total inflation */\n  total: number;\n  /** inflation allocated to validators */\n  validator: number;\n  /** inflation allocated to the foundation */\n  foundation: number;\n  /** epoch for which these values are valid */\n  epoch: number;\n};\n\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */\nconst GetInflationRateResult = pick({\n  total: number(),\n  validator: number(),\n  foundation: number(),\n  epoch: number(),\n});\n\n/**\n * Information about the current epoch\n */\nexport type EpochInfo = {\n  epoch: number;\n  slotIndex: number;\n  slotsInEpoch: number;\n  absoluteSlot: number;\n  blockHeight?: number;\n  transactionCount?: number;\n};\n\nconst GetEpochInfoResult = pick({\n  epoch: number(),\n  slotIndex: number(),\n  slotsInEpoch: number(),\n  absoluteSlot: number(),\n  blockHeight: optional(number()),\n  transactionCount: optional(number()),\n});\n\nconst GetEpochScheduleResult = pick({\n  slotsPerEpoch: number(),\n  leaderScheduleSlotOffset: number(),\n  warmup: boolean(),\n  firstNormalEpoch: number(),\n  firstNormalSlot: number(),\n});\n\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */\nexport type LeaderSchedule = {\n  [address: string]: number[];\n};\n\nconst GetLeaderScheduleResult = record(string(), array(number()));\n\n/**\n * Transaction error or null\n */\nconst TransactionErrorResult = nullable(union([pick({}), string()]));\n\n/**\n * Signature status for a transaction\n */\nconst SignatureStatusResult = pick({\n  err: TransactionErrorResult,\n});\n\n/**\n * Transaction signature received notification\n */\nconst SignatureReceivedResult = literal('receivedSignature');\n\n/**\n * Version info for a node\n */\nexport type Version = {\n  /** Version of solana-core */\n  'solana-core': string;\n  'feature-set'?: number;\n};\n\nconst VersionResult = pick({\n  'solana-core': string(),\n  'feature-set': optional(number()),\n});\n\nexport type SimulatedTransactionAccountInfo = {\n  /** `true` if this account's data contains a loaded program */\n  executable: boolean;\n  /** Identifier of the program that owns the account */\n  owner: string;\n  /** Number of lamports assigned to the account */\n  lamports: number;\n  /** Optional data assigned to the account */\n  data: string[];\n  /** Optional rent epoch info for account */\n  rentEpoch?: number;\n};\n\nexport type TransactionReturnDataEncoding = 'base64';\n\nexport type TransactionReturnData = {\n  programId: string;\n  data: [string, TransactionReturnDataEncoding];\n};\n\nexport type SimulateTransactionConfig = {\n  /** Optional parameter used to enable signature verification before simulation */\n  sigVerify?: boolean;\n  /** Optional parameter used to replace the simulated transaction's recent blockhash with the latest blockhash */\n  replaceRecentBlockhash?: boolean;\n  /** Optional parameter used to set the commitment level when selecting the latest block */\n  commitment?: Commitment;\n  /** Optional parameter used to specify a list of base58-encoded account addresses to return post simulation state for */\n  accounts?: {\n    /** The encoding of the returned account's data */\n    encoding: 'base64';\n    addresses: string[];\n  };\n  /** Optional parameter used to specify the minimum block slot that can be used for simulation */\n  minContextSlot?: number;\n  /** Optional parameter used to include inner instructions in the simulation */\n  innerInstructions?: boolean;\n};\n\nexport type SimulatedTransactionResponse = {\n  err: TransactionError | string | null;\n  logs: Array<string> | null;\n  accounts?: (SimulatedTransactionAccountInfo | null)[] | null;\n  unitsConsumed?: number;\n  returnData?: TransactionReturnData | null;\n  innerInstructions?: ParsedInnerInstruction[] | null;\n};\nconst ParsedInstructionStruct = pick({\n  program: string(),\n  programId: PublicKeyFromString,\n  parsed: unknown(),\n});\n\nconst PartiallyDecodedInstructionStruct = pick({\n  programId: PublicKeyFromString,\n  accounts: array(PublicKeyFromString),\n  data: string(),\n});\n\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext(\n  pick({\n    err: nullable(union([pick({}), string()])),\n    logs: nullable(array(string())),\n    accounts: optional(\n      nullable(\n        array(\n          nullable(\n            pick({\n              executable: boolean(),\n              owner: string(),\n              lamports: number(),\n              data: array(string()),\n              rentEpoch: optional(number()),\n            }),\n          ),\n        ),\n      ),\n    ),\n    unitsConsumed: optional(number()),\n    returnData: optional(\n      nullable(\n        pick({\n          programId: string(),\n          data: tuple([string(), literal('base64')]),\n        }),\n      ),\n    ),\n    innerInstructions: optional(\n      nullable(\n        array(\n          pick({\n            index: number(),\n            instructions: array(\n              union([\n                ParsedInstructionStruct,\n                PartiallyDecodedInstructionStruct,\n              ]),\n            ),\n          }),\n        ),\n      ),\n    ),\n  }),\n);\n\nexport type ParsedInnerInstruction = {\n  index: number;\n  instructions: (ParsedInstruction | PartiallyDecodedInstruction)[];\n};\n\nexport type TokenBalance = {\n  accountIndex: number;\n  mint: string;\n  owner?: string;\n  programId?: string;\n  uiTokenAmount: TokenAmount;\n};\n\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */\nexport type ParsedConfirmedTransactionMeta = ParsedTransactionMeta;\n\n/**\n * Collection of addresses loaded by a transaction using address table lookups\n */\nexport type LoadedAddresses = {\n  writable: Array<PublicKey>;\n  readonly: Array<PublicKey>;\n};\n\n/**\n * Metadata for a parsed transaction on the ledger\n */\nexport type ParsedTransactionMeta = {\n  /** The fee charged for processing the transaction */\n  fee: number;\n  /** An array of cross program invoked parsed instructions */\n  innerInstructions?: ParsedInnerInstruction[] | null;\n  /** The balances of the transaction accounts before processing */\n  preBalances: Array<number>;\n  /** The balances of the transaction accounts after processing */\n  postBalances: Array<number>;\n  /** An array of program log messages emitted during a transaction */\n  logMessages?: Array<string> | null;\n  /** The token balances of the transaction accounts before processing */\n  preTokenBalances?: Array<TokenBalance> | null;\n  /** The token balances of the transaction accounts after processing */\n  postTokenBalances?: Array<TokenBalance> | null;\n  /** The error result of transaction processing */\n  err: TransactionError | null;\n  /** The collection of addresses loaded using address lookup tables */\n  loadedAddresses?: LoadedAddresses;\n  /** The compute units consumed after processing the transaction */\n  computeUnitsConsumed?: number;\n};\n\nexport type CompiledInnerInstruction = {\n  index: number;\n  instructions: CompiledInstruction[];\n};\n\n/**\n * Metadata for a confirmed transaction on the ledger\n */\nexport type ConfirmedTransactionMeta = {\n  /** The fee charged for processing the transaction */\n  fee: number;\n  /** An array of cross program invoked instructions */\n  innerInstructions?: CompiledInnerInstruction[] | null;\n  /** The balances of the transaction accounts before processing */\n  preBalances: Array<number>;\n  /** The balances of the transaction accounts after processing */\n  postBalances: Array<number>;\n  /** An array of program log messages emitted during a transaction */\n  logMessages?: Array<string> | null;\n  /** The token balances of the transaction accounts before processing */\n  preTokenBalances?: Array<TokenBalance> | null;\n  /** The token balances of the transaction accounts after processing */\n  postTokenBalances?: Array<TokenBalance> | null;\n  /** The error result of transaction processing */\n  err: TransactionError | null;\n  /** The collection of addresses loaded using address lookup tables */\n  loadedAddresses?: LoadedAddresses;\n  /** The compute units consumed after processing the transaction */\n  computeUnitsConsumed?: number;\n};\n\n/**\n * A processed transaction from the RPC API\n */\nexport type TransactionResponse = {\n  /** The slot during which the transaction was processed */\n  slot: number;\n  /** The transaction */\n  transaction: {\n    /** The transaction message */\n    message: Message;\n    /** The transaction signatures */\n    signatures: string[];\n  };\n  /** Metadata produced from the transaction */\n  meta: ConfirmedTransactionMeta | null;\n  /** The unix timestamp of when the transaction was processed */\n  blockTime?: number | null;\n};\n\n/**\n * A processed transaction from the RPC API\n */\nexport type VersionedTransactionResponse = {\n  /** The slot during which the transaction was processed */\n  slot: number;\n  /** The transaction */\n  transaction: {\n    /** The transaction message */\n    message: VersionedMessage;\n    /** The transaction signatures */\n    signatures: string[];\n  };\n  /** Metadata produced from the transaction */\n  meta: ConfirmedTransactionMeta | null;\n  /** The unix timestamp of when the transaction was processed */\n  blockTime?: number | null;\n  /** The transaction version */\n  version?: TransactionVersion;\n};\n\n/**\n * A processed transaction message from the RPC API\n */\ntype MessageResponse = {\n  accountKeys: string[];\n  header: MessageHeader;\n  instructions: CompiledInstruction[];\n  recentBlockhash: string;\n  addressTableLookups?: ParsedAddressTableLookup[];\n};\n\n/**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */\nexport type ConfirmedTransaction = {\n  /** The slot during which the transaction was processed */\n  slot: number;\n  /** The details of the transaction */\n  transaction: Transaction;\n  /** Metadata produced from the transaction */\n  meta: ConfirmedTransactionMeta | null;\n  /** The unix timestamp of when the transaction was processed */\n  blockTime?: number | null;\n};\n\n/**\n * A partially decoded transaction instruction\n */\nexport type PartiallyDecodedInstruction = {\n  /** Program id called by this instruction */\n  programId: PublicKey;\n  /** Public keys of accounts passed to this instruction */\n  accounts: Array<PublicKey>;\n  /** Raw base-58 instruction data */\n  data: string;\n};\n\n/**\n * A parsed transaction message account\n */\nexport type ParsedMessageAccount = {\n  /** Public key of the account */\n  pubkey: PublicKey;\n  /** Indicates if the account signed the transaction */\n  signer: boolean;\n  /** Indicates if the account is writable for this transaction */\n  writable: boolean;\n  /** Indicates if the account key came from the transaction or a lookup table */\n  source?: 'transaction' | 'lookupTable';\n};\n\n/**\n * A parsed transaction instruction\n */\nexport type ParsedInstruction = {\n  /** Name of the program for this instruction */\n  program: string;\n  /** ID of the program for this instruction */\n  programId: PublicKey;\n  /** Parsed instruction info */\n  parsed: any;\n};\n\n/**\n * A parsed address table lookup\n */\nexport type ParsedAddressTableLookup = {\n  /** Address lookup table account key */\n  accountKey: PublicKey;\n  /** Parsed instruction info */\n  writableIndexes: number[];\n  /** Parsed instruction info */\n  readonlyIndexes: number[];\n};\n\n/**\n * A parsed transaction message\n */\nexport type ParsedMessage = {\n  /** Accounts used in the instructions */\n  accountKeys: ParsedMessageAccount[];\n  /** The atomically executed instructions for the transaction */\n  instructions: (ParsedInstruction | PartiallyDecodedInstruction)[];\n  /** Recent blockhash */\n  recentBlockhash: string;\n  /** Address table lookups used to load additional accounts */\n  addressTableLookups?: ParsedAddressTableLookup[] | null;\n};\n\n/**\n * A parsed transaction\n */\nexport type ParsedTransaction = {\n  /** Signatures for the transaction */\n  signatures: Array<string>;\n  /** Message of the transaction */\n  message: ParsedMessage;\n};\n\n/**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */\nexport type ParsedConfirmedTransaction = ParsedTransactionWithMeta;\n\n/**\n * A parsed transaction on the ledger with meta\n */\nexport type ParsedTransactionWithMeta = {\n  /** The slot during which the transaction was processed */\n  slot: number;\n  /** The details of the transaction */\n  transaction: ParsedTransaction;\n  /** Metadata produced from the transaction */\n  meta: ParsedTransactionMeta | null;\n  /** The unix timestamp of when the transaction was processed */\n  blockTime?: number | null;\n  /** The version of the transaction message */\n  version?: TransactionVersion;\n};\n\n/**\n * A processed block fetched from the RPC API\n */\nexport type BlockResponse = {\n  /** Blockhash of this block */\n  blockhash: Blockhash;\n  /** Blockhash of this block's parent */\n  previousBlockhash: Blockhash;\n  /** Slot index of this block's parent */\n  parentSlot: number;\n  /** Vector of transactions with status meta and original message */\n  transactions: Array<{\n    /** The transaction */\n    transaction: {\n      /** The transaction message */\n      message: Message;\n      /** The transaction signatures */\n      signatures: string[];\n    };\n    /** Metadata produced from the transaction */\n    meta: ConfirmedTransactionMeta | null;\n    /** The transaction version */\n    version?: TransactionVersion;\n  }>;\n  /** Vector of block rewards */\n  rewards?: Array<{\n    /** Public key of reward recipient */\n    pubkey: string;\n    /** Reward value in lamports */\n    lamports: number;\n    /** Account balance after reward is applied */\n    postBalance: number | null;\n    /** Type of reward received */\n    rewardType: string | null;\n    /** Vote account commission when the reward was credited, only present for voting and staking rewards */\n    commission?: number | null;\n  }>;\n  /** The unix timestamp of when the block was processed */\n  blockTime: number | null;\n};\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */\nexport type AccountsModeBlockResponse = VersionedAccountsModeBlockResponse;\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */\nexport type NoneModeBlockResponse = VersionedNoneModeBlockResponse;\n\n/**\n * A block with parsed transactions\n */\nexport type ParsedBlockResponse = {\n  /** Blockhash of this block */\n  blockhash: Blockhash;\n  /** Blockhash of this block's parent */\n  previousBlockhash: Blockhash;\n  /** Slot index of this block's parent */\n  parentSlot: number;\n  /** Vector of transactions with status meta and original message */\n  transactions: Array<{\n    /** The details of the transaction */\n    transaction: ParsedTransaction;\n    /** Metadata produced from the transaction */\n    meta: ParsedTransactionMeta | null;\n    /** The transaction version */\n    version?: TransactionVersion;\n  }>;\n  /** Vector of block rewards */\n  rewards?: Array<{\n    /** Public key of reward recipient */\n    pubkey: string;\n    /** Reward value in lamports */\n    lamports: number;\n    /** Account balance after reward is applied */\n    postBalance: number | null;\n    /** Type of reward received */\n    rewardType: string | null;\n    /** Vote account commission when the reward was credited, only present for voting and staking rewards */\n    commission?: number | null;\n  }>;\n  /** The unix timestamp of when the block was processed */\n  blockTime: number | null;\n  /** The number of blocks beneath this block */\n  blockHeight: number | null;\n};\n\n/**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */\nexport type ParsedAccountsModeBlockResponse = Omit<\n  ParsedBlockResponse,\n  'transactions'\n> & {\n  transactions: Array<\n    Omit<ParsedBlockResponse['transactions'][number], 'transaction'> & {\n      transaction: Pick<\n        ParsedBlockResponse['transactions'][number]['transaction'],\n        'signatures'\n      > & {\n        accountKeys: ParsedMessageAccount[];\n      };\n    }\n  >;\n};\n\n/**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */\nexport type ParsedNoneModeBlockResponse = Omit<\n  ParsedBlockResponse,\n  'transactions'\n>;\n\n/**\n * A processed block fetched from the RPC API\n */\nexport type VersionedBlockResponse = {\n  /** Blockhash of this block */\n  blockhash: Blockhash;\n  /** Blockhash of this block's parent */\n  previousBlockhash: Blockhash;\n  /** Slot index of this block's parent */\n  parentSlot: number;\n  /** Vector of transactions with status meta and original message */\n  transactions: Array<{\n    /** The transaction */\n    transaction: {\n      /** The transaction message */\n      message: VersionedMessage;\n      /** The transaction signatures */\n      signatures: string[];\n    };\n    /** Metadata produced from the transaction */\n    meta: ConfirmedTransactionMeta | null;\n    /** The transaction version */\n    version?: TransactionVersion;\n  }>;\n  /** Vector of block rewards */\n  rewards?: Array<{\n    /** Public key of reward recipient */\n    pubkey: string;\n    /** Reward value in lamports */\n    lamports: number;\n    /** Account balance after reward is applied */\n    postBalance: number | null;\n    /** Type of reward received */\n    rewardType: string | null;\n    /** Vote account commission when the reward was credited, only present for voting and staking rewards */\n    commission?: number | null;\n  }>;\n  /** The unix timestamp of when the block was processed */\n  blockTime: number | null;\n};\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */\nexport type VersionedAccountsModeBlockResponse = Omit<\n  VersionedBlockResponse,\n  'transactions'\n> & {\n  transactions: Array<\n    Omit<VersionedBlockResponse['transactions'][number], 'transaction'> & {\n      transaction: Pick<\n        VersionedBlockResponse['transactions'][number]['transaction'],\n        'signatures'\n      > & {\n        accountKeys: ParsedMessageAccount[];\n      };\n    }\n  >;\n};\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */\nexport type VersionedNoneModeBlockResponse = Omit<\n  VersionedBlockResponse,\n  'transactions'\n>;\n\n/**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */\nexport type ConfirmedBlock = {\n  /** Blockhash of this block */\n  blockhash: Blockhash;\n  /** Blockhash of this block's parent */\n  previousBlockhash: Blockhash;\n  /** Slot index of this block's parent */\n  parentSlot: number;\n  /** Vector of transactions and status metas */\n  transactions: Array<{\n    transaction: Transaction;\n    meta: ConfirmedTransactionMeta | null;\n  }>;\n  /** Vector of block rewards */\n  rewards?: Array<{\n    pubkey: string;\n    lamports: number;\n    postBalance: number | null;\n    rewardType: string | null;\n    commission?: number | null;\n  }>;\n  /** The unix timestamp of when the block was processed */\n  blockTime: number | null;\n};\n\n/**\n * A Block on the ledger with signatures only\n */\nexport type BlockSignatures = {\n  /** Blockhash of this block */\n  blockhash: Blockhash;\n  /** Blockhash of this block's parent */\n  previousBlockhash: Blockhash;\n  /** Slot index of this block's parent */\n  parentSlot: number;\n  /** Vector of signatures */\n  signatures: Array<string>;\n  /** The unix timestamp of when the block was processed */\n  blockTime: number | null;\n};\n\n/**\n * recent block production information\n */\nexport type BlockProduction = Readonly<{\n  /** a dictionary of validator identities, as base-58 encoded strings. Value is a two element array containing the number of leader slots and the number of blocks produced */\n  byIdentity: Readonly<Record<string, ReadonlyArray<number>>>;\n  /** Block production slot range */\n  range: Readonly<{\n    /** first slot of the block production information (inclusive) */\n    firstSlot: number;\n    /** last slot of block production information (inclusive) */\n    lastSlot: number;\n  }>;\n}>;\n\nexport type GetBlockProductionConfig = {\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /** Slot range to return block production for. If parameter not provided, defaults to current epoch. */\n  range?: {\n    /** first slot to return block production information for (inclusive) */\n    firstSlot: number;\n    /** last slot to return block production information for (inclusive). If parameter not provided, defaults to the highest slot */\n    lastSlot?: number;\n  };\n  /** Only return results for this validator identity (base-58 encoded) */\n  identity?: string;\n};\n\n/**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */\nconst BlockProductionResponseStruct = jsonRpcResultAndContext(\n  pick({\n    byIdentity: record(string(), array(number())),\n    range: pick({\n      firstSlot: number(),\n      lastSlot: number(),\n    }),\n  }),\n);\n\n/**\n * A performance sample\n */\nexport type PerfSample = {\n  /** Slot number of sample */\n  slot: number;\n  /** Number of transactions in a sample window */\n  numTransactions: number;\n  /** Number of slots in a sample window */\n  numSlots: number;\n  /** Sample window in seconds */\n  samplePeriodSecs: number;\n};\n\nfunction createRpcClient(\n  url: string,\n  httpHeaders?: HttpHeaders,\n  customFetch?: FetchFn,\n  fetchMiddleware?: FetchMiddleware,\n  disableRetryOnRateLimit?: boolean,\n  httpAgent?: NodeHttpAgent | NodeHttpsAgent | false,\n): RpcClient {\n  const fetch = customFetch ? customFetch : fetchImpl;\n  let agent: NodeHttpAgent | NodeHttpsAgent | undefined;\n  if (process.env.BROWSER) {\n    if (httpAgent != null) {\n      console.warn(\n        'You have supplied an `httpAgent` when creating a `Connection` in a browser environment.' +\n          'It has been ignored; `httpAgent` is only used in Node environments.',\n      );\n    }\n  } else {\n    if (httpAgent == null) {\n      if (process.env.NODE_ENV !== 'test') {\n        const agentOptions = {\n          // One second fewer than the Solana RPC's keepalive timeout.\n          // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n          freeSocketTimeout: 19000,\n          keepAlive: true,\n          maxSockets: 25,\n        };\n        if (url.startsWith('https:')) {\n          agent = new HttpsKeepAliveAgent(agentOptions);\n        } else {\n          agent = new HttpKeepAliveAgent(agentOptions);\n        }\n      }\n    } else {\n      if (httpAgent !== false) {\n        const isHttps = url.startsWith('https:');\n        if (isHttps && !(httpAgent instanceof NodeHttpsAgent)) {\n          throw new Error(\n            'The endpoint `' +\n              url +\n              '` can only be paired with an `https.Agent`. You have, instead, supplied an ' +\n              '`http.Agent` through `httpAgent`.',\n          );\n        } else if (!isHttps && httpAgent instanceof NodeHttpsAgent) {\n          throw new Error(\n            'The endpoint `' +\n              url +\n              '` can only be paired with an `http.Agent`. You have, instead, supplied an ' +\n              '`https.Agent` through `httpAgent`.',\n          );\n        }\n        agent = httpAgent;\n      }\n    }\n  }\n\n  let fetchWithMiddleware: FetchFn | undefined;\n\n  if (fetchMiddleware) {\n    fetchWithMiddleware = async (info, init) => {\n      const modifiedFetchArgs = await new Promise<Parameters<FetchFn>>(\n        (resolve, reject) => {\n          try {\n            fetchMiddleware(info, init, (modifiedInfo, modifiedInit) =>\n              resolve([modifiedInfo, modifiedInit]),\n            );\n          } catch (error) {\n            reject(error);\n          }\n        },\n      );\n      return await fetch(...modifiedFetchArgs);\n    };\n  }\n\n  const clientBrowser = new RpcClient(async (request, callback) => {\n    const options = {\n      method: 'POST',\n      body: request,\n      agent,\n      headers: Object.assign(\n        {\n          'Content-Type': 'application/json',\n        },\n        httpHeaders || {},\n        COMMON_HTTP_HEADERS,\n      ),\n    };\n\n    try {\n      let too_many_requests_retries = 5;\n      let res: Response;\n      let waitTime = 500;\n      for (;;) {\n        if (fetchWithMiddleware) {\n          res = await fetchWithMiddleware(url, options);\n        } else {\n          res = await fetch(url, options);\n        }\n\n        if (res.status !== 429 /* Too many requests */) {\n          break;\n        }\n        if (disableRetryOnRateLimit === true) {\n          break;\n        }\n        too_many_requests_retries -= 1;\n        if (too_many_requests_retries === 0) {\n          break;\n        }\n        console.error(\n          `Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`,\n        );\n        await sleep(waitTime);\n        waitTime *= 2;\n      }\n\n      const text = await res.text();\n      if (res.ok) {\n        callback(null, text);\n      } else {\n        callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n      }\n    } catch (err) {\n      if (err instanceof Error) callback(err);\n    }\n  }, {});\n\n  return clientBrowser;\n}\n\nfunction createRpcRequest(client: RpcClient): RpcRequest {\n  return (method, args) => {\n    return new Promise((resolve, reject) => {\n      client.request(method, args, (err: any, response: any) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\n\nfunction createRpcBatchRequest(client: RpcClient): RpcBatchRequest {\n  return (requests: RpcParams[]) => {\n    return new Promise((resolve, reject) => {\n      // Do nothing if requests is empty\n      if (requests.length === 0) resolve([]);\n\n      const batch = requests.map((params: RpcParams) => {\n        return client.request(params.methodName, params.args);\n      });\n\n      client.request(batch, (err: any, response: any) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\n\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */\nconst GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */\nconst GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */\nconst GetRecentPrioritizationFeesRpcResult = jsonRpcResult(\n  GetRecentPrioritizationFeesResult,\n);\n\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */\nconst GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */\nconst GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */\nconst GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */\nconst SlotRpcResult = jsonRpcResult(number());\n\n/**\n * Supply\n */\nexport type Supply = {\n  /** Total supply in lamports */\n  total: number;\n  /** Circulating supply in lamports */\n  circulating: number;\n  /** Non-circulating supply in lamports */\n  nonCirculating: number;\n  /** List of non-circulating account addresses */\n  nonCirculatingAccounts: Array<PublicKey>;\n};\n\n/**\n * Expected JSON RPC response for the \"getSupply\" message\n */\nconst GetSupplyRpcResult = jsonRpcResultAndContext(\n  pick({\n    total: number(),\n    circulating: number(),\n    nonCirculating: number(),\n    nonCirculatingAccounts: array(PublicKeyFromString),\n  }),\n);\n\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */\nexport type TokenAmount = {\n  /** Raw amount of tokens as string ignoring decimals */\n  amount: string;\n  /** Number of decimals configured for token's mint */\n  decimals: number;\n  /** Token amount as float, accounts for decimals */\n  uiAmount: number | null;\n  /** Token amount as string, accounts for decimals */\n  uiAmountString?: string;\n};\n\n/**\n * Expected JSON RPC structure for token amounts\n */\nconst TokenAmountResult = pick({\n  amount: string(),\n  uiAmount: nullable(number()),\n  decimals: number(),\n  uiAmountString: optional(string()),\n});\n\n/**\n * Token address and balance.\n */\nexport type TokenAccountBalancePair = {\n  /** Address of the token account */\n  address: PublicKey;\n  /** Raw amount of tokens as string ignoring decimals */\n  amount: string;\n  /** Number of decimals configured for token's mint */\n  decimals: number;\n  /** Token amount as float, accounts for decimals */\n  uiAmount: number | null;\n  /** Token amount as string, accounts for decimals */\n  uiAmountString?: string;\n};\n\n/**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */\nconst GetTokenLargestAccountsResult = jsonRpcResultAndContext(\n  array(\n    pick({\n      address: PublicKeyFromString,\n      amount: string(),\n      uiAmount: nullable(number()),\n      decimals: number(),\n      uiAmountString: optional(string()),\n    }),\n  ),\n);\n\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */\nconst GetTokenAccountsByOwner = jsonRpcResultAndContext(\n  array(\n    pick({\n      pubkey: PublicKeyFromString,\n      account: pick({\n        executable: boolean(),\n        owner: PublicKeyFromString,\n        lamports: number(),\n        data: BufferFromRawAccountData,\n        rentEpoch: number(),\n      }),\n    }),\n  ),\n);\n\nconst ParsedAccountDataResult = pick({\n  program: string(),\n  parsed: unknown(),\n  space: number(),\n});\n\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */\nconst GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(\n  array(\n    pick({\n      pubkey: PublicKeyFromString,\n      account: pick({\n        executable: boolean(),\n        owner: PublicKeyFromString,\n        lamports: number(),\n        data: ParsedAccountDataResult,\n        rentEpoch: number(),\n      }),\n    }),\n  ),\n);\n\n/**\n * Pair of an account address and its balance\n */\nexport type AccountBalancePair = {\n  address: PublicKey;\n  lamports: number;\n};\n\n/**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */\nconst GetLargestAccountsRpcResult = jsonRpcResultAndContext(\n  array(\n    pick({\n      lamports: number(),\n      address: PublicKeyFromString,\n    }),\n  ),\n);\n\n/**\n * @internal\n */\nconst AccountInfoResult = pick({\n  executable: boolean(),\n  owner: PublicKeyFromString,\n  lamports: number(),\n  data: BufferFromRawAccountData,\n  rentEpoch: number(),\n});\n\n/**\n * @internal\n */\nconst KeyedAccountInfoResult = pick({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult,\n});\n\nconst ParsedOrRawAccountData = coerce(\n  union([instance(Buffer), ParsedAccountDataResult]),\n  union([RawAccountDataResult, ParsedAccountDataResult]),\n  value => {\n    if (Array.isArray(value)) {\n      return create(value, BufferFromRawAccountData);\n    } else {\n      return value;\n    }\n  },\n);\n\n/**\n * @internal\n */\nconst ParsedAccountInfoResult = pick({\n  executable: boolean(),\n  owner: PublicKeyFromString,\n  lamports: number(),\n  data: ParsedOrRawAccountData,\n  rentEpoch: number(),\n});\n\nconst KeyedParsedAccountInfoResult = pick({\n  pubkey: PublicKeyFromString,\n  account: ParsedAccountInfoResult,\n});\n\n/**\n * @internal\n */\nconst StakeActivationResult = pick({\n  state: union([\n    literal('active'),\n    literal('inactive'),\n    literal('activating'),\n    literal('deactivating'),\n  ]),\n  active: number(),\n  inactive: number(),\n});\n\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */\n\nconst GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(\n  array(\n    pick({\n      signature: string(),\n      slot: number(),\n      err: TransactionErrorResult,\n      memo: nullable(string()),\n      blockTime: optional(nullable(number())),\n    }),\n  ),\n);\n\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */\nconst GetSignaturesForAddressRpcResult = jsonRpcResult(\n  array(\n    pick({\n      signature: string(),\n      slot: number(),\n      err: TransactionErrorResult,\n      memo: nullable(string()),\n      blockTime: optional(nullable(number())),\n    }),\n  ),\n);\n\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */\nconst AccountNotificationResult = pick({\n  subscription: number(),\n  result: notificationResultAndContext(AccountInfoResult),\n});\n\n/**\n * @internal\n */\nconst ProgramAccountInfoResult = pick({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult,\n});\n\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */\nconst ProgramAccountNotificationResult = pick({\n  subscription: number(),\n  result: notificationResultAndContext(ProgramAccountInfoResult),\n});\n\n/**\n * @internal\n */\nconst SlotInfoResult = pick({\n  parent: number(),\n  slot: number(),\n  root: number(),\n});\n\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */\nconst SlotNotificationResult = pick({\n  subscription: number(),\n  result: SlotInfoResult,\n});\n\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */\nexport type SlotUpdate =\n  | {\n      type: 'firstShredReceived';\n      slot: number;\n      timestamp: number;\n    }\n  | {\n      type: 'completed';\n      slot: number;\n      timestamp: number;\n    }\n  | {\n      type: 'createdBank';\n      slot: number;\n      timestamp: number;\n      parent: number;\n    }\n  | {\n      type: 'frozen';\n      slot: number;\n      timestamp: number;\n      stats: {\n        numTransactionEntries: number;\n        numSuccessfulTransactions: number;\n        numFailedTransactions: number;\n        maxTransactionsPerEntry: number;\n      };\n    }\n  | {\n      type: 'dead';\n      slot: number;\n      timestamp: number;\n      err: string;\n    }\n  | {\n      type: 'optimisticConfirmation';\n      slot: number;\n      timestamp: number;\n    }\n  | {\n      type: 'root';\n      slot: number;\n      timestamp: number;\n    };\n\n/**\n * @internal\n */\nconst SlotUpdateResult = union([\n  pick({\n    type: union([\n      literal('firstShredReceived'),\n      literal('completed'),\n      literal('optimisticConfirmation'),\n      literal('root'),\n    ]),\n    slot: number(),\n    timestamp: number(),\n  }),\n  pick({\n    type: literal('createdBank'),\n    parent: number(),\n    slot: number(),\n    timestamp: number(),\n  }),\n  pick({\n    type: literal('frozen'),\n    slot: number(),\n    timestamp: number(),\n    stats: pick({\n      numTransactionEntries: number(),\n      numSuccessfulTransactions: number(),\n      numFailedTransactions: number(),\n      maxTransactionsPerEntry: number(),\n    }),\n  }),\n  pick({\n    type: literal('dead'),\n    slot: number(),\n    timestamp: number(),\n    err: string(),\n  }),\n]);\n\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */\nconst SlotUpdateNotificationResult = pick({\n  subscription: number(),\n  result: SlotUpdateResult,\n});\n\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */\nconst SignatureNotificationResult = pick({\n  subscription: number(),\n  result: notificationResultAndContext(\n    union([SignatureStatusResult, SignatureReceivedResult]),\n  ),\n});\n\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */\nconst RootNotificationResult = pick({\n  subscription: number(),\n  result: number(),\n});\n\nconst ContactInfoResult = pick({\n  pubkey: string(),\n  gossip: nullable(string()),\n  tpu: nullable(string()),\n  rpc: nullable(string()),\n  version: nullable(string()),\n});\n\nconst VoteAccountInfoResult = pick({\n  votePubkey: string(),\n  nodePubkey: string(),\n  activatedStake: number(),\n  epochVoteAccount: boolean(),\n  epochCredits: array(tuple([number(), number(), number()])),\n  commission: number(),\n  lastVote: number(),\n  rootSlot: nullable(number()),\n});\n\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */\nconst GetVoteAccounts = jsonRpcResult(\n  pick({\n    current: array(VoteAccountInfoResult),\n    delinquent: array(VoteAccountInfoResult),\n  }),\n);\n\nconst ConfirmationStatus = union([\n  literal('processed'),\n  literal('confirmed'),\n  literal('finalized'),\n]);\n\nconst SignatureStatusResponse = pick({\n  slot: number(),\n  confirmations: nullable(number()),\n  err: TransactionErrorResult,\n  confirmationStatus: optional(ConfirmationStatus),\n});\n\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */\nconst GetSignatureStatusesRpcResult = jsonRpcResultAndContext(\n  array(nullable(SignatureStatusResponse)),\n);\n\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */\nconst GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());\n\nconst AddressTableLookupStruct = pick({\n  accountKey: PublicKeyFromString,\n  writableIndexes: array(number()),\n  readonlyIndexes: array(number()),\n});\n\nconst ConfirmedTransactionResult = pick({\n  signatures: array(string()),\n  message: pick({\n    accountKeys: array(string()),\n    header: pick({\n      numRequiredSignatures: number(),\n      numReadonlySignedAccounts: number(),\n      numReadonlyUnsignedAccounts: number(),\n    }),\n    instructions: array(\n      pick({\n        accounts: array(number()),\n        data: string(),\n        programIdIndex: number(),\n      }),\n    ),\n    recentBlockhash: string(),\n    addressTableLookups: optional(array(AddressTableLookupStruct)),\n  }),\n});\n\nconst AnnotatedAccountKey = pick({\n  pubkey: PublicKeyFromString,\n  signer: boolean(),\n  writable: boolean(),\n  source: optional(union([literal('transaction'), literal('lookupTable')])),\n});\n\nconst ConfirmedTransactionAccountsModeResult = pick({\n  accountKeys: array(AnnotatedAccountKey),\n  signatures: array(string()),\n});\n\nconst ParsedInstructionResult = pick({\n  parsed: unknown(),\n  program: string(),\n  programId: PublicKeyFromString,\n});\n\nconst RawInstructionResult = pick({\n  accounts: array(PublicKeyFromString),\n  data: string(),\n  programId: PublicKeyFromString,\n});\n\nconst InstructionResult = union([\n  RawInstructionResult,\n  ParsedInstructionResult,\n]);\n\nconst UnknownInstructionResult = union([\n  pick({\n    parsed: unknown(),\n    program: string(),\n    programId: string(),\n  }),\n  pick({\n    accounts: array(string()),\n    data: string(),\n    programId: string(),\n  }),\n]);\n\nconst ParsedOrRawInstruction = coerce(\n  InstructionResult,\n  UnknownInstructionResult,\n  value => {\n    if ('accounts' in value) {\n      return create(value, RawInstructionResult);\n    } else {\n      return create(value, ParsedInstructionResult);\n    }\n  },\n);\n\n/**\n * @internal\n */\nconst ParsedConfirmedTransactionResult = pick({\n  signatures: array(string()),\n  message: pick({\n    accountKeys: array(AnnotatedAccountKey),\n    instructions: array(ParsedOrRawInstruction),\n    recentBlockhash: string(),\n    addressTableLookups: optional(nullable(array(AddressTableLookupStruct))),\n  }),\n});\n\nconst TokenBalanceResult = pick({\n  accountIndex: number(),\n  mint: string(),\n  owner: optional(string()),\n  programId: optional(string()),\n  uiTokenAmount: TokenAmountResult,\n});\n\nconst LoadedAddressesResult = pick({\n  writable: array(PublicKeyFromString),\n  readonly: array(PublicKeyFromString),\n});\n\n/**\n * @internal\n */\nconst ConfirmedTransactionMetaResult = pick({\n  err: TransactionErrorResult,\n  fee: number(),\n  innerInstructions: optional(\n    nullable(\n      array(\n        pick({\n          index: number(),\n          instructions: array(\n            pick({\n              accounts: array(number()),\n              data: string(),\n              programIdIndex: number(),\n            }),\n          ),\n        }),\n      ),\n    ),\n  ),\n  preBalances: array(number()),\n  postBalances: array(number()),\n  logMessages: optional(nullable(array(string()))),\n  preTokenBalances: optional(nullable(array(TokenBalanceResult))),\n  postTokenBalances: optional(nullable(array(TokenBalanceResult))),\n  loadedAddresses: optional(LoadedAddressesResult),\n  computeUnitsConsumed: optional(number()),\n});\n\n/**\n * @internal\n */\nconst ParsedConfirmedTransactionMetaResult = pick({\n  err: TransactionErrorResult,\n  fee: number(),\n  innerInstructions: optional(\n    nullable(\n      array(\n        pick({\n          index: number(),\n          instructions: array(ParsedOrRawInstruction),\n        }),\n      ),\n    ),\n  ),\n  preBalances: array(number()),\n  postBalances: array(number()),\n  logMessages: optional(nullable(array(string()))),\n  preTokenBalances: optional(nullable(array(TokenBalanceResult))),\n  postTokenBalances: optional(nullable(array(TokenBalanceResult))),\n  loadedAddresses: optional(LoadedAddressesResult),\n  computeUnitsConsumed: optional(number()),\n});\n\nconst TransactionVersionStruct = union([literal(0), literal('legacy')]);\n\n/** @internal */\nconst RewardsResult = pick({\n  pubkey: string(),\n  lamports: number(),\n  postBalance: nullable(number()),\n  rewardType: nullable(string()),\n  commission: optional(nullable(number())),\n});\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\nconst GetBlockRpcResult = jsonRpcResult(\n  nullable(\n    pick({\n      blockhash: string(),\n      previousBlockhash: string(),\n      parentSlot: number(),\n      transactions: array(\n        pick({\n          transaction: ConfirmedTransactionResult,\n          meta: nullable(ConfirmedTransactionMetaResult),\n          version: optional(TransactionVersionStruct),\n        }),\n      ),\n      rewards: optional(array(RewardsResult)),\n      blockTime: nullable(number()),\n      blockHeight: nullable(number()),\n    }),\n  ),\n);\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */\nconst GetNoneModeBlockRpcResult = jsonRpcResult(\n  nullable(\n    pick({\n      blockhash: string(),\n      previousBlockhash: string(),\n      parentSlot: number(),\n      rewards: optional(array(RewardsResult)),\n      blockTime: nullable(number()),\n      blockHeight: nullable(number()),\n    }),\n  ),\n);\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */\nconst GetAccountsModeBlockRpcResult = jsonRpcResult(\n  nullable(\n    pick({\n      blockhash: string(),\n      previousBlockhash: string(),\n      parentSlot: number(),\n      transactions: array(\n        pick({\n          transaction: ConfirmedTransactionAccountsModeResult,\n          meta: nullable(ConfirmedTransactionMetaResult),\n          version: optional(TransactionVersionStruct),\n        }),\n      ),\n      rewards: optional(array(RewardsResult)),\n      blockTime: nullable(number()),\n      blockHeight: nullable(number()),\n    }),\n  ),\n);\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */\nconst GetParsedBlockRpcResult = jsonRpcResult(\n  nullable(\n    pick({\n      blockhash: string(),\n      previousBlockhash: string(),\n      parentSlot: number(),\n      transactions: array(\n        pick({\n          transaction: ParsedConfirmedTransactionResult,\n          meta: nullable(ParsedConfirmedTransactionMetaResult),\n          version: optional(TransactionVersionStruct),\n        }),\n      ),\n      rewards: optional(array(RewardsResult)),\n      blockTime: nullable(number()),\n      blockHeight: nullable(number()),\n    }),\n  ),\n);\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */\nconst GetParsedAccountsModeBlockRpcResult = jsonRpcResult(\n  nullable(\n    pick({\n      blockhash: string(),\n      previousBlockhash: string(),\n      parentSlot: number(),\n      transactions: array(\n        pick({\n          transaction: ConfirmedTransactionAccountsModeResult,\n          meta: nullable(ParsedConfirmedTransactionMetaResult),\n          version: optional(TransactionVersionStruct),\n        }),\n      ),\n      rewards: optional(array(RewardsResult)),\n      blockTime: nullable(number()),\n      blockHeight: nullable(number()),\n    }),\n  ),\n);\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */\nconst GetParsedNoneModeBlockRpcResult = jsonRpcResult(\n  nullable(\n    pick({\n      blockhash: string(),\n      previousBlockhash: string(),\n      parentSlot: number(),\n      rewards: optional(array(RewardsResult)),\n      blockTime: nullable(number()),\n      blockHeight: nullable(number()),\n    }),\n  ),\n);\n\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */\nconst GetConfirmedBlockRpcResult = jsonRpcResult(\n  nullable(\n    pick({\n      blockhash: string(),\n      previousBlockhash: string(),\n      parentSlot: number(),\n      transactions: array(\n        pick({\n          transaction: ConfirmedTransactionResult,\n          meta: nullable(ConfirmedTransactionMetaResult),\n        }),\n      ),\n      rewards: optional(array(RewardsResult)),\n      blockTime: nullable(number()),\n    }),\n  ),\n);\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\nconst GetBlockSignaturesRpcResult = jsonRpcResult(\n  nullable(\n    pick({\n      blockhash: string(),\n      previousBlockhash: string(),\n      parentSlot: number(),\n      signatures: array(string()),\n      blockTime: nullable(number()),\n    }),\n  ),\n);\n\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */\nconst GetTransactionRpcResult = jsonRpcResult(\n  nullable(\n    pick({\n      slot: number(),\n      meta: nullable(ConfirmedTransactionMetaResult),\n      blockTime: optional(nullable(number())),\n      transaction: ConfirmedTransactionResult,\n      version: optional(TransactionVersionStruct),\n    }),\n  ),\n);\n\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */\nconst GetParsedTransactionRpcResult = jsonRpcResult(\n  nullable(\n    pick({\n      slot: number(),\n      transaction: ParsedConfirmedTransactionResult,\n      meta: nullable(ParsedConfirmedTransactionMetaResult),\n      blockTime: optional(nullable(number())),\n      version: optional(TransactionVersionStruct),\n    }),\n  ),\n);\n\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */\nconst GetLatestBlockhashRpcResult = jsonRpcResultAndContext(\n  pick({\n    blockhash: string(),\n    lastValidBlockHeight: number(),\n  }),\n);\n\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */\nconst IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());\n\nconst PerfSampleResult = pick({\n  slot: number(),\n  numTransactions: number(),\n  numSlots: number(),\n  samplePeriodSecs: number(),\n});\n\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */\nconst GetRecentPerformanceSamplesRpcResult = jsonRpcResult(\n  array(PerfSampleResult),\n);\n\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */\nconst GetFeeCalculatorRpcResult = jsonRpcResultAndContext(\n  nullable(\n    pick({\n      feeCalculator: pick({\n        lamportsPerSignature: number(),\n      }),\n    }),\n  ),\n);\n\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */\nconst RequestAirdropRpcResult = jsonRpcResult(string());\n\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */\nconst SendTransactionRpcResult = jsonRpcResult(string());\n\n/**\n * Information about the latest slot being processed by a node\n */\nexport type SlotInfo = {\n  /** Currently processing slot */\n  slot: number;\n  /** Parent of the current slot */\n  parent: number;\n  /** The root block of the current slot's fork */\n  root: number;\n};\n\n/**\n * Parsed account data\n */\nexport type ParsedAccountData = {\n  /** Name of the program that owns this account */\n  program: string;\n  /** Parsed account data */\n  parsed: any;\n  /** Space used by account data */\n  space: number;\n};\n\n/**\n * Stake Activation data\n */\nexport type StakeActivationData = {\n  /** the stake account's activation state */\n  state: 'active' | 'inactive' | 'activating' | 'deactivating';\n  /** stake active during the epoch */\n  active: number;\n  /** stake inactive during the epoch */\n  inactive: number;\n};\n\n/**\n * Data slice argument for getProgramAccounts\n */\nexport type DataSlice = {\n  /** offset of data slice */\n  offset: number;\n  /** length of data slice */\n  length: number;\n};\n\n/**\n * Memory comparison filter for getProgramAccounts\n */\nexport type MemcmpFilter = {\n  memcmp: {\n    /** offset into program account data to start comparison */\n    offset: number;\n  } & (\n    | {\n        encoding?: 'base58'; // Base-58 is the default when not supplied.\n        /** data to match, as base-58 encoded string and limited to less than 129 bytes */\n        bytes: string;\n      }\n    | {\n        encoding: 'base64';\n        /** data to match, as base-64 encoded string */\n        bytes: string;\n      }\n  );\n};\n\n/**\n * Data size comparison filter for getProgramAccounts\n */\nexport type DataSizeFilter = {\n  /** Size of data for program account data length comparison */\n  dataSize: number;\n};\n\n/**\n * A filter object for getProgramAccounts\n */\nexport type GetProgramAccountsFilter = MemcmpFilter | DataSizeFilter;\n\n/**\n * Configuration object for getProgramAccounts requests\n */\nexport type GetProgramAccountsConfig = {\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /** Optional encoding for account data (default base64)\n   * To use \"jsonParsed\" encoding, please refer to `getParsedProgramAccounts` in connection.ts\n   * */\n  encoding?: 'base64';\n  /** Optional data slice to limit the returned account data */\n  dataSlice?: DataSlice;\n  /** Optional array of filters to apply to accounts */\n  filters?: GetProgramAccountsFilter[];\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n  /** wrap the result in an RpcResponse JSON object */\n  withContext?: boolean;\n};\n\nexport type GetProgramAccountsResponse = readonly Readonly<{\n  account: AccountInfo<Buffer>;\n  /** the account Pubkey as base-58 encoded string */\n  pubkey: PublicKey;\n}>[];\n\n/**\n * Configuration object for getParsedProgramAccounts\n */\nexport type GetParsedProgramAccountsConfig = {\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /** Optional array of filters to apply to accounts */\n  filters?: GetProgramAccountsFilter[];\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for getMultipleAccounts\n */\nexport type GetMultipleAccountsConfig = {\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n  /** Optional data slice to limit the returned account data */\n  dataSlice?: DataSlice;\n};\n\n/**\n * Configuration object for `getStakeActivation`\n */\nexport type GetStakeActivationConfig = {\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /** Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch */\n  epoch?: number;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for `getStakeActivation`\n */\nexport type GetTokenAccountsByOwnerConfig = {\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for `getStakeActivation`\n */\nexport type GetTransactionCountConfig = {\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for `getNonce`\n */\nexport type GetNonceConfig = {\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\n/**\n * Configuration object for `getNonceAndContext`\n */\nexport type GetNonceAndContextConfig = {\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /** The minimum slot that the request can be evaluated at */\n  minContextSlot?: number;\n};\n\nexport type AccountSubscriptionConfig = Readonly<{\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /**\n   * Encoding format for Account data\n   *   - `base58` is slow.\n   *   - `jsonParsed` encoding attempts to use program-specific state parsers to return more\n   *      human-readable and explicit account state data\n   *   - If `jsonParsed` is requested but a parser cannot be found, the field falls back to `base64`\n   *     encoding, detectable when the `data` field is type `string`.\n   */\n  encoding?: 'base58' | 'base64' | 'base64+zstd' | 'jsonParsed';\n}>;\n\nexport type ProgramAccountSubscriptionConfig = Readonly<{\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /**\n   * Encoding format for Account data\n   *   - `base58` is slow.\n   *   - `jsonParsed` encoding attempts to use program-specific state parsers to return more\n   *      human-readable and explicit account state data\n   *   - If `jsonParsed` is requested but a parser cannot be found, the field falls back to `base64`\n   *     encoding, detectable when the `data` field is type `string`.\n   */\n  encoding?: 'base58' | 'base64' | 'base64+zstd' | 'jsonParsed';\n  /**\n   * Filter results using various filter objects\n   * The resultant account must meet ALL filter criteria to be included in the returned results\n   */\n  filters?: GetProgramAccountsFilter[];\n}>;\n\n/**\n * Information describing an account\n */\nexport type AccountInfo<T> = {\n  /** `true` if this account's data contains a loaded program */\n  executable: boolean;\n  /** Identifier of the program that owns the account */\n  owner: PublicKey;\n  /** Number of lamports assigned to the account */\n  lamports: number;\n  /** Optional data assigned to the account */\n  data: T;\n  /** Optional rent epoch info for account */\n  rentEpoch?: number;\n};\n\n/**\n * Account information identified by pubkey\n */\nexport type KeyedAccountInfo = {\n  accountId: PublicKey;\n  accountInfo: AccountInfo<Buffer>;\n};\n\n/**\n * Callback function for account change notifications\n */\nexport type AccountChangeCallback = (\n  accountInfo: AccountInfo<Buffer>,\n  context: Context,\n) => void;\n\n/**\n * Callback function for program account change notifications\n */\nexport type ProgramAccountChangeCallback = (\n  keyedAccountInfo: KeyedAccountInfo,\n  context: Context,\n) => void;\n\n/**\n * Callback function for slot change notifications\n */\nexport type SlotChangeCallback = (slotInfo: SlotInfo) => void;\n\n/**\n * Callback function for slot update notifications\n */\nexport type SlotUpdateCallback = (slotUpdate: SlotUpdate) => void;\n\n/**\n * Callback function for signature status notifications\n */\nexport type SignatureResultCallback = (\n  signatureResult: SignatureResult,\n  context: Context,\n) => void;\n\n/**\n * Signature status notification with transaction result\n */\nexport type SignatureStatusNotification = {\n  type: 'status';\n  result: SignatureResult;\n};\n\n/**\n * Signature received notification\n */\nexport type SignatureReceivedNotification = {\n  type: 'received';\n};\n\n/**\n * Callback function for signature notifications\n */\nexport type SignatureSubscriptionCallback = (\n  notification: SignatureStatusNotification | SignatureReceivedNotification,\n  context: Context,\n) => void;\n\n/**\n * Signature subscription options\n */\nexport type SignatureSubscriptionOptions = {\n  commitment?: Commitment;\n  enableReceivedNotification?: boolean;\n};\n\n/**\n * Callback function for root change notifications\n */\nexport type RootChangeCallback = (root: number) => void;\n\n/**\n * @internal\n */\nconst LogsResult = pick({\n  err: TransactionErrorResult,\n  logs: array(string()),\n  signature: string(),\n});\n\n/**\n * Logs result.\n */\nexport type Logs = {\n  err: TransactionError | null;\n  logs: string[];\n  signature: string;\n};\n\n/**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */\nconst LogsNotificationResult = pick({\n  result: notificationResultAndContext(LogsResult),\n  subscription: number(),\n});\n\n/**\n * Filter for log subscriptions.\n */\nexport type LogsFilter = PublicKey | 'all' | 'allWithVotes';\n\n/**\n * Callback function for log notifications.\n */\nexport type LogsCallback = (logs: Logs, ctx: Context) => void;\n\n/**\n * Signature result\n */\nexport type SignatureResult = {\n  err: TransactionError | null;\n};\n\n/**\n * Transaction error\n */\nexport type TransactionError = {} | string;\n\n/**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */\nexport type TransactionConfirmationStatus =\n  | 'processed'\n  | 'confirmed'\n  | 'finalized';\n\n/**\n * Signature status\n */\nexport type SignatureStatus = {\n  /** when the transaction was processed */\n  slot: number;\n  /** the number of blocks that have been confirmed and voted on in the fork containing `slot` */\n  confirmations: number | null;\n  /** transaction error, if any */\n  err: TransactionError | null;\n  /** cluster confirmation status, if data available. Possible responses: `processed`, `confirmed`, `finalized` */\n  confirmationStatus?: TransactionConfirmationStatus;\n};\n\n/**\n * A confirmed signature with its status\n */\nexport type ConfirmedSignatureInfo = {\n  /** the transaction signature */\n  signature: string;\n  /** when the transaction was processed */\n  slot: number;\n  /** error, if any */\n  err: TransactionError | null;\n  /** memo associated with the transaction, if any */\n  memo: string | null;\n  /** The unix timestamp of when the transaction was processed */\n  blockTime?: number | null;\n  /** Cluster confirmation status, if available. Possible values: `processed`, `confirmed`, `finalized` */\n  confirmationStatus?: TransactionConfirmationStatus;\n};\n\n/**\n * An object defining headers to be passed to the RPC server\n */\nexport type HttpHeaders = {\n  [header: string]: string;\n} & {\n  // Prohibited headers; for internal use only.\n  'solana-client'?: never;\n};\n\n/**\n * The type of the JavaScript `fetch()` API\n */\nexport type FetchFn = typeof fetchImpl;\n\n/**\n * A callback used to augment the outgoing HTTP request\n */\nexport type FetchMiddleware = (\n  info: Parameters<FetchFn>[0],\n  init: Parameters<FetchFn>[1],\n  fetch: (...a: Parameters<FetchFn>) => void,\n) => void;\n\n/**\n * Configuration for instantiating a Connection\n */\nexport type ConnectionConfig = {\n  /**\n   * An `http.Agent` that will be used to manage socket connections (eg. to implement connection\n   * persistence). Set this to `false` to create a connection that uses no agent. This applies to\n   * Node environments only.\n   */\n  httpAgent?: NodeHttpAgent | NodeHttpsAgent | false;\n  /** Optional commitment level */\n  commitment?: Commitment;\n  /** Optional endpoint URL to the fullnode JSON RPC PubSub WebSocket Endpoint */\n  wsEndpoint?: string;\n  /** Optional HTTP headers object */\n  httpHeaders?: HttpHeaders;\n  /** Optional custom fetch function */\n  fetch?: FetchFn;\n  /** Optional fetch middleware callback */\n  fetchMiddleware?: FetchMiddleware;\n  /** Optional Disable retrying calls when server responds with HTTP 429 (Too Many Requests) */\n  disableRetryOnRateLimit?: boolean;\n  /** time to allow for the server to initially process a transaction (in milliseconds) */\n  confirmTransactionInitialTimeout?: number;\n};\n\n/** @internal */\nconst COMMON_HTTP_HEADERS = {\n  'solana-client': `js/${process.env.npm_package_version ?? 'UNKNOWN'}`,\n};\n\n/**\n * A connection to a fullnode JSON RPC endpoint\n */\nexport class Connection {\n  /** @internal */ _commitment?: Commitment;\n  /** @internal */ _confirmTransactionInitialTimeout?: number;\n  /** @internal */ _rpcEndpoint: string;\n  /** @internal */ _rpcWsEndpoint: string;\n  /** @internal */ _rpcClient: RpcClient;\n  /** @internal */ _rpcRequest: RpcRequest;\n  /** @internal */ _rpcBatchRequest: RpcBatchRequest;\n  /** @internal */ _rpcWebSocket: RpcWebSocketClient;\n  /** @internal */ _rpcWebSocketConnected: boolean = false;\n  /** @internal */ _rpcWebSocketHeartbeat: ReturnType<\n    typeof setInterval\n  > | null = null;\n  /** @internal */ _rpcWebSocketIdleTimeout: ReturnType<\n    typeof setTimeout\n  > | null = null;\n  /** @internal\n   * A number that we increment every time an active connection closes.\n   * Used to determine whether the same socket connection that was open\n   * when an async operation started is the same one that's active when\n   * its continuation fires.\n   *\n   */ private _rpcWebSocketGeneration: number = 0;\n\n  /** @internal */ _disableBlockhashCaching: boolean = false;\n  /** @internal */ _pollingBlockhash: boolean = false;\n  /** @internal */ _blockhashInfo: {\n    latestBlockhash: BlockhashWithExpiryBlockHeight | null;\n    lastFetch: number;\n    simulatedSignatures: Array<string>;\n    transactionSignatures: Array<string>;\n  } = {\n    latestBlockhash: null,\n    lastFetch: 0,\n    transactionSignatures: [],\n    simulatedSignatures: [],\n  };\n\n  /** @internal */ private _nextClientSubscriptionId: ClientSubscriptionId = 0;\n  /** @internal */ private _subscriptionDisposeFunctionsByClientSubscriptionId: {\n    [clientSubscriptionId: ClientSubscriptionId]:\n      | SubscriptionDisposeFn\n      | undefined;\n  } = {};\n  /** @internal */ private _subscriptionHashByClientSubscriptionId: {\n    [clientSubscriptionId: ClientSubscriptionId]:\n      | SubscriptionConfigHash\n      | undefined;\n  } = {};\n  /** @internal */ private _subscriptionStateChangeCallbacksByHash: {\n    [hash: SubscriptionConfigHash]:\n      | Set<SubscriptionStateChangeCallback>\n      | undefined;\n  } = {};\n  /** @internal */ private _subscriptionCallbacksByServerSubscriptionId: {\n    [serverSubscriptionId: ServerSubscriptionId]:\n      | Set<SubscriptionConfig['callback']>\n      | undefined;\n  } = {};\n  /** @internal */ private _subscriptionsByHash: {\n    [hash: SubscriptionConfigHash]: Subscription | undefined;\n  } = {};\n  /**\n   * Special case.\n   * After a signature is processed, RPCs automatically dispose of the\n   * subscription on the server side. We need to track which of these\n   * subscriptions have been disposed in such a way, so that we know\n   * whether the client is dealing with a not-yet-processed signature\n   * (in which case we must tear down the server subscription) or an\n   * already-processed signature (in which case the client can simply\n   * clear out the subscription locally without telling the server).\n   *\n   * NOTE: There is a proposal to eliminate this special case, here:\n   * https://github.com/solana-labs/solana/issues/18892\n   */\n  /** @internal */ private _subscriptionsAutoDisposedByRpc: Set<ServerSubscriptionId> =\n    new Set();\n\n  /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */\n  constructor(\n    endpoint: string,\n    commitmentOrConfig?: Commitment | ConnectionConfig,\n  ) {\n    let wsEndpoint;\n    let httpHeaders;\n    let fetch;\n    let fetchMiddleware;\n    let disableRetryOnRateLimit;\n    let httpAgent;\n    if (commitmentOrConfig && typeof commitmentOrConfig === 'string') {\n      this._commitment = commitmentOrConfig;\n    } else if (commitmentOrConfig) {\n      this._commitment = commitmentOrConfig.commitment;\n      this._confirmTransactionInitialTimeout =\n        commitmentOrConfig.confirmTransactionInitialTimeout;\n      wsEndpoint = commitmentOrConfig.wsEndpoint;\n      httpHeaders = commitmentOrConfig.httpHeaders;\n      fetch = commitmentOrConfig.fetch;\n      fetchMiddleware = commitmentOrConfig.fetchMiddleware;\n      disableRetryOnRateLimit = commitmentOrConfig.disableRetryOnRateLimit;\n      httpAgent = commitmentOrConfig.httpAgent;\n    }\n\n    this._rpcEndpoint = assertEndpointUrl(endpoint);\n    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n\n    this._rpcClient = createRpcClient(\n      endpoint,\n      httpHeaders,\n      fetch,\n      fetchMiddleware,\n      disableRetryOnRateLimit,\n      httpAgent,\n    );\n    this._rpcRequest = createRpcRequest(this._rpcClient);\n    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n\n    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n      autoconnect: false,\n      max_reconnects: Infinity,\n    });\n    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));\n    this._rpcWebSocket.on('error', this._wsOnError.bind(this));\n    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));\n    this._rpcWebSocket.on(\n      'accountNotification',\n      this._wsOnAccountNotification.bind(this),\n    );\n    this._rpcWebSocket.on(\n      'programNotification',\n      this._wsOnProgramAccountNotification.bind(this),\n    );\n    this._rpcWebSocket.on(\n      'slotNotification',\n      this._wsOnSlotNotification.bind(this),\n    );\n    this._rpcWebSocket.on(\n      'slotsUpdatesNotification',\n      this._wsOnSlotUpdatesNotification.bind(this),\n    );\n    this._rpcWebSocket.on(\n      'signatureNotification',\n      this._wsOnSignatureNotification.bind(this),\n    );\n    this._rpcWebSocket.on(\n      'rootNotification',\n      this._wsOnRootNotification.bind(this),\n    );\n    this._rpcWebSocket.on(\n      'logsNotification',\n      this._wsOnLogsNotification.bind(this),\n    );\n  }\n\n  /**\n   * The default commitment used for requests\n   */\n  get commitment(): Commitment | undefined {\n    return this._commitment;\n  }\n\n  /**\n   * The RPC endpoint\n   */\n  get rpcEndpoint(): string {\n    return this._rpcEndpoint;\n  }\n\n  /**\n   * Fetch the balance for the specified public key, return with context\n   */\n  async getBalanceAndContext(\n    publicKey: PublicKey,\n    commitmentOrConfig?: Commitment | GetBalanceConfig,\n  ): Promise<RpcResponseAndContext<number>> {\n    /** @internal */\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [publicKey.toBase58()],\n      commitment,\n      undefined /* encoding */,\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getBalance', args);\n    const res = create(unsafeRes, jsonRpcResultAndContext(number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get balance for ${publicKey.toBase58()}`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the balance for the specified public key\n   */\n  async getBalance(\n    publicKey: PublicKey,\n    commitmentOrConfig?: Commitment | GetBalanceConfig,\n  ): Promise<number> {\n    return await this.getBalanceAndContext(publicKey, commitmentOrConfig)\n      .then(x => x.value)\n      .catch(e => {\n        throw new Error(\n          'failed to get balance of account ' + publicKey.toBase58() + ': ' + e,\n        );\n      });\n  }\n\n  /**\n   * Fetch the estimated production time of a block\n   */\n  async getBlockTime(slot: number): Promise<number | null> {\n    const unsafeRes = await this._rpcRequest('getBlockTime', [slot]);\n    const res = create(unsafeRes, jsonRpcResult(nullable(number())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get block time for slot ${slot}`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */\n  async getMinimumLedgerSlot(): Promise<number> {\n    const unsafeRes = await this._rpcRequest('minimumLedgerSlot', []);\n    const res = create(unsafeRes, jsonRpcResult(number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to get minimum ledger slot',\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */\n  async getFirstAvailableBlock(): Promise<number> {\n    const unsafeRes = await this._rpcRequest('getFirstAvailableBlock', []);\n    const res = create(unsafeRes, SlotRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to get first available block',\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch information about the current supply\n   */\n  async getSupply(\n    config?: GetSupplyConfig | Commitment,\n  ): Promise<RpcResponseAndContext<Supply>> {\n    let configArg: GetSupplyConfig = {};\n    if (typeof config === 'string') {\n      configArg = {commitment: config};\n    } else if (config) {\n      configArg = {\n        ...config,\n        commitment: (config && config.commitment) || this.commitment,\n      };\n    } else {\n      configArg = {\n        commitment: this.commitment,\n      };\n    }\n\n    const unsafeRes = await this._rpcRequest('getSupply', [configArg]);\n    const res = create(unsafeRes, GetSupplyRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get supply');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current supply of a token mint\n   */\n  async getTokenSupply(\n    tokenMintAddress: PublicKey,\n    commitment?: Commitment,\n  ): Promise<RpcResponseAndContext<TokenAmount>> {\n    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenSupply', args);\n    const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get token supply');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current balance of a token account\n   */\n  async getTokenAccountBalance(\n    tokenAddress: PublicKey,\n    commitment?: Commitment,\n  ): Promise<RpcResponseAndContext<TokenAmount>> {\n    const args = this._buildArgs([tokenAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenAccountBalance', args);\n    const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to get token account balance',\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */\n  async getTokenAccountsByOwner(\n    ownerAddress: PublicKey,\n    filter: TokenAccountsFilter,\n    commitmentOrConfig?: Commitment | GetTokenAccountsByOwnerConfig,\n  ): Promise<RpcResponseAndContext<GetProgramAccountsResponse>> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    let _args: any[] = [ownerAddress.toBase58()];\n    if ('mint' in filter) {\n      _args.push({mint: filter.mint.toBase58()});\n    } else {\n      _args.push({programId: filter.programId.toBase58()});\n    }\n\n    const args = this._buildArgs(_args, commitment, 'base64', config);\n    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);\n    const res = create(unsafeRes, GetTokenAccountsByOwner);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get token accounts owned by account ${ownerAddress.toBase58()}`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */\n  async getParsedTokenAccountsByOwner(\n    ownerAddress: PublicKey,\n    filter: TokenAccountsFilter,\n    commitment?: Commitment,\n  ): Promise<\n    RpcResponseAndContext<\n      Array<{pubkey: PublicKey; account: AccountInfo<ParsedAccountData>}>\n    >\n  > {\n    let _args: any[] = [ownerAddress.toBase58()];\n    if ('mint' in filter) {\n      _args.push({mint: filter.mint.toBase58()});\n    } else {\n      _args.push({programId: filter.programId.toBase58()});\n    }\n\n    const args = this._buildArgs(_args, commitment, 'jsonParsed');\n    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);\n    const res = create(unsafeRes, GetParsedTokenAccountsByOwner);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get token accounts owned by account ${ownerAddress.toBase58()}`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the 20 largest accounts with their current balances\n   */\n  async getLargestAccounts(\n    config?: GetLargestAccountsConfig,\n  ): Promise<RpcResponseAndContext<Array<AccountBalancePair>>> {\n    const arg = {\n      ...config,\n      commitment: (config && config.commitment) || this.commitment,\n    };\n    const args = arg.filter || arg.commitment ? [arg] : [];\n    const unsafeRes = await this._rpcRequest('getLargestAccounts', args);\n    const res = create(unsafeRes, GetLargestAccountsRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get largest accounts');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */\n  async getTokenLargestAccounts(\n    mintAddress: PublicKey,\n    commitment?: Commitment,\n  ): Promise<RpcResponseAndContext<Array<TokenAccountBalancePair>>> {\n    const args = this._buildArgs([mintAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenLargestAccounts', args);\n    const res = create(unsafeRes, GetTokenLargestAccountsResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to get token largest accounts',\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for the specified public key, return with context\n   */\n  async getAccountInfoAndContext(\n    publicKey: PublicKey,\n    commitmentOrConfig?: Commitment | GetAccountInfoConfig,\n  ): Promise<RpcResponseAndContext<AccountInfo<Buffer> | null>> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [publicKey.toBase58()],\n      commitment,\n      'base64',\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getAccountInfo', args);\n    const res = create(\n      unsafeRes,\n      jsonRpcResultAndContext(nullable(AccountInfoResult)),\n    );\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get info about account ${publicKey.toBase58()}`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed account info for the specified public key\n   */\n  async getParsedAccountInfo(\n    publicKey: PublicKey,\n    commitmentOrConfig?: Commitment | GetAccountInfoConfig,\n  ): Promise<\n    RpcResponseAndContext<AccountInfo<Buffer | ParsedAccountData> | null>\n  > {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [publicKey.toBase58()],\n      commitment,\n      'jsonParsed',\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getAccountInfo', args);\n    const res = create(\n      unsafeRes,\n      jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)),\n    );\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get info about account ${publicKey.toBase58()}`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for the specified public key\n   */\n  async getAccountInfo(\n    publicKey: PublicKey,\n    commitmentOrConfig?: Commitment | GetAccountInfoConfig,\n  ): Promise<AccountInfo<Buffer> | null> {\n    try {\n      const res = await this.getAccountInfoAndContext(\n        publicKey,\n        commitmentOrConfig,\n      );\n      return res.value;\n    } catch (e) {\n      throw new Error(\n        'failed to get info about account ' + publicKey.toBase58() + ': ' + e,\n      );\n    }\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */\n  async getMultipleParsedAccounts(\n    publicKeys: PublicKey[],\n    rawConfig?: GetMultipleAccountsConfig,\n  ): Promise<\n    RpcResponseAndContext<(AccountInfo<Buffer | ParsedAccountData> | null)[]>\n  > {\n    const {commitment, config} = extractCommitmentFromConfig(rawConfig);\n    const keys = publicKeys.map(key => key.toBase58());\n    const args = this._buildArgs([keys], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);\n    const res = create(\n      unsafeRes,\n      jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))),\n    );\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get info for accounts ${keys}`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */\n  async getMultipleAccountsInfoAndContext(\n    publicKeys: PublicKey[],\n    commitmentOrConfig?: Commitment | GetMultipleAccountsConfig,\n  ): Promise<RpcResponseAndContext<(AccountInfo<Buffer> | null)[]>> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const keys = publicKeys.map(key => key.toBase58());\n    const args = this._buildArgs([keys], commitment, 'base64', config);\n    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);\n    const res = create(\n      unsafeRes,\n      jsonRpcResultAndContext(array(nullable(AccountInfoResult))),\n    );\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get info for accounts ${keys}`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */\n  async getMultipleAccountsInfo(\n    publicKeys: PublicKey[],\n    commitmentOrConfig?: Commitment | GetMultipleAccountsConfig,\n  ): Promise<(AccountInfo<Buffer> | null)[]> {\n    const res = await this.getMultipleAccountsInfoAndContext(\n      publicKeys,\n      commitmentOrConfig,\n    );\n    return res.value;\n  }\n\n  /**\n   * Returns epoch activation information for a stake account that has been delegated\n   *\n   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.\n   */\n  async getStakeActivation(\n    publicKey: PublicKey,\n    commitmentOrConfig?: Commitment | GetStakeActivationConfig,\n    epoch?: number,\n  ): Promise<StakeActivationData> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [publicKey.toBase58()],\n      commitment,\n      undefined /* encoding */,\n      {\n        ...config,\n        epoch: epoch != null ? epoch : config?.epoch,\n      },\n    );\n\n    const unsafeRes = await this._rpcRequest('getStakeActivation', args);\n    const res = create(unsafeRes, jsonRpcResult(StakeActivationResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get Stake Activation ${publicKey.toBase58()}`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */\n  async getProgramAccounts(\n    programId: PublicKey,\n    configOrCommitment: GetProgramAccountsConfig &\n      Readonly<{withContext: true}>,\n  ): Promise<RpcResponseAndContext<GetProgramAccountsResponse>>;\n  // eslint-disable-next-line no-dupe-class-members\n  async getProgramAccounts(\n    programId: PublicKey,\n    configOrCommitment?: GetProgramAccountsConfig | Commitment,\n  ): Promise<GetProgramAccountsResponse>;\n  // eslint-disable-next-line no-dupe-class-members\n  async getProgramAccounts(\n    programId: PublicKey,\n    configOrCommitment?: GetProgramAccountsConfig | Commitment,\n  ): Promise<\n    | GetProgramAccountsResponse\n    | RpcResponseAndContext<GetProgramAccountsResponse>\n  > {\n    const {commitment, config} =\n      extractCommitmentFromConfig(configOrCommitment);\n    const {encoding, ...configWithoutEncoding} = config || {};\n    const args = this._buildArgs(\n      [programId.toBase58()],\n      commitment,\n      encoding || 'base64',\n      {\n        ...configWithoutEncoding,\n        ...(configWithoutEncoding.filters\n          ? {\n              filters: applyDefaultMemcmpEncodingToFilters(\n                configWithoutEncoding.filters,\n              ),\n            }\n          : null),\n      },\n    );\n    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);\n    const baseSchema = array(KeyedAccountInfoResult);\n    const res =\n      configWithoutEncoding.withContext === true\n        ? create(unsafeRes, jsonRpcResultAndContext(baseSchema))\n        : create(unsafeRes, jsonRpcResult(baseSchema));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get accounts owned by program ${programId.toBase58()}`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */\n  async getParsedProgramAccounts(\n    programId: PublicKey,\n    configOrCommitment?: GetParsedProgramAccountsConfig | Commitment,\n  ): Promise<\n    Array<{\n      pubkey: PublicKey;\n      account: AccountInfo<Buffer | ParsedAccountData>;\n    }>\n  > {\n    const {commitment, config} =\n      extractCommitmentFromConfig(configOrCommitment);\n    const args = this._buildArgs(\n      [programId.toBase58()],\n      commitment,\n      'jsonParsed',\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);\n    const res = create(\n      unsafeRes,\n      jsonRpcResult(array(KeyedParsedAccountInfoResult)),\n    );\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get accounts owned by program ${programId.toBase58()}`,\n      );\n    }\n    return res.result;\n  }\n\n  confirmTransaction(\n    strategy: TransactionConfirmationStrategy,\n    commitment?: Commitment,\n  ): Promise<RpcResponseAndContext<SignatureResult>>;\n\n  /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */\n  // eslint-disable-next-line no-dupe-class-members\n  confirmTransaction(\n    strategy: TransactionSignature,\n    commitment?: Commitment,\n  ): Promise<RpcResponseAndContext<SignatureResult>>;\n\n  // eslint-disable-next-line no-dupe-class-members\n  async confirmTransaction(\n    strategy: TransactionConfirmationStrategy | TransactionSignature,\n    commitment?: Commitment,\n  ): Promise<RpcResponseAndContext<SignatureResult>> {\n    let rawSignature: string;\n\n    if (typeof strategy == 'string') {\n      rawSignature = strategy;\n    } else {\n      const config = strategy as TransactionConfirmationStrategy;\n\n      if (config.abortSignal?.aborted) {\n        return Promise.reject(config.abortSignal.reason);\n      }\n      rawSignature = config.signature;\n    }\n\n    let decodedSignature;\n\n    try {\n      decodedSignature = bs58.decode(rawSignature);\n    } catch (err) {\n      throw new Error('signature must be base58 encoded: ' + rawSignature);\n    }\n\n    assert(decodedSignature.length === 64, 'signature has invalid length');\n\n    if (typeof strategy === 'string') {\n      return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n        commitment: commitment || this.commitment,\n        signature: rawSignature,\n      });\n    } else if ('lastValidBlockHeight' in strategy) {\n      return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n        commitment: commitment || this.commitment,\n        strategy,\n      });\n    } else {\n      return await this.confirmTransactionUsingDurableNonceStrategy({\n        commitment: commitment || this.commitment,\n        strategy,\n      });\n    }\n  }\n\n  private getCancellationPromise(signal?: AbortSignal): Promise<never> {\n    return new Promise<never>((_, reject) => {\n      if (signal == null) {\n        return;\n      }\n      if (signal.aborted) {\n        reject(signal.reason);\n      } else {\n        signal.addEventListener('abort', () => {\n          reject(signal.reason);\n        });\n      }\n    });\n  }\n\n  private getTransactionConfirmationPromise({\n    commitment,\n    signature,\n  }: {\n    commitment?: Commitment;\n    signature: string;\n  }): {\n    abortConfirmation(): void;\n    confirmationPromise: Promise<{\n      __type: TransactionStatus.PROCESSED;\n      response: RpcResponseAndContext<SignatureResult>;\n    }>;\n  } {\n    let signatureSubscriptionId: number | undefined;\n    let disposeSignatureSubscriptionStateChangeObserver:\n      | SubscriptionStateChangeDisposeFn\n      | undefined;\n    let done = false;\n    const confirmationPromise = new Promise<{\n      __type: TransactionStatus.PROCESSED;\n      response: RpcResponseAndContext<SignatureResult>;\n    }>((resolve, reject) => {\n      try {\n        signatureSubscriptionId = this.onSignature(\n          signature,\n          (result: SignatureResult, context: Context) => {\n            signatureSubscriptionId = undefined;\n            const response = {\n              context,\n              value: result,\n            };\n            resolve({__type: TransactionStatus.PROCESSED, response});\n          },\n          commitment,\n        );\n        const subscriptionSetupPromise = new Promise<void>(\n          resolveSubscriptionSetup => {\n            if (signatureSubscriptionId == null) {\n              resolveSubscriptionSetup();\n            } else {\n              disposeSignatureSubscriptionStateChangeObserver =\n                this._onSubscriptionStateChange(\n                  signatureSubscriptionId,\n                  nextState => {\n                    if (nextState === 'subscribed') {\n                      resolveSubscriptionSetup();\n                    }\n                  },\n                );\n            }\n          },\n        );\n        (async () => {\n          await subscriptionSetupPromise;\n          if (done) return;\n          const response = await this.getSignatureStatus(signature);\n          if (done) return;\n          if (response == null) {\n            return;\n          }\n          const {context, value} = response;\n          if (value == null) {\n            return;\n          }\n          if (value?.err) {\n            reject(value.err);\n          } else {\n            switch (commitment) {\n              case 'confirmed':\n              case 'single':\n              case 'singleGossip': {\n                if (value.confirmationStatus === 'processed') {\n                  return;\n                }\n                break;\n              }\n              case 'finalized':\n              case 'max':\n              case 'root': {\n                if (\n                  value.confirmationStatus === 'processed' ||\n                  value.confirmationStatus === 'confirmed'\n                ) {\n                  return;\n                }\n                break;\n              }\n              // exhaust enums to ensure full coverage\n              case 'processed':\n              case 'recent':\n            }\n            done = true;\n            resolve({\n              __type: TransactionStatus.PROCESSED,\n              response: {\n                context,\n                value,\n              },\n            });\n          }\n        })();\n      } catch (err) {\n        reject(err);\n      }\n    });\n    const abortConfirmation = () => {\n      if (disposeSignatureSubscriptionStateChangeObserver) {\n        disposeSignatureSubscriptionStateChangeObserver();\n        disposeSignatureSubscriptionStateChangeObserver = undefined;\n      }\n      if (signatureSubscriptionId != null) {\n        this.removeSignatureListener(signatureSubscriptionId);\n        signatureSubscriptionId = undefined;\n      }\n    };\n    return {abortConfirmation, confirmationPromise};\n  }\n\n  private async confirmTransactionUsingBlockHeightExceedanceStrategy({\n    commitment,\n    strategy: {abortSignal, lastValidBlockHeight, signature},\n  }: {\n    commitment?: Commitment;\n    strategy: BlockheightBasedTransactionConfirmationStrategy;\n  }) {\n    let done: boolean = false;\n    const expiryPromise = new Promise<{\n      __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED;\n    }>(resolve => {\n      const checkBlockHeight = async () => {\n        try {\n          const blockHeight = await this.getBlockHeight(commitment);\n          return blockHeight;\n        } catch (_e) {\n          return -1;\n        }\n      };\n      (async () => {\n        let currentBlockHeight = await checkBlockHeight();\n        if (done) return;\n        while (currentBlockHeight <= lastValidBlockHeight) {\n          await sleep(1000);\n          if (done) return;\n          currentBlockHeight = await checkBlockHeight();\n          if (done) return;\n        }\n        resolve({__type: TransactionStatus.BLOCKHEIGHT_EXCEEDED});\n      })();\n    });\n    const {abortConfirmation, confirmationPromise} =\n      this.getTransactionConfirmationPromise({commitment, signature});\n    const cancellationPromise = this.getCancellationPromise(abortSignal);\n    let result: RpcResponseAndContext<SignatureResult>;\n    try {\n      const outcome = await Promise.race([\n        cancellationPromise,\n        confirmationPromise,\n        expiryPromise,\n      ]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        throw new TransactionExpiredBlockheightExceededError(signature);\n      }\n    } finally {\n      done = true;\n      abortConfirmation();\n    }\n    return result;\n  }\n\n  private async confirmTransactionUsingDurableNonceStrategy({\n    commitment,\n    strategy: {\n      abortSignal,\n      minContextSlot,\n      nonceAccountPubkey,\n      nonceValue,\n      signature,\n    },\n  }: {\n    commitment?: Commitment;\n    strategy: DurableNonceTransactionConfirmationStrategy;\n  }) {\n    let done: boolean = false;\n    const expiryPromise = new Promise<{\n      __type: TransactionStatus.NONCE_INVALID;\n      slotInWhichNonceDidAdvance: number | null;\n    }>(resolve => {\n      let currentNonceValue: string | undefined = nonceValue;\n      let lastCheckedSlot: number | null = null;\n      const getCurrentNonceValue = async () => {\n        try {\n          const {context, value: nonceAccount} = await this.getNonceAndContext(\n            nonceAccountPubkey,\n            {\n              commitment,\n              minContextSlot,\n            },\n          );\n          lastCheckedSlot = context.slot;\n          return nonceAccount?.nonce;\n        } catch (e) {\n          // If for whatever reason we can't reach/read the nonce\n          // account, just keep using the last-known value.\n          return currentNonceValue;\n        }\n      };\n      (async () => {\n        currentNonceValue = await getCurrentNonceValue();\n        if (done) return;\n        while (\n          true // eslint-disable-line no-constant-condition\n        ) {\n          if (nonceValue !== currentNonceValue) {\n            resolve({\n              __type: TransactionStatus.NONCE_INVALID,\n              slotInWhichNonceDidAdvance: lastCheckedSlot,\n            });\n            return;\n          }\n          await sleep(2000);\n          if (done) return;\n          currentNonceValue = await getCurrentNonceValue();\n          if (done) return;\n        }\n      })();\n    });\n    const {abortConfirmation, confirmationPromise} =\n      this.getTransactionConfirmationPromise({commitment, signature});\n    const cancellationPromise = this.getCancellationPromise(abortSignal);\n    let result: RpcResponseAndContext<SignatureResult>;\n    try {\n      const outcome = await Promise.race([\n        cancellationPromise,\n        confirmationPromise,\n        expiryPromise,\n      ]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        // Double check that the transaction is indeed unconfirmed.\n        let signatureStatus:\n          | RpcResponseAndContext<SignatureStatus | null>\n          | null\n          | undefined;\n        while (\n          true // eslint-disable-line no-constant-condition\n        ) {\n          const status = await this.getSignatureStatus(signature);\n          if (status == null) {\n            break;\n          }\n          if (\n            status.context.slot <\n            (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)\n          ) {\n            await sleep(400);\n            continue;\n          }\n          signatureStatus = status;\n          break;\n        }\n        if (signatureStatus?.value) {\n          const commitmentForStatus = commitment || 'finalized';\n          const {confirmationStatus} = signatureStatus.value;\n          switch (commitmentForStatus) {\n            case 'processed':\n            case 'recent':\n              if (\n                confirmationStatus !== 'processed' &&\n                confirmationStatus !== 'confirmed' &&\n                confirmationStatus !== 'finalized'\n              ) {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            case 'confirmed':\n            case 'single':\n            case 'singleGossip':\n              if (\n                confirmationStatus !== 'confirmed' &&\n                confirmationStatus !== 'finalized'\n              ) {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            case 'finalized':\n            case 'max':\n            case 'root':\n              if (confirmationStatus !== 'finalized') {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            default:\n              // Exhaustive switch.\n              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n              ((_: never) => {})(commitmentForStatus);\n          }\n          result = {\n            context: signatureStatus.context,\n            value: {err: signatureStatus.value.err},\n          };\n        } else {\n          throw new TransactionExpiredNonceInvalidError(signature);\n        }\n      }\n    } finally {\n      done = true;\n      abortConfirmation();\n    }\n    return result;\n  }\n\n  private async confirmTransactionUsingLegacyTimeoutStrategy({\n    commitment,\n    signature,\n  }: {\n    commitment?: Commitment;\n    signature: string;\n  }) {\n    let timeoutId;\n    const expiryPromise = new Promise<{\n      __type: TransactionStatus.TIMED_OUT;\n      timeoutMs: number;\n    }>(resolve => {\n      let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n      switch (commitment) {\n        case 'processed':\n        case 'recent':\n        case 'single':\n        case 'confirmed':\n        case 'singleGossip': {\n          timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n          break;\n        }\n        // exhaust enums to ensure full coverage\n        case 'finalized':\n        case 'max':\n        case 'root':\n      }\n      timeoutId = setTimeout(\n        () => resolve({__type: TransactionStatus.TIMED_OUT, timeoutMs}),\n        timeoutMs,\n      );\n    });\n    const {abortConfirmation, confirmationPromise} =\n      this.getTransactionConfirmationPromise({\n        commitment,\n        signature,\n      });\n    let result: RpcResponseAndContext<SignatureResult>;\n    try {\n      const outcome = await Promise.race([confirmationPromise, expiryPromise]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        throw new TransactionExpiredTimeoutError(\n          signature,\n          outcome.timeoutMs / 1000,\n        );\n      }\n    } finally {\n      clearTimeout(timeoutId);\n      abortConfirmation();\n    }\n    return result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getClusterNodes(): Promise<Array<ContactInfo>> {\n    const unsafeRes = await this._rpcRequest('getClusterNodes', []);\n    const res = create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get cluster nodes');\n    }\n    return res.result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getVoteAccounts(commitment?: Commitment): Promise<VoteAccountStatus> {\n    const args = this._buildArgs([], commitment);\n    const unsafeRes = await this._rpcRequest('getVoteAccounts', args);\n    const res = create(unsafeRes, GetVoteAccounts);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get vote accounts');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot that the node is processing\n   */\n  async getSlot(\n    commitmentOrConfig?: Commitment | GetSlotConfig,\n  ): Promise<number> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [],\n      commitment,\n      undefined /* encoding */,\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getSlot', args);\n    const res = create(unsafeRes, jsonRpcResult(number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot leader of the cluster\n   */\n  async getSlotLeader(\n    commitmentOrConfig?: Commitment | GetSlotLeaderConfig,\n  ): Promise<string> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [],\n      commitment,\n      undefined /* encoding */,\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getSlotLeader', args);\n    const res = create(unsafeRes, jsonRpcResult(string()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot leader');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */\n  async getSlotLeaders(\n    startSlot: number,\n    limit: number,\n  ): Promise<Array<PublicKey>> {\n    const args = [startSlot, limit];\n    const unsafeRes = await this._rpcRequest('getSlotLeaders', args);\n    const res = create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot leaders');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current status of a signature\n   */\n  async getSignatureStatus(\n    signature: TransactionSignature,\n    config?: SignatureStatusConfig,\n  ): Promise<RpcResponseAndContext<SignatureStatus | null>> {\n    const {context, value: values} = await this.getSignatureStatuses(\n      [signature],\n      config,\n    );\n    assert(values.length === 1);\n    const value = values[0];\n    return {context, value};\n  }\n\n  /**\n   * Fetch the current statuses of a batch of signatures\n   */\n  async getSignatureStatuses(\n    signatures: Array<TransactionSignature>,\n    config?: SignatureStatusConfig,\n  ): Promise<RpcResponseAndContext<Array<SignatureStatus | null>>> {\n    const params: any[] = [signatures];\n    if (config) {\n      params.push(config);\n    }\n    const unsafeRes = await this._rpcRequest('getSignatureStatuses', params);\n    const res = create(unsafeRes, GetSignatureStatusesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get signature status');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current transaction count of the cluster\n   */\n  async getTransactionCount(\n    commitmentOrConfig?: Commitment | GetTransactionCountConfig,\n  ): Promise<number> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [],\n      commitment,\n      undefined /* encoding */,\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getTransactionCount', args);\n    const res = create(unsafeRes, jsonRpcResult(number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to get transaction count',\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.\n   */\n  async getTotalSupply(commitment?: Commitment): Promise<number> {\n    const result = await this.getSupply({\n      commitment,\n      excludeNonCirculatingAccountsList: true,\n    });\n    return result.value.total;\n  }\n\n  /**\n   * Fetch the cluster InflationGovernor parameters\n   */\n  async getInflationGovernor(\n    commitment?: Commitment,\n  ): Promise<InflationGovernor> {\n    const args = this._buildArgs([], commitment);\n    const unsafeRes = await this._rpcRequest('getInflationGovernor', args);\n    const res = create(unsafeRes, GetInflationGovernorRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */\n  async getInflationReward(\n    addresses: PublicKey[],\n    epoch?: number,\n    commitmentOrConfig?: Commitment | GetInflationRewardConfig,\n  ): Promise<(InflationReward | null)[]> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [addresses.map(pubkey => pubkey.toBase58())],\n      commitment,\n      undefined /* encoding */,\n      {\n        ...config,\n        epoch: epoch != null ? epoch : config?.epoch,\n      },\n    );\n    const unsafeRes = await this._rpcRequest('getInflationReward', args);\n    const res = create(unsafeRes, GetInflationRewardResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation reward');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the specific inflation values for the current epoch\n   */\n  async getInflationRate(): Promise<InflationRate> {\n    const unsafeRes = await this._rpcRequest('getInflationRate', []);\n    const res = create(unsafeRes, GetInflationRateRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation rate');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the Epoch Info parameters\n   */\n  async getEpochInfo(\n    commitmentOrConfig?: Commitment | GetEpochInfoConfig,\n  ): Promise<EpochInfo> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [],\n      commitment,\n      undefined /* encoding */,\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getEpochInfo', args);\n    const res = create(unsafeRes, GetEpochInfoRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get epoch info');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the Epoch Schedule parameters\n   */\n  async getEpochSchedule(): Promise<EpochSchedule> {\n    const unsafeRes = await this._rpcRequest('getEpochSchedule', []);\n    const res = create(unsafeRes, GetEpochScheduleRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get epoch schedule');\n    }\n    const epochSchedule = res.result;\n    return new EpochSchedule(\n      epochSchedule.slotsPerEpoch,\n      epochSchedule.leaderScheduleSlotOffset,\n      epochSchedule.warmup,\n      epochSchedule.firstNormalEpoch,\n      epochSchedule.firstNormalSlot,\n    );\n  }\n\n  /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */\n  async getLeaderSchedule(): Promise<LeaderSchedule> {\n    const unsafeRes = await this._rpcRequest('getLeaderSchedule', []);\n    const res = create(unsafeRes, GetLeaderScheduleRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get leader schedule');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */\n  async getMinimumBalanceForRentExemption(\n    dataLength: number,\n    commitment?: Commitment,\n  ): Promise<number> {\n    const args = this._buildArgs([dataLength], commitment);\n    const unsafeRes = await this._rpcRequest(\n      'getMinimumBalanceForRentExemption',\n      args,\n    );\n    const res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n    if ('error' in res) {\n      console.warn('Unable to fetch minimum balance for rent exemption');\n      return 0;\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.\n   */\n  async getRecentBlockhashAndContext(commitment?: Commitment): Promise<\n    RpcResponseAndContext<{\n      blockhash: Blockhash;\n      feeCalculator: FeeCalculator;\n    }>\n  > {\n    const {\n      context,\n      value: {blockhash},\n    } = await this.getLatestBlockhashAndContext(commitment);\n    const feeCalculator = {\n      get lamportsPerSignature(): number {\n        throw new Error(\n          'The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is ' +\n            'no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee ' +\n            'for a given message.',\n        );\n      },\n      toJSON() {\n        return {};\n      },\n    };\n    return {\n      context,\n      value: {\n        blockhash,\n        feeCalculator,\n      },\n    };\n  }\n\n  /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */\n  async getRecentPerformanceSamples(\n    limit?: number,\n  ): Promise<Array<PerfSample>> {\n    const unsafeRes = await this._rpcRequest(\n      'getRecentPerformanceSamples',\n      limit ? [limit] : [],\n    );\n    const res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to get recent performance samples',\n      );\n    }\n\n    return res.result;\n  }\n\n  /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.\n   */\n  async getFeeCalculatorForBlockhash(\n    blockhash: Blockhash,\n    commitment?: Commitment,\n  ): Promise<RpcResponseAndContext<FeeCalculator | null>> {\n    const args = this._buildArgs([blockhash], commitment);\n    const unsafeRes = await this._rpcRequest(\n      'getFeeCalculatorForBlockhash',\n      args,\n    );\n\n    const res = create(unsafeRes, GetFeeCalculatorRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get fee calculator');\n    }\n    const {context, value} = res.result;\n    return {\n      context,\n      value: value !== null ? value.feeCalculator : null,\n    };\n  }\n\n  /**\n   * Fetch the fee for a message from the cluster, return with context\n   */\n  async getFeeForMessage(\n    message: VersionedMessage,\n    commitment?: Commitment,\n  ): Promise<RpcResponseAndContext<number | null>> {\n    const wireMessage = toBuffer(message.serialize()).toString('base64');\n    const args = this._buildArgs([wireMessage], commitment);\n    const unsafeRes = await this._rpcRequest('getFeeForMessage', args);\n\n    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(number())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get fee for message');\n    }\n    if (res.result === null) {\n      throw new Error('invalid blockhash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */\n  async getRecentPrioritizationFees(\n    config?: GetRecentPrioritizationFeesConfig,\n  ): Promise<RecentPrioritizationFees[]> {\n    const accounts = config?.lockedWritableAccounts?.map(key => key.toBase58());\n    const args = accounts?.length ? [accounts] : [];\n    const unsafeRes = await this._rpcRequest(\n      'getRecentPrioritizationFees',\n      args,\n    );\n    const res = create(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to get recent prioritization fees',\n      );\n    }\n    return res.result;\n  }\n  /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */\n  async getRecentBlockhash(\n    commitment?: Commitment,\n  ): Promise<{blockhash: Blockhash; feeCalculator: FeeCalculator}> {\n    try {\n      const res = await this.getRecentBlockhashAndContext(commitment);\n      return res.value;\n    } catch (e) {\n      throw new Error('failed to get recent blockhash: ' + e);\n    }\n  }\n\n  /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */\n  async getLatestBlockhash(\n    commitmentOrConfig?: Commitment | GetLatestBlockhashConfig,\n  ): Promise<BlockhashWithExpiryBlockHeight> {\n    try {\n      const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n      return res.value;\n    } catch (e) {\n      throw new Error('failed to get recent blockhash: ' + e);\n    }\n  }\n\n  /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */\n  async getLatestBlockhashAndContext(\n    commitmentOrConfig?: Commitment | GetLatestBlockhashConfig,\n  ): Promise<RpcResponseAndContext<BlockhashWithExpiryBlockHeight>> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [],\n      commitment,\n      undefined /* encoding */,\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getLatestBlockhash', args);\n    const res = create(unsafeRes, GetLatestBlockhashRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get latest blockhash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Returns whether a blockhash is still valid or not\n   */\n  async isBlockhashValid(\n    blockhash: Blockhash,\n    rawConfig?: IsBlockhashValidConfig,\n  ): Promise<RpcResponseAndContext<boolean>> {\n    const {commitment, config} = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgs(\n      [blockhash],\n      commitment,\n      undefined /* encoding */,\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('isBlockhashValid', args);\n    const res = create(unsafeRes, IsBlockhashValidRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to determine if the blockhash `' + blockhash + '`is valid',\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the node version\n   */\n  async getVersion(): Promise<Version> {\n    const unsafeRes = await this._rpcRequest('getVersion', []);\n    const res = create(unsafeRes, jsonRpcResult(VersionResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get version');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the genesis hash\n   */\n  async getGenesisHash(): Promise<string> {\n    const unsafeRes = await this._rpcRequest('getGenesisHash', []);\n    const res = create(unsafeRes, jsonRpcResult(string()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get genesis hash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n  async getBlock(\n    slot: number,\n    rawConfig?: GetBlockConfig,\n  ): Promise<BlockResponse | null>;\n\n  /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getBlock(\n    slot: number,\n    rawConfig: GetBlockConfig & {transactionDetails: 'accounts'},\n  ): Promise<AccountsModeBlockResponse | null>;\n\n  /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getBlock(\n    slot: number,\n    rawConfig: GetBlockConfig & {transactionDetails: 'none'},\n  ): Promise<NoneModeBlockResponse | null>;\n\n  /**\n   * Fetch a processed block from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getBlock(\n    slot: number,\n    rawConfig?: GetVersionedBlockConfig,\n  ): Promise<VersionedBlockResponse | null>;\n\n  // eslint-disable-next-line no-dupe-class-members\n  async getBlock(\n    slot: number,\n    rawConfig: GetVersionedBlockConfig & {transactionDetails: 'accounts'},\n  ): Promise<VersionedAccountsModeBlockResponse | null>;\n\n  // eslint-disable-next-line no-dupe-class-members\n  async getBlock(\n    slot: number,\n    rawConfig: GetVersionedBlockConfig & {transactionDetails: 'none'},\n  ): Promise<VersionedNoneModeBlockResponse | null>;\n\n  /**\n   * Fetch a processed block from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getBlock(\n    slot: number,\n    rawConfig?: GetVersionedBlockConfig,\n  ): Promise<\n    | VersionedBlockResponse\n    | VersionedAccountsModeBlockResponse\n    | VersionedNoneModeBlockResponse\n    | null\n  > {\n    const {commitment, config} = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed(\n      [slot],\n      commitment as Finality,\n      undefined /* encoding */,\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    try {\n      switch (config?.transactionDetails) {\n        case 'accounts': {\n          const res = create(unsafeRes, GetAccountsModeBlockRpcResult);\n          if ('error' in res) {\n            throw res.error;\n          }\n          return res.result;\n        }\n        case 'none': {\n          const res = create(unsafeRes, GetNoneModeBlockRpcResult);\n          if ('error' in res) {\n            throw res.error;\n          }\n          return res.result;\n        }\n        default: {\n          const res = create(unsafeRes, GetBlockRpcResult);\n          if ('error' in res) {\n            throw res.error;\n          }\n          const {result} = res;\n          return result\n            ? {\n                ...result,\n                transactions: result.transactions.map(\n                  ({transaction, meta, version}) => ({\n                    meta,\n                    transaction: {\n                      ...transaction,\n                      message: versionedMessageFromResponse(\n                        version,\n                        transaction.message,\n                      ),\n                    },\n                    version,\n                  }),\n                ),\n              }\n            : null;\n        }\n      }\n    } catch (e) {\n      throw new SolanaJSONRPCError(\n        e as JSONRPCError,\n        'failed to get confirmed block',\n      );\n    }\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */\n  async getParsedBlock(\n    slot: number,\n    rawConfig?: GetVersionedBlockConfig,\n  ): Promise<ParsedAccountsModeBlockResponse>;\n\n  // eslint-disable-next-line no-dupe-class-members\n  async getParsedBlock(\n    slot: number,\n    rawConfig: GetVersionedBlockConfig & {transactionDetails: 'accounts'},\n  ): Promise<ParsedAccountsModeBlockResponse>;\n\n  // eslint-disable-next-line no-dupe-class-members\n  async getParsedBlock(\n    slot: number,\n    rawConfig: GetVersionedBlockConfig & {transactionDetails: 'none'},\n  ): Promise<ParsedNoneModeBlockResponse>;\n  // eslint-disable-next-line no-dupe-class-members\n  async getParsedBlock(\n    slot: number,\n    rawConfig?: GetVersionedBlockConfig,\n  ): Promise<\n    | ParsedBlockResponse\n    | ParsedAccountsModeBlockResponse\n    | ParsedNoneModeBlockResponse\n    | null\n  > {\n    const {commitment, config} = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed(\n      [slot],\n      commitment as Finality,\n      'jsonParsed',\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    try {\n      switch (config?.transactionDetails) {\n        case 'accounts': {\n          const res = create(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n          if ('error' in res) {\n            throw res.error;\n          }\n          return res.result;\n        }\n        case 'none': {\n          const res = create(unsafeRes, GetParsedNoneModeBlockRpcResult);\n          if ('error' in res) {\n            throw res.error;\n          }\n          return res.result;\n        }\n        default: {\n          const res = create(unsafeRes, GetParsedBlockRpcResult);\n          if ('error' in res) {\n            throw res.error;\n          }\n          return res.result;\n        }\n      }\n    } catch (e) {\n      throw new SolanaJSONRPCError(e as JSONRPCError, 'failed to get block');\n    }\n  }\n\n  /*\n   * Returns the current block height of the node\n   */\n  getBlockHeight = (() => {\n    const requestPromises: {[hash: string]: Promise<number>} = {};\n    return async (\n      commitmentOrConfig?: Commitment | GetBlockHeightConfig,\n    ): Promise<number> => {\n      const {commitment, config} =\n        extractCommitmentFromConfig(commitmentOrConfig);\n      const args = this._buildArgs(\n        [],\n        commitment,\n        undefined /* encoding */,\n        config,\n      );\n      const requestHash = fastStableStringify(args);\n      requestPromises[requestHash] =\n        requestPromises[requestHash] ??\n        (async () => {\n          try {\n            const unsafeRes = await this._rpcRequest('getBlockHeight', args);\n            const res = create(unsafeRes, jsonRpcResult(number()));\n            if ('error' in res) {\n              throw new SolanaJSONRPCError(\n                res.error,\n                'failed to get block height information',\n              );\n            }\n            return res.result;\n          } finally {\n            delete requestPromises[requestHash];\n          }\n        })();\n      return await requestPromises[requestHash];\n    };\n  })();\n\n  /*\n   * Returns recent block production information from the current or previous epoch\n   */\n  async getBlockProduction(\n    configOrCommitment?: GetBlockProductionConfig | Commitment,\n  ): Promise<RpcResponseAndContext<BlockProduction>> {\n    let extra: Omit<GetBlockProductionConfig, 'commitment'> | undefined;\n    let commitment: Commitment | undefined;\n\n    if (typeof configOrCommitment === 'string') {\n      commitment = configOrCommitment;\n    } else if (configOrCommitment) {\n      const {commitment: c, ...rest} = configOrCommitment;\n      commitment = c;\n      extra = rest;\n    }\n\n    const args = this._buildArgs([], commitment, 'base64', extra);\n    const unsafeRes = await this._rpcRequest('getBlockProduction', args);\n    const res = create(unsafeRes, BlockProductionResponseStruct);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to get block production information',\n      );\n    }\n\n    return res.result;\n  }\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */\n  async getTransaction(\n    signature: string,\n    rawConfig?: GetTransactionConfig,\n  ): Promise<TransactionResponse | null>;\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getTransaction(\n    signature: string,\n    rawConfig: GetVersionedTransactionConfig,\n  ): Promise<VersionedTransactionResponse | null>;\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getTransaction(\n    signature: string,\n    rawConfig?: GetVersionedTransactionConfig,\n  ): Promise<VersionedTransactionResponse | null> {\n    const {commitment, config} = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed(\n      [signature],\n      commitment as Finality,\n      undefined /* encoding */,\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = create(unsafeRes, GetTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n\n    const result = res.result;\n    if (!result) return result;\n\n    return {\n      ...result,\n      transaction: {\n        ...result.transaction,\n        message: versionedMessageFromResponse(\n          result.version,\n          result.transaction.message,\n        ),\n      },\n    };\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */\n  async getParsedTransaction(\n    signature: TransactionSignature,\n    commitmentOrConfig?: GetVersionedTransactionConfig | Finality,\n  ): Promise<ParsedTransactionWithMeta | null> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgsAtLeastConfirmed(\n      [signature],\n      commitment as Finality,\n      'jsonParsed',\n      config,\n    );\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = create(unsafeRes, GetParsedTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */\n  async getParsedTransactions(\n    signatures: TransactionSignature[],\n    commitmentOrConfig?: GetVersionedTransactionConfig | Finality,\n  ): Promise<(ParsedTransactionWithMeta | null)[]> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const batch = signatures.map(signature => {\n      const args = this._buildArgsAtLeastConfirmed(\n        [signature],\n        commitment as Finality,\n        'jsonParsed',\n        config,\n      );\n      return {\n        methodName: 'getTransaction',\n        args,\n      };\n    });\n\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = unsafeRes.map((unsafeRes: any) => {\n      const res = create(unsafeRes, GetParsedTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');\n      }\n      return res.result;\n    });\n\n    return res;\n  }\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */\n  async getTransactions(\n    signatures: TransactionSignature[],\n    commitmentOrConfig?: GetTransactionConfig | Finality,\n  ): Promise<(TransactionResponse | null)[]>;\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getTransactions(\n    signatures: TransactionSignature[],\n    commitmentOrConfig: GetVersionedTransactionConfig | Finality,\n  ): Promise<(VersionedTransactionResponse | null)[]>;\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getTransactions(\n    signatures: TransactionSignature[],\n    commitmentOrConfig: GetVersionedTransactionConfig | Finality,\n  ): Promise<(VersionedTransactionResponse | null)[]> {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const batch = signatures.map(signature => {\n      const args = this._buildArgsAtLeastConfirmed(\n        [signature],\n        commitment as Finality,\n        undefined /* encoding */,\n        config,\n      );\n      return {\n        methodName: 'getTransaction',\n        args,\n      };\n    });\n\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = unsafeRes.map((unsafeRes: any) => {\n      const res = create(unsafeRes, GetTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');\n      }\n      const result = res.result;\n      if (!result) return result;\n\n      return {\n        ...result,\n        transaction: {\n          ...result.transaction,\n          message: versionedMessageFromResponse(\n            result.version,\n            result.transaction.message,\n          ),\n        },\n      };\n    });\n\n    return res;\n  }\n\n  /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.\n   */\n  async getConfirmedBlock(\n    slot: number,\n    commitment?: Finality,\n  ): Promise<ConfirmedBlock> {\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment);\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    const res = create(unsafeRes, GetConfirmedBlockRpcResult);\n\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');\n    }\n\n    const result = res.result;\n    if (!result) {\n      throw new Error('Confirmed block ' + slot + ' not found');\n    }\n\n    const block = {\n      ...result,\n      transactions: result.transactions.map(({transaction, meta}) => {\n        const message = new Message(transaction.message);\n        return {\n          meta,\n          transaction: {\n            ...transaction,\n            message,\n          },\n        };\n      }),\n    };\n\n    return {\n      ...block,\n      transactions: block.transactions.map(({transaction, meta}) => {\n        return {\n          meta,\n          transaction: Transaction.populate(\n            transaction.message,\n            transaction.signatures,\n          ),\n        };\n      }),\n    };\n  }\n\n  /**\n   * Fetch confirmed blocks between two slots\n   */\n  async getBlocks(\n    startSlot: number,\n    endSlot?: number,\n    commitment?: Finality,\n  ): Promise<Array<number>> {\n    const args = this._buildArgsAtLeastConfirmed(\n      endSlot !== undefined ? [startSlot, endSlot] : [startSlot],\n      commitment,\n    );\n    const unsafeRes = await this._rpcRequest('getBlocks', args);\n    const res = create(unsafeRes, jsonRpcResult(array(number())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get blocks');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */\n  async getBlockSignatures(\n    slot: number,\n    commitment?: Finality,\n  ): Promise<BlockSignatures> {\n    const args = this._buildArgsAtLeastConfirmed(\n      [slot],\n      commitment,\n      undefined,\n      {\n        transactionDetails: 'signatures',\n        rewards: false,\n      },\n    );\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    const res = create(unsafeRes, GetBlockSignaturesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get block');\n    }\n    const result = res.result;\n    if (!result) {\n      throw new Error('Block ' + slot + ' not found');\n    }\n    return result;\n  }\n\n  /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.\n   */\n  async getConfirmedBlockSignatures(\n    slot: number,\n    commitment?: Finality,\n  ): Promise<BlockSignatures> {\n    const args = this._buildArgsAtLeastConfirmed(\n      [slot],\n      commitment,\n      undefined,\n      {\n        transactionDetails: 'signatures',\n        rewards: false,\n      },\n    );\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    const res = create(unsafeRes, GetBlockSignaturesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');\n    }\n    const result = res.result;\n    if (!result) {\n      throw new Error('Confirmed block ' + slot + ' not found');\n    }\n    return result;\n  }\n\n  /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.\n   */\n  async getConfirmedTransaction(\n    signature: TransactionSignature,\n    commitment?: Finality,\n  ): Promise<ConfirmedTransaction | null> {\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment);\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = create(unsafeRes, GetTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n\n    const result = res.result;\n    if (!result) return result;\n\n    const message = new Message(result.transaction.message);\n    const signatures = result.transaction.signatures;\n    return {\n      ...result,\n      transaction: Transaction.populate(message, signatures),\n    };\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.\n   */\n  async getParsedConfirmedTransaction(\n    signature: TransactionSignature,\n    commitment?: Finality,\n  ): Promise<ParsedConfirmedTransaction | null> {\n    const args = this._buildArgsAtLeastConfirmed(\n      [signature],\n      commitment,\n      'jsonParsed',\n    );\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = create(unsafeRes, GetParsedTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to get confirmed transaction',\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.\n   */\n  async getParsedConfirmedTransactions(\n    signatures: TransactionSignature[],\n    commitment?: Finality,\n  ): Promise<(ParsedConfirmedTransaction | null)[]> {\n    const batch = signatures.map(signature => {\n      const args = this._buildArgsAtLeastConfirmed(\n        [signature],\n        commitment,\n        'jsonParsed',\n      );\n      return {\n        methodName: 'getTransaction',\n        args,\n      };\n    });\n\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = unsafeRes.map((unsafeRes: any) => {\n      const res = create(unsafeRes, GetParsedTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(\n          res.error,\n          'failed to get confirmed transactions',\n        );\n      }\n      return res.result;\n    });\n\n    return res;\n  }\n\n  /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */\n  async getConfirmedSignaturesForAddress(\n    address: PublicKey,\n    startSlot: number,\n    endSlot: number,\n  ): Promise<Array<TransactionSignature>> {\n    let options: any = {};\n\n    let firstAvailableBlock = await this.getFirstAvailableBlock();\n    while (!('until' in options)) {\n      startSlot--;\n      if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n        break;\n      }\n\n      try {\n        const block = await this.getConfirmedBlockSignatures(\n          startSlot,\n          'finalized',\n        );\n        if (block.signatures.length > 0) {\n          options.until =\n            block.signatures[block.signatures.length - 1].toString();\n        }\n      } catch (err) {\n        if (err instanceof Error && err.message.includes('skipped')) {\n          continue;\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    let highestConfirmedRoot = await this.getSlot('finalized');\n    while (!('before' in options)) {\n      endSlot++;\n      if (endSlot > highestConfirmedRoot) {\n        break;\n      }\n\n      try {\n        const block = await this.getConfirmedBlockSignatures(endSlot);\n        if (block.signatures.length > 0) {\n          options.before =\n            block.signatures[block.signatures.length - 1].toString();\n        }\n      } catch (err) {\n        if (err instanceof Error && err.message.includes('skipped')) {\n          continue;\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(\n      address,\n      options,\n    );\n    return confirmedSignatureInfo.map(info => info.signature);\n  }\n\n  /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.\n   */\n  async getConfirmedSignaturesForAddress2(\n    address: PublicKey,\n    options?: ConfirmedSignaturesForAddress2Options,\n    commitment?: Finality,\n  ): Promise<Array<ConfirmedSignatureInfo>> {\n    const args = this._buildArgsAtLeastConfirmed(\n      [address.toBase58()],\n      commitment,\n      undefined,\n      options,\n    );\n    const unsafeRes = await this._rpcRequest(\n      'getConfirmedSignaturesForAddress2',\n      args,\n    );\n    const res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to get confirmed signatures for address',\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */\n  async getSignaturesForAddress(\n    address: PublicKey,\n    options?: SignaturesForAddressOptions,\n    commitment?: Finality,\n  ): Promise<Array<ConfirmedSignatureInfo>> {\n    const args = this._buildArgsAtLeastConfirmed(\n      [address.toBase58()],\n      commitment,\n      undefined,\n      options,\n    );\n    const unsafeRes = await this._rpcRequest('getSignaturesForAddress', args);\n    const res = create(unsafeRes, GetSignaturesForAddressRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        'failed to get signatures for address',\n      );\n    }\n    return res.result;\n  }\n\n  async getAddressLookupTable(\n    accountKey: PublicKey,\n    config?: GetAccountInfoConfig,\n  ): Promise<RpcResponseAndContext<AddressLookupTableAccount | null>> {\n    const {context, value: accountInfo} = await this.getAccountInfoAndContext(\n      accountKey,\n      config,\n    );\n\n    let value = null;\n    if (accountInfo !== null) {\n      value = new AddressLookupTableAccount({\n        key: accountKey,\n        state: AddressLookupTableAccount.deserialize(accountInfo.data),\n      });\n    }\n\n    return {\n      context,\n      value,\n    };\n  }\n\n  /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */\n  async getNonceAndContext(\n    nonceAccount: PublicKey,\n    commitmentOrConfig?: Commitment | GetNonceAndContextConfig,\n  ): Promise<RpcResponseAndContext<NonceAccount | null>> {\n    const {context, value: accountInfo} = await this.getAccountInfoAndContext(\n      nonceAccount,\n      commitmentOrConfig,\n    );\n\n    let value = null;\n    if (accountInfo !== null) {\n      value = NonceAccount.fromAccountData(accountInfo.data);\n    }\n\n    return {\n      context,\n      value,\n    };\n  }\n\n  /**\n   * Fetch the contents of a Nonce account from the cluster\n   */\n  async getNonce(\n    nonceAccount: PublicKey,\n    commitmentOrConfig?: Commitment | GetNonceConfig,\n  ): Promise<NonceAccount | null> {\n    return await this.getNonceAndContext(nonceAccount, commitmentOrConfig)\n      .then(x => x.value)\n      .catch(e => {\n        throw new Error(\n          'failed to get nonce for account ' +\n            nonceAccount.toBase58() +\n            ': ' +\n            e,\n        );\n      });\n  }\n\n  /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */\n  async requestAirdrop(\n    to: PublicKey,\n    lamports: number,\n  ): Promise<TransactionSignature> {\n    const unsafeRes = await this._rpcRequest('requestAirdrop', [\n      to.toBase58(),\n      lamports,\n    ]);\n    const res = create(unsafeRes, RequestAirdropRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `airdrop to ${to.toBase58()} failed`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * @internal\n   */\n  async _blockhashWithExpiryBlockHeight(\n    disableCache: boolean,\n  ): Promise<BlockhashWithExpiryBlockHeight> {\n    if (!disableCache) {\n      // Wait for polling to finish\n      while (this._pollingBlockhash) {\n        await sleep(100);\n      }\n      const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n      if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n        return this._blockhashInfo.latestBlockhash;\n      }\n    }\n\n    return await this._pollNewBlockhash();\n  }\n\n  /**\n   * @internal\n   */\n  async _pollNewBlockhash(): Promise<BlockhashWithExpiryBlockHeight> {\n    this._pollingBlockhash = true;\n    try {\n      const startTime = Date.now();\n      const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n      const cachedBlockhash = cachedLatestBlockhash\n        ? cachedLatestBlockhash.blockhash\n        : null;\n      for (let i = 0; i < 50; i++) {\n        const latestBlockhash = await this.getLatestBlockhash('finalized');\n\n        if (cachedBlockhash !== latestBlockhash.blockhash) {\n          this._blockhashInfo = {\n            latestBlockhash,\n            lastFetch: Date.now(),\n            transactionSignatures: [],\n            simulatedSignatures: [],\n          };\n          return latestBlockhash;\n        }\n\n        // Sleep for approximately half a slot\n        await sleep(MS_PER_SLOT / 2);\n      }\n\n      throw new Error(\n        `Unable to obtain a new blockhash after ${Date.now() - startTime}ms`,\n      );\n    } finally {\n      this._pollingBlockhash = false;\n    }\n  }\n\n  /**\n   * get the stake minimum delegation\n   */\n  async getStakeMinimumDelegation(\n    config?: GetStakeMinimumDelegationConfig,\n  ): Promise<RpcResponseAndContext<number>> {\n    const {commitment, config: configArg} = extractCommitmentFromConfig(config);\n    const args = this._buildArgs([], commitment, 'base64', configArg);\n    const unsafeRes = await this._rpcRequest('getStakeMinimumDelegation', args);\n    const res = create(unsafeRes, jsonRpcResultAndContext(number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(\n        res.error,\n        `failed to get stake minimum delegation`,\n      );\n    }\n    return res.result;\n  }\n\n  /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */\n  simulateTransaction(\n    transactionOrMessage: Transaction | Message,\n    signers?: Array<Signer>,\n    includeAccounts?: boolean | Array<PublicKey>,\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>>;\n\n  /**\n   * Simulate a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  simulateTransaction(\n    transaction: VersionedTransaction,\n    config?: SimulateTransactionConfig,\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>>;\n\n  /**\n   * Simulate a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async simulateTransaction(\n    transactionOrMessage: VersionedTransaction | Transaction | Message,\n    configOrSigners?: SimulateTransactionConfig | Array<Signer>,\n    includeAccounts?: boolean | Array<PublicKey>,\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n    if ('message' in transactionOrMessage) {\n      const versionedTx = transactionOrMessage;\n      const wireTransaction = versionedTx.serialize();\n      const encodedTransaction =\n        Buffer.from(wireTransaction).toString('base64');\n      if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n        throw new Error('Invalid arguments');\n      }\n\n      const config: any = configOrSigners || {};\n      config.encoding = 'base64';\n      if (!('commitment' in config)) {\n        config.commitment = this.commitment;\n      }\n\n      if (\n        configOrSigners &&\n        typeof configOrSigners === 'object' &&\n        'innerInstructions' in configOrSigners\n      ) {\n        config.innerInstructions = configOrSigners.innerInstructions;\n      }\n\n      const args = [encodedTransaction, config];\n      const unsafeRes = await this._rpcRequest('simulateTransaction', args);\n      const res = create(unsafeRes, SimulatedTransactionResponseStruct);\n      if ('error' in res) {\n        throw new Error('failed to simulate transaction: ' + res.error.message);\n      }\n      return res.result;\n    }\n\n    let transaction;\n    if (transactionOrMessage instanceof Transaction) {\n      let originalTx: Transaction = transactionOrMessage;\n      transaction = new Transaction();\n      transaction.feePayer = originalTx.feePayer;\n      transaction.instructions = transactionOrMessage.instructions;\n      transaction.nonceInfo = originalTx.nonceInfo;\n      transaction.signatures = originalTx.signatures;\n    } else {\n      transaction = Transaction.populate(transactionOrMessage);\n      // HACK: this function relies on mutating the populated transaction\n      transaction._message = transaction._json = undefined;\n    }\n\n    if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n      throw new Error('Invalid arguments');\n    }\n\n    const signers = configOrSigners;\n    if (transaction.nonceInfo && signers) {\n      transaction.sign(...signers);\n    } else {\n      let disableCache = this._disableBlockhashCaching;\n      for (;;) {\n        const latestBlockhash =\n          await this._blockhashWithExpiryBlockHeight(disableCache);\n        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n        transaction.recentBlockhash = latestBlockhash.blockhash;\n\n        if (!signers) break;\n\n        transaction.sign(...signers);\n        if (!transaction.signature) {\n          throw new Error('!signature'); // should never happen\n        }\n\n        const signature = transaction.signature.toString('base64');\n        if (\n          !this._blockhashInfo.simulatedSignatures.includes(signature) &&\n          !this._blockhashInfo.transactionSignatures.includes(signature)\n        ) {\n          // The signature of this transaction has not been seen before with the\n          // current recentBlockhash, all done. Let's break\n          this._blockhashInfo.simulatedSignatures.push(signature);\n          break;\n        } else {\n          // This transaction would be treated as duplicate (its derived signature\n          // matched to one of already recorded signatures).\n          // So, we must fetch a new blockhash for a different signature by disabling\n          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n          disableCache = true;\n        }\n      }\n    }\n\n    const message = transaction._compile();\n    const signData = message.serialize();\n    const wireTransaction = transaction._serialize(signData);\n    const encodedTransaction = wireTransaction.toString('base64');\n    const config: any = {\n      encoding: 'base64',\n      commitment: this.commitment,\n    };\n\n    if (includeAccounts) {\n      const addresses = (\n        Array.isArray(includeAccounts)\n          ? includeAccounts\n          : message.nonProgramIds()\n      ).map(key => key.toBase58());\n\n      config['accounts'] = {\n        encoding: 'base64',\n        addresses,\n      };\n    }\n\n    if (signers) {\n      config.sigVerify = true;\n    }\n\n    if (\n      configOrSigners &&\n      typeof configOrSigners === 'object' &&\n      'innerInstructions' in configOrSigners\n    ) {\n      config.innerInstructions = configOrSigners.innerInstructions;\n    }\n\n    const args = [encodedTransaction, config];\n    const unsafeRes = await this._rpcRequest('simulateTransaction', args);\n    const res = create(unsafeRes, SimulatedTransactionResponseStruct);\n    if ('error' in res) {\n      let logs;\n      if ('data' in res.error) {\n        logs = res.error.data.logs;\n        if (logs && Array.isArray(logs)) {\n          const traceIndent = '\\n    ';\n          const logTrace = traceIndent + logs.join(traceIndent);\n          console.error(res.error.message, logTrace);\n        }\n      }\n\n      throw new SendTransactionError({\n        action: 'simulate',\n        signature: '',\n        transactionMessage: res.error.message,\n        logs: logs,\n      });\n    }\n    return res.result;\n  }\n\n  /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */\n  sendTransaction(\n    transaction: Transaction,\n    signers: Array<Signer>,\n    options?: SendOptions,\n  ): Promise<TransactionSignature>;\n\n  /**\n   * Send a signed transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  sendTransaction(\n    transaction: VersionedTransaction,\n    options?: SendOptions,\n  ): Promise<TransactionSignature>;\n\n  /**\n   * Sign and send a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async sendTransaction(\n    transaction: VersionedTransaction | Transaction,\n    signersOrOptions?: Array<Signer> | SendOptions,\n    options?: SendOptions,\n  ): Promise<TransactionSignature> {\n    if ('version' in transaction) {\n      if (signersOrOptions && Array.isArray(signersOrOptions)) {\n        throw new Error('Invalid arguments');\n      }\n\n      const wireTransaction = transaction.serialize();\n      return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n    }\n\n    if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n      throw new Error('Invalid arguments');\n    }\n\n    const signers = signersOrOptions;\n    if (transaction.nonceInfo) {\n      transaction.sign(...signers);\n    } else {\n      let disableCache = this._disableBlockhashCaching;\n      for (;;) {\n        const latestBlockhash =\n          await this._blockhashWithExpiryBlockHeight(disableCache);\n        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n        transaction.recentBlockhash = latestBlockhash.blockhash;\n        transaction.sign(...signers);\n        if (!transaction.signature) {\n          throw new Error('!signature'); // should never happen\n        }\n\n        const signature = transaction.signature.toString('base64');\n        if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n          // The signature of this transaction has not been seen before with the\n          // current recentBlockhash, all done. Let's break\n          this._blockhashInfo.transactionSignatures.push(signature);\n          break;\n        } else {\n          // This transaction would be treated as duplicate (its derived signature\n          // matched to one of already recorded signatures).\n          // So, we must fetch a new blockhash for a different signature by disabling\n          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n          disableCache = true;\n        }\n      }\n    }\n\n    const wireTransaction = transaction.serialize();\n    return await this.sendRawTransaction(wireTransaction, options);\n  }\n\n  /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */\n  async sendRawTransaction(\n    rawTransaction: Buffer | Uint8Array | Array<number>,\n    options?: SendOptions,\n  ): Promise<TransactionSignature> {\n    const encodedTransaction = toBuffer(rawTransaction).toString('base64');\n    const result = await this.sendEncodedTransaction(\n      encodedTransaction,\n      options,\n    );\n    return result;\n  }\n\n  /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */\n  async sendEncodedTransaction(\n    encodedTransaction: string,\n    options?: SendOptions,\n  ): Promise<TransactionSignature> {\n    const config: any = {encoding: 'base64'};\n    const skipPreflight = options && options.skipPreflight;\n    const preflightCommitment =\n      skipPreflight === true\n        ? 'processed' // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n        : (options && options.preflightCommitment) || this.commitment;\n\n    if (options && options.maxRetries != null) {\n      config.maxRetries = options.maxRetries;\n    }\n    if (options && options.minContextSlot != null) {\n      config.minContextSlot = options.minContextSlot;\n    }\n    if (skipPreflight) {\n      config.skipPreflight = skipPreflight;\n    }\n    if (preflightCommitment) {\n      config.preflightCommitment = preflightCommitment;\n    }\n\n    const args = [encodedTransaction, config];\n    const unsafeRes = await this._rpcRequest('sendTransaction', args);\n    const res = create(unsafeRes, SendTransactionRpcResult);\n    if ('error' in res) {\n      let logs = undefined;\n      if ('data' in res.error) {\n        logs = res.error.data.logs;\n      }\n\n      throw new SendTransactionError({\n        action: skipPreflight ? 'send' : 'simulate',\n        signature: '',\n        transactionMessage: res.error.message,\n        logs: logs,\n      });\n    }\n    return res.result;\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnOpen() {\n    this._rpcWebSocketConnected = true;\n    this._rpcWebSocketHeartbeat = setInterval(() => {\n      // Ping server every 5s to prevent idle timeouts\n      (async () => {\n        try {\n          await this._rpcWebSocket.notify('ping');\n          // eslint-disable-next-line no-empty\n        } catch {}\n      })();\n    }, 5000);\n    this._updateSubscriptions();\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnError(err: Error) {\n    this._rpcWebSocketConnected = false;\n    console.error('ws error:', err.message);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnClose(code: number) {\n    this._rpcWebSocketConnected = false;\n    this._rpcWebSocketGeneration =\n      (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n    if (this._rpcWebSocketIdleTimeout) {\n      clearTimeout(this._rpcWebSocketIdleTimeout);\n      this._rpcWebSocketIdleTimeout = null;\n    }\n    if (this._rpcWebSocketHeartbeat) {\n      clearInterval(this._rpcWebSocketHeartbeat);\n      this._rpcWebSocketHeartbeat = null;\n    }\n\n    if (code === 1000) {\n      // explicit close, check if any subscriptions have been made since close\n      this._updateSubscriptions();\n      return;\n    }\n\n    // implicit close, prepare subscriptions for auto-reconnect\n    this._subscriptionCallbacksByServerSubscriptionId = {};\n    Object.entries(\n      this._subscriptionsByHash as Record<SubscriptionConfigHash, Subscription>,\n    ).forEach(([hash, subscription]) => {\n      this._setSubscription(hash, {\n        ...subscription,\n        state: 'pending',\n      });\n    });\n  }\n\n  /**\n   * @internal\n   */\n  private _setSubscription(\n    hash: SubscriptionConfigHash,\n    nextSubscription: Subscription,\n  ) {\n    const prevState = this._subscriptionsByHash[hash]?.state;\n    this._subscriptionsByHash[hash] = nextSubscription;\n    if (prevState !== nextSubscription.state) {\n      const stateChangeCallbacks =\n        this._subscriptionStateChangeCallbacksByHash[hash];\n      if (stateChangeCallbacks) {\n        stateChangeCallbacks.forEach(cb => {\n          try {\n            cb(nextSubscription.state);\n            // eslint-disable-next-line no-empty\n          } catch {}\n        });\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  private _onSubscriptionStateChange(\n    clientSubscriptionId: ClientSubscriptionId,\n    callback: SubscriptionStateChangeCallback,\n  ): SubscriptionStateChangeDisposeFn {\n    const hash =\n      this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n    if (hash == null) {\n      return () => {};\n    }\n    const stateChangeCallbacks = (this._subscriptionStateChangeCallbacksByHash[\n      hash\n    ] ||= new Set());\n    stateChangeCallbacks.add(callback);\n    return () => {\n      stateChangeCallbacks.delete(callback);\n      if (stateChangeCallbacks.size === 0) {\n        delete this._subscriptionStateChangeCallbacksByHash[hash];\n      }\n    };\n  }\n\n  /**\n   * @internal\n   */\n  async _updateSubscriptions() {\n    if (Object.keys(this._subscriptionsByHash).length === 0) {\n      if (this._rpcWebSocketConnected) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketIdleTimeout = setTimeout(() => {\n          this._rpcWebSocketIdleTimeout = null;\n          try {\n            this._rpcWebSocket.close();\n          } catch (err) {\n            // swallow error if socket has already been closed.\n            if (err instanceof Error) {\n              console.log(\n                `Error when closing socket connection: ${err.message}`,\n              );\n            }\n          }\n        }, 500);\n      }\n      return;\n    }\n\n    if (this._rpcWebSocketIdleTimeout !== null) {\n      clearTimeout(this._rpcWebSocketIdleTimeout);\n      this._rpcWebSocketIdleTimeout = null;\n      this._rpcWebSocketConnected = true;\n    }\n\n    if (!this._rpcWebSocketConnected) {\n      this._rpcWebSocket.connect();\n      return;\n    }\n\n    const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n    const isCurrentConnectionStillActive = () => {\n      return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n    };\n\n    await Promise.all(\n      // Don't be tempted to change this to `Object.entries`. We call\n      // `_updateSubscriptions` recursively when processing the state,\n      // so it's important that we look up the *current* version of\n      // each subscription, every time we process a hash.\n      Object.keys(this._subscriptionsByHash).map(async hash => {\n        const subscription = this._subscriptionsByHash[hash];\n        if (subscription === undefined) {\n          // This entry has since been deleted. Skip.\n          return;\n        }\n        switch (subscription.state) {\n          case 'pending':\n          case 'unsubscribed':\n            if (subscription.callbacks.size === 0) {\n              /**\n               * You can end up here when:\n               *\n               * - a subscription has recently unsubscribed\n               *   without having new callbacks added to it\n               *   while the unsubscribe was in flight, or\n               * - when a pending subscription has its\n               *   listeners removed before a request was\n               *   sent to the server.\n               *\n               * Being that nobody is interested in this\n               * subscription any longer, delete it.\n               */\n              delete this._subscriptionsByHash[hash];\n              if (subscription.state === 'unsubscribed') {\n                delete this._subscriptionCallbacksByServerSubscriptionId[\n                  subscription.serverSubscriptionId\n                ];\n              }\n              await this._updateSubscriptions();\n              return;\n            }\n            await (async () => {\n              const {args, method} = subscription;\n              try {\n                this._setSubscription(hash, {\n                  ...subscription,\n                  state: 'subscribing',\n                });\n                const serverSubscriptionId: ServerSubscriptionId =\n                  (await this._rpcWebSocket.call(method, args)) as number;\n                this._setSubscription(hash, {\n                  ...subscription,\n                  serverSubscriptionId,\n                  state: 'subscribed',\n                });\n                this._subscriptionCallbacksByServerSubscriptionId[\n                  serverSubscriptionId\n                ] = subscription.callbacks;\n                await this._updateSubscriptions();\n              } catch (e) {\n                console.error(\n                  `Received ${e instanceof Error ? '' : 'JSON-RPC '}error calling \\`${method}\\``,\n                  {\n                    args,\n                    error: e,\n                  },\n                );\n                if (!isCurrentConnectionStillActive()) {\n                  return;\n                }\n                // TODO: Maybe add an 'errored' state or a retry limit?\n                this._setSubscription(hash, {\n                  ...subscription,\n                  state: 'pending',\n                });\n                await this._updateSubscriptions();\n              }\n            })();\n            break;\n          case 'subscribed':\n            if (subscription.callbacks.size === 0) {\n              // By the time we successfully set up a subscription\n              // with the server, the client stopped caring about it.\n              // Tear it down now.\n              await (async () => {\n                const {serverSubscriptionId, unsubscribeMethod} = subscription;\n                if (\n                  this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)\n                ) {\n                  /**\n                   * Special case.\n                   * If we're dealing with a subscription that has been auto-\n                   * disposed by the RPC, then we can skip the RPC call to\n                   * tear down the subscription here.\n                   *\n                   * NOTE: There is a proposal to eliminate this special case, here:\n                   * https://github.com/solana-labs/solana/issues/18892\n                   */\n                  this._subscriptionsAutoDisposedByRpc.delete(\n                    serverSubscriptionId,\n                  );\n                } else {\n                  this._setSubscription(hash, {\n                    ...subscription,\n                    state: 'unsubscribing',\n                  });\n                  this._setSubscription(hash, {\n                    ...subscription,\n                    state: 'unsubscribing',\n                  });\n                  try {\n                    await this._rpcWebSocket.call(unsubscribeMethod, [\n                      serverSubscriptionId,\n                    ]);\n                  } catch (e) {\n                    if (e instanceof Error) {\n                      console.error(`${unsubscribeMethod} error:`, e.message);\n                    }\n                    if (!isCurrentConnectionStillActive()) {\n                      return;\n                    }\n                    // TODO: Maybe add an 'errored' state or a retry limit?\n                    this._setSubscription(hash, {\n                      ...subscription,\n                      state: 'subscribed',\n                    });\n                    await this._updateSubscriptions();\n                    return;\n                  }\n                }\n                this._setSubscription(hash, {\n                  ...subscription,\n                  state: 'unsubscribed',\n                });\n                await this._updateSubscriptions();\n              })();\n            }\n            break;\n          case 'subscribing':\n          case 'unsubscribing':\n            break;\n        }\n      }),\n    );\n  }\n\n  /**\n   * @internal\n   */\n  private _handleServerNotification<\n    TCallback extends SubscriptionConfig['callback'],\n  >(\n    serverSubscriptionId: ServerSubscriptionId,\n    callbackArgs: Parameters<TCallback>,\n  ): void {\n    const callbacks =\n      this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n    if (callbacks === undefined) {\n      return;\n    }\n    callbacks.forEach(cb => {\n      try {\n        cb(\n          // I failed to find a way to convince TypeScript that `cb` is of type\n          // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n          // See https://github.com/microsoft/TypeScript/issues/47615\n          // @ts-ignore\n          ...callbackArgs,\n        );\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnAccountNotification(notification: object) {\n    const {result, subscription} = create(\n      notification,\n      AccountNotificationResult,\n    );\n    this._handleServerNotification<AccountChangeCallback>(subscription, [\n      result.value,\n      result.context,\n    ]);\n  }\n\n  /**\n   * @internal\n   */\n  private _makeSubscription(\n    subscriptionConfig: SubscriptionConfig,\n    /**\n     * When preparing `args` for a call to `_makeSubscription`, be sure\n     * to carefully apply a default `commitment` property, if necessary.\n     *\n     * - If the user supplied a `commitment` use that.\n     * - Otherwise, if the `Connection::commitment` is set, use that.\n     * - Otherwise, set it to the RPC server default: `finalized`.\n     *\n     * This is extremely important to ensure that these two fundamentally\n     * identical subscriptions produce the same identifying hash:\n     *\n     * - A subscription made without specifying a commitment.\n     * - A subscription made where the commitment specified is the same\n     *   as the default applied to the subscription above.\n     *\n     * Example; these two subscriptions must produce the same hash:\n     *\n     * - An `accountSubscribe` subscription for `'PUBKEY'`\n     * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n     *   `'finalized'`.\n     *\n     * See the 'making a subscription with defaulted params omitted' test\n     * in `connection-subscriptions.ts` for more.\n     */\n    args: IWSRequestParams,\n  ): ClientSubscriptionId {\n    const clientSubscriptionId = this._nextClientSubscriptionId++;\n    const hash = fastStableStringify([subscriptionConfig.method, args]);\n    const existingSubscription = this._subscriptionsByHash[hash];\n    if (existingSubscription === undefined) {\n      this._subscriptionsByHash[hash] = {\n        ...subscriptionConfig,\n        args,\n        callbacks: new Set([subscriptionConfig.callback]),\n        state: 'pending',\n      };\n    } else {\n      existingSubscription.callbacks.add(subscriptionConfig.callback);\n    }\n    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n    this._subscriptionDisposeFunctionsByClientSubscriptionId[\n      clientSubscriptionId\n    ] = async () => {\n      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[\n        clientSubscriptionId\n      ];\n      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n      const subscription = this._subscriptionsByHash[hash];\n      assert(\n        subscription !== undefined,\n        `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`,\n      );\n      subscription.callbacks.delete(subscriptionConfig.callback);\n      await this._updateSubscriptions();\n    };\n    this._updateSubscriptions();\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */\n  onAccountChange(\n    publicKey: PublicKey,\n    callback: AccountChangeCallback,\n    config?: AccountSubscriptionConfig,\n  ): ClientSubscriptionId;\n  /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */\n  // eslint-disable-next-line no-dupe-class-members\n  onAccountChange(\n    publicKey: PublicKey,\n    callback: AccountChangeCallback,\n    commitment?: Commitment,\n  ): ClientSubscriptionId;\n  // eslint-disable-next-line no-dupe-class-members\n  onAccountChange(\n    publicKey: PublicKey,\n    callback: AccountChangeCallback,\n    commitmentOrConfig?: Commitment | AccountSubscriptionConfig,\n  ): ClientSubscriptionId {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [publicKey.toBase58()],\n      commitment || this._commitment || 'finalized', // Apply connection/server default.\n      'base64',\n      config,\n    );\n    return this._makeSubscription(\n      {\n        callback,\n        method: 'accountSubscribe',\n        unsubscribeMethod: 'accountUnsubscribe',\n      },\n      args,\n    );\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeAccountChangeListener(\n    clientSubscriptionId: ClientSubscriptionId,\n  ): Promise<void> {\n    await this._unsubscribeClientSubscription(\n      clientSubscriptionId,\n      'account change',\n    );\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnProgramAccountNotification(notification: Object) {\n    const {result, subscription} = create(\n      notification,\n      ProgramAccountNotificationResult,\n    );\n    this._handleServerNotification<ProgramAccountChangeCallback>(subscription, [\n      {\n        accountId: result.value.pubkey,\n        accountInfo: result.value.account,\n      },\n      result.context,\n    ]);\n  }\n\n  /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */\n  onProgramAccountChange(\n    programId: PublicKey,\n    callback: ProgramAccountChangeCallback,\n    config?: ProgramAccountSubscriptionConfig,\n  ): ClientSubscriptionId;\n  /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */\n  // eslint-disable-next-line no-dupe-class-members\n  onProgramAccountChange(\n    programId: PublicKey,\n    callback: ProgramAccountChangeCallback,\n    commitment?: Commitment,\n    filters?: GetProgramAccountsFilter[],\n  ): ClientSubscriptionId;\n  // eslint-disable-next-line no-dupe-class-members\n  onProgramAccountChange(\n    programId: PublicKey,\n    callback: ProgramAccountChangeCallback,\n    commitmentOrConfig?: Commitment | ProgramAccountSubscriptionConfig,\n    maybeFilters?: GetProgramAccountsFilter[],\n  ): ClientSubscriptionId {\n    const {commitment, config} =\n      extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs(\n      [programId.toBase58()],\n      commitment || this._commitment || 'finalized', // Apply connection/server default.\n      'base64' /* encoding */,\n      config\n        ? config\n        : maybeFilters\n          ? {filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)}\n          : undefined /* extra */,\n    );\n    return this._makeSubscription(\n      {\n        callback,\n        method: 'programSubscribe',\n        unsubscribeMethod: 'programUnsubscribe',\n      },\n      args,\n    );\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeProgramAccountChangeListener(\n    clientSubscriptionId: ClientSubscriptionId,\n  ): Promise<void> {\n    await this._unsubscribeClientSubscription(\n      clientSubscriptionId,\n      'program account change',\n    );\n  }\n\n  /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */\n  onLogs(\n    filter: LogsFilter,\n    callback: LogsCallback,\n    commitment?: Commitment,\n  ): ClientSubscriptionId {\n    const args = this._buildArgs(\n      [typeof filter === 'object' ? {mentions: [filter.toString()]} : filter],\n      commitment || this._commitment || 'finalized', // Apply connection/server default.\n    );\n    return this._makeSubscription(\n      {\n        callback,\n        method: 'logsSubscribe',\n        unsubscribeMethod: 'logsUnsubscribe',\n      },\n      args,\n    );\n  }\n\n  /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */\n  async removeOnLogsListener(\n    clientSubscriptionId: ClientSubscriptionId,\n  ): Promise<void> {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnLogsNotification(notification: Object) {\n    const {result, subscription} = create(notification, LogsNotificationResult);\n    this._handleServerNotification<LogsCallback>(subscription, [\n      result.value,\n      result.context,\n    ]);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSlotNotification(notification: Object) {\n    const {result, subscription} = create(notification, SlotNotificationResult);\n    this._handleServerNotification<SlotChangeCallback>(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */\n  onSlotChange(callback: SlotChangeCallback): ClientSubscriptionId {\n    return this._makeSubscription(\n      {\n        callback,\n        method: 'slotSubscribe',\n        unsubscribeMethod: 'slotUnsubscribe',\n      },\n      [] /* args */,\n    );\n  }\n\n  /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSlotChangeListener(\n    clientSubscriptionId: ClientSubscriptionId,\n  ): Promise<void> {\n    await this._unsubscribeClientSubscription(\n      clientSubscriptionId,\n      'slot change',\n    );\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSlotUpdatesNotification(notification: Object) {\n    const {result, subscription} = create(\n      notification,\n      SlotUpdateNotificationResult,\n    );\n    this._handleServerNotification<SlotUpdateCallback>(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */\n  onSlotUpdate(callback: SlotUpdateCallback): ClientSubscriptionId {\n    return this._makeSubscription(\n      {\n        callback,\n        method: 'slotsUpdatesSubscribe',\n        unsubscribeMethod: 'slotsUpdatesUnsubscribe',\n      },\n      [] /* args */,\n    );\n  }\n\n  /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSlotUpdateListener(\n    clientSubscriptionId: ClientSubscriptionId,\n  ): Promise<void> {\n    await this._unsubscribeClientSubscription(\n      clientSubscriptionId,\n      'slot update',\n    );\n  }\n\n  /**\n   * @internal\n   */\n\n  private async _unsubscribeClientSubscription(\n    clientSubscriptionId: ClientSubscriptionId,\n    subscriptionName: string,\n  ) {\n    const dispose =\n      this._subscriptionDisposeFunctionsByClientSubscriptionId[\n        clientSubscriptionId\n      ];\n    if (dispose) {\n      await dispose();\n    } else {\n      console.warn(\n        'Ignored unsubscribe request because an active subscription with id ' +\n          `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` +\n          'could not be found.',\n      );\n    }\n  }\n\n  _buildArgs(\n    args: Array<any>,\n    override?: Commitment,\n    encoding?: 'jsonParsed' | 'base64',\n    extra?: any,\n  ): Array<any> {\n    const commitment = override || this._commitment;\n    if (commitment || encoding || extra) {\n      let options: any = {};\n      if (encoding) {\n        options.encoding = encoding;\n      }\n      if (commitment) {\n        options.commitment = commitment;\n      }\n      if (extra) {\n        options = Object.assign(options, extra);\n      }\n      args.push(options);\n    }\n    return args;\n  }\n\n  /**\n   * @internal\n   */\n  _buildArgsAtLeastConfirmed(\n    args: Array<any>,\n    override?: Finality,\n    encoding?: 'jsonParsed' | 'base64',\n    extra?: any,\n  ): Array<any> {\n    const commitment = override || this._commitment;\n    if (commitment && !['confirmed', 'finalized'].includes(commitment)) {\n      throw new Error(\n        'Using Connection with default commitment: `' +\n          this._commitment +\n          '`, but method requires at least `confirmed`',\n      );\n    }\n    return this._buildArgs(args, override, encoding, extra);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSignatureNotification(notification: Object) {\n    const {result, subscription} = create(\n      notification,\n      SignatureNotificationResult,\n    );\n    if (result.value !== 'receivedSignature') {\n      /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */\n      this._subscriptionsAutoDisposedByRpc.add(subscription);\n    }\n    this._handleServerNotification<SignatureSubscriptionCallback>(\n      subscription,\n      result.value === 'receivedSignature'\n        ? [{type: 'received'}, result.context]\n        : [{type: 'status', result: result.value}, result.context],\n    );\n  }\n\n  /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */\n  onSignature(\n    signature: TransactionSignature,\n    callback: SignatureResultCallback,\n    commitment?: Commitment,\n  ): ClientSubscriptionId {\n    const args = this._buildArgs(\n      [signature],\n      commitment || this._commitment || 'finalized', // Apply connection/server default.\n    );\n    const clientSubscriptionId = this._makeSubscription(\n      {\n        callback: (notification, context) => {\n          if (notification.type === 'status') {\n            callback(notification.result, context);\n            // Signatures subscriptions are auto-removed by the RPC service\n            // so no need to explicitly send an unsubscribe message.\n            try {\n              this.removeSignatureListener(clientSubscriptionId);\n              // eslint-disable-next-line no-empty\n            } catch (_err) {\n              // Already removed.\n            }\n          }\n        },\n        method: 'signatureSubscribe',\n        unsubscribeMethod: 'signatureUnsubscribe',\n      },\n      args,\n    );\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */\n  onSignatureWithOptions(\n    signature: TransactionSignature,\n    callback: SignatureSubscriptionCallback,\n    options?: SignatureSubscriptionOptions,\n  ): ClientSubscriptionId {\n    const {commitment, ...extra} = {\n      ...options,\n      commitment:\n        (options && options.commitment) || this._commitment || 'finalized', // Apply connection/server default.\n    };\n    const args = this._buildArgs(\n      [signature],\n      commitment,\n      undefined /* encoding */,\n      extra,\n    );\n    const clientSubscriptionId = this._makeSubscription(\n      {\n        callback: (notification, context) => {\n          callback(notification, context);\n          // Signatures subscriptions are auto-removed by the RPC service\n          // so no need to explicitly send an unsubscribe message.\n          try {\n            this.removeSignatureListener(clientSubscriptionId);\n            // eslint-disable-next-line no-empty\n          } catch (_err) {\n            // Already removed.\n          }\n        },\n        method: 'signatureSubscribe',\n        unsubscribeMethod: 'signatureUnsubscribe',\n      },\n      args,\n    );\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSignatureListener(\n    clientSubscriptionId: ClientSubscriptionId,\n  ): Promise<void> {\n    await this._unsubscribeClientSubscription(\n      clientSubscriptionId,\n      'signature result',\n    );\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnRootNotification(notification: Object) {\n    const {result, subscription} = create(notification, RootNotificationResult);\n    this._handleServerNotification<RootChangeCallback>(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */\n  onRootChange(callback: RootChangeCallback): ClientSubscriptionId {\n    return this._makeSubscription(\n      {\n        callback,\n        method: 'rootSubscribe',\n        unsubscribeMethod: 'rootUnsubscribe',\n      },\n      [] /* args */,\n    );\n  }\n\n  /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeRootChangeListener(\n    clientSubscriptionId: ClientSubscriptionId,\n  ): Promise<void> {\n    await this._unsubscribeClientSubscription(\n      clientSubscriptionId,\n      'root change',\n    );\n  }\n}\n", "import {generateKeypair, getPublicKey, Ed25519Keypair} from './utils/ed25519';\nimport {PublicKey} from './publickey';\n\n/**\n * Keypair signer interface\n */\nexport interface Signer {\n  publicKey: PublicKey;\n  secretKey: Uint8Array;\n}\n\n/**\n * An account keypair used for signing transactions.\n */\nexport class Keypair {\n  private _keypair: Ed25519Keypair;\n\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */\n  constructor(keypair?: Ed25519Keypair) {\n    this._keypair = keypair ?? generateKeypair();\n  }\n\n  /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */\n  static generate(): Keypair {\n    return new Keypair(generateKeypair());\n  }\n\n  /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */\n  static fromSecretKey(\n    secretKey: Uint8Array,\n    options?: {skipValidation?: boolean},\n  ): Keypair {\n    if (secretKey.byteLength !== 64) {\n      throw new Error('bad secret key size');\n    }\n    const publicKey = secretKey.slice(32, 64);\n    if (!options || !options.skipValidation) {\n      const privateScalar = secretKey.slice(0, 32);\n      const computedPublicKey = getPublicKey(privateScalar);\n      for (let ii = 0; ii < 32; ii++) {\n        if (publicKey[ii] !== computedPublicKey[ii]) {\n          throw new Error('provided secretKey is invalid');\n        }\n      }\n    }\n    return new Keypair({publicKey, secretKey});\n  }\n\n  /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */\n  static fromSeed(seed: Uint8Array): Keypair {\n    const publicKey = getPublicKey(seed);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(seed);\n    secretKey.set(publicKey, 32);\n    return new Keypair({publicKey, secretKey});\n  }\n\n  /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */\n  get publicKey(): PublicKey {\n    return new PublicKey(this._keypair.publicKey);\n  }\n\n  /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */\n  get secretKey(): Uint8Array {\n    return new Uint8Array(this._keypair.secretKey);\n  }\n}\n", "import * as BufferLayout from '@solana/buffer-layout';\nimport {getU64Encoder} from '@solana/codecs-numbers';\n\nimport * as Layout from '../../layout';\nimport {PublicKey} from '../../publickey';\nimport * as bigintLayout from '../../utils/bigint';\nimport {SystemProgram} from '../system';\nimport {TransactionInstruction} from '../../transaction';\nimport {decodeData, encodeData, IInstructionInputData} from '../../instruction';\n\nexport * from './state';\n\nexport type CreateLookupTableParams = {\n  /** Account used to derive and control the new address lookup table. */\n  authority: PublicKey;\n  /** Account that will fund the new address lookup table. */\n  payer: PublicKey;\n  /** A recent slot must be used in the derivation path for each initialized table. */\n  recentSlot: bigint | number;\n};\n\nexport type FreezeLookupTableParams = {\n  /** Address lookup table account to freeze. */\n  lookupTable: PublicKey;\n  /** Account which is the current authority. */\n  authority: PublicKey;\n};\n\nexport type ExtendLookupTableParams = {\n  /** Address lookup table account to extend. */\n  lookupTable: PublicKey;\n  /** Account which is the current authority. */\n  authority: PublicKey;\n  /** Account that will fund the table reallocation.\n   * Not required if the reallocation has already been funded. */\n  payer?: PublicKey;\n  /** List of Public Keys to be added to the lookup table. */\n  addresses: Array<PublicKey>;\n};\n\nexport type DeactivateLookupTableParams = {\n  /** Address lookup table account to deactivate. */\n  lookupTable: PublicKey;\n  /** Account which is the current authority. */\n  authority: PublicKey;\n};\n\nexport type CloseLookupTableParams = {\n  /** Address lookup table account to close. */\n  lookupTable: PublicKey;\n  /** Account which is the current authority. */\n  authority: PublicKey;\n  /** Recipient of closed account lamports. */\n  recipient: PublicKey;\n};\n\n/**\n * An enumeration of valid LookupTableInstructionType's\n */\nexport type LookupTableInstructionType =\n  | 'CreateLookupTable'\n  | 'ExtendLookupTable'\n  | 'CloseLookupTable'\n  | 'FreezeLookupTable'\n  | 'DeactivateLookupTable';\n\ntype LookupTableInstructionInputData = {\n  CreateLookupTable: IInstructionInputData &\n    Readonly<{\n      recentSlot: bigint;\n      bumpSeed: number;\n    }>;\n  FreezeLookupTable: IInstructionInputData;\n  ExtendLookupTable: IInstructionInputData &\n    Readonly<{\n      numberOfAddresses: bigint;\n      addresses: Array<Uint8Array>;\n    }>;\n  DeactivateLookupTable: IInstructionInputData;\n  CloseLookupTable: IInstructionInputData;\n};\n\n/**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */\nexport const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n  CreateLookupTable: {\n    index: 0,\n    layout: BufferLayout.struct<\n      LookupTableInstructionInputData['CreateLookupTable']\n    >([\n      BufferLayout.u32('instruction'),\n      bigintLayout.u64('recentSlot'),\n      BufferLayout.u8('bumpSeed'),\n    ]),\n  },\n  FreezeLookupTable: {\n    index: 1,\n    layout: BufferLayout.struct<\n      LookupTableInstructionInputData['FreezeLookupTable']\n    >([BufferLayout.u32('instruction')]),\n  },\n  ExtendLookupTable: {\n    index: 2,\n    layout: BufferLayout.struct<\n      LookupTableInstructionInputData['ExtendLookupTable']\n    >([\n      BufferLayout.u32('instruction'),\n      bigintLayout.u64(),\n      BufferLayout.seq(\n        Layout.publicKey(),\n        BufferLayout.offset(BufferLayout.u32(), -8),\n        'addresses',\n      ),\n    ]),\n  },\n  DeactivateLookupTable: {\n    index: 3,\n    layout: BufferLayout.struct<\n      LookupTableInstructionInputData['DeactivateLookupTable']\n    >([BufferLayout.u32('instruction')]),\n  },\n  CloseLookupTable: {\n    index: 4,\n    layout: BufferLayout.struct<\n      LookupTableInstructionInputData['CloseLookupTable']\n    >([BufferLayout.u32('instruction')]),\n  },\n});\n\nexport class AddressLookupTableInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  static decodeInstructionType(\n    instruction: TransactionInstruction,\n  ): LookupTableInstructionType {\n    this.checkProgramId(instruction.programId);\n\n    const instructionTypeLayout = BufferLayout.u32('instruction');\n    const index = instructionTypeLayout.decode(instruction.data);\n\n    let type: LookupTableInstructionType | undefined;\n    for (const [layoutType, layout] of Object.entries(\n      LOOKUP_TABLE_INSTRUCTION_LAYOUTS,\n    )) {\n      if ((layout as any).index == index) {\n        type = layoutType as LookupTableInstructionType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error(\n        'Invalid Instruction. Should be a LookupTable Instruction',\n      );\n    }\n    return type;\n  }\n\n  static decodeCreateLookupTable(\n    instruction: TransactionInstruction,\n  ): CreateLookupTableParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 4);\n\n    const {recentSlot} = decodeData(\n      LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable,\n      instruction.data,\n    );\n\n    return {\n      authority: instruction.keys[1].pubkey,\n      payer: instruction.keys[2].pubkey,\n      recentSlot: Number(recentSlot),\n    };\n  }\n\n  static decodeExtendLookupTable(\n    instruction: TransactionInstruction,\n  ): ExtendLookupTableParams {\n    this.checkProgramId(instruction.programId);\n    if (instruction.keys.length < 2) {\n      throw new Error(\n        `invalid instruction; found ${instruction.keys.length} keys, expected at least 2`,\n      );\n    }\n\n    const {addresses} = decodeData(\n      LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable,\n      instruction.data,\n    );\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey,\n      payer:\n        instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n      addresses: addresses.map(buffer => new PublicKey(buffer)),\n    };\n  }\n\n  static decodeCloseLookupTable(\n    instruction: TransactionInstruction,\n  ): CloseLookupTableParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 3);\n\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey,\n      recipient: instruction.keys[2].pubkey,\n    };\n  }\n\n  static decodeFreezeLookupTable(\n    instruction: TransactionInstruction,\n  ): FreezeLookupTableParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 2);\n\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey,\n    };\n  }\n\n  static decodeDeactivateLookupTable(\n    instruction: TransactionInstruction,\n  ): DeactivateLookupTableParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 2);\n\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey,\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId: PublicKey) {\n    if (!programId.equals(AddressLookupTableProgram.programId)) {\n      throw new Error(\n        'invalid instruction; programId is not AddressLookupTable Program',\n      );\n    }\n  }\n  /**\n   * @internal\n   */\n  static checkKeysLength(keys: Array<any>, expectedLength: number) {\n    if (keys.length < expectedLength) {\n      throw new Error(\n        `invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`,\n      );\n    }\n  }\n}\n\nexport class AddressLookupTableProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  static programId: PublicKey = new PublicKey(\n    'AddressLookupTab1e1111111111111111111111111',\n  );\n\n  static createLookupTable(params: CreateLookupTableParams) {\n    const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync(\n      [\n        params.authority.toBuffer(),\n        getU64Encoder().encode(params.recentSlot) as Uint8Array,\n      ],\n      this.programId,\n    );\n\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n    const data = encodeData(type, {\n      recentSlot: BigInt(params.recentSlot),\n      bumpSeed: bumpSeed,\n    });\n\n    const keys = [\n      {\n        pubkey: lookupTableAddress,\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: params.payer,\n        isSigner: true,\n        isWritable: true,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n\n    return [\n      new TransactionInstruction({\n        programId: this.programId,\n        keys: keys,\n        data: data,\n      }),\n      lookupTableAddress,\n    ] as [TransactionInstruction, PublicKey];\n  }\n\n  static freezeLookupTable(params: FreezeLookupTableParams) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n    const data = encodeData(type);\n\n    const keys = [\n      {\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false,\n      },\n    ];\n\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data,\n    });\n  }\n\n  static extendLookupTable(params: ExtendLookupTableParams) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n    const data = encodeData(type, {\n      addresses: params.addresses.map(addr => addr.toBytes()),\n    });\n\n    const keys = [\n      {\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false,\n      },\n    ];\n\n    if (params.payer) {\n      keys.push(\n        {\n          pubkey: params.payer,\n          isSigner: true,\n          isWritable: true,\n        },\n        {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false,\n        },\n      );\n    }\n\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data,\n    });\n  }\n\n  static deactivateLookupTable(params: DeactivateLookupTableParams) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n    const data = encodeData(type);\n\n    const keys = [\n      {\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false,\n      },\n    ];\n\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data,\n    });\n  }\n\n  static closeLookupTable(params: CloseLookupTableParams) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n    const data = encodeData(type);\n\n    const keys = [\n      {\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: params.recipient,\n        isSigner: false,\n        isWritable: true,\n      },\n    ];\n\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data,\n    });\n  }\n}\n", "import * as BufferLayout from '@solana/buffer-layout';\n\nimport {\n  encodeData,\n  decodeData,\n  InstructionType,\n  IInstructionInputData,\n} from '../instruction';\nimport {PublicKey} from '../publickey';\nimport {TransactionInstruction} from '../transaction';\nimport {u64} from '../utils/bigint';\n\n/**\n * Compute Budget Instruction class\n */\nexport class ComputeBudgetInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(\n    instruction: TransactionInstruction,\n  ): ComputeBudgetInstructionType {\n    this.checkProgramId(instruction.programId);\n\n    const instructionTypeLayout = BufferLayout.u8('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n\n    let type: ComputeBudgetInstructionType | undefined;\n    for (const [ixType, layout] of Object.entries(\n      COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,\n    )) {\n      if (layout.index == typeIndex) {\n        type = ixType as ComputeBudgetInstructionType;\n        break;\n      }\n    }\n\n    if (!type) {\n      throw new Error(\n        'Instruction type incorrect; not a ComputeBudgetInstruction',\n      );\n    }\n\n    return type;\n  }\n\n  /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */\n  static decodeRequestUnits(\n    instruction: TransactionInstruction,\n  ): RequestUnitsParams {\n    this.checkProgramId(instruction.programId);\n    const {units, additionalFee} = decodeData(\n      COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits,\n      instruction.data,\n    );\n    return {units, additionalFee};\n  }\n\n  /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */\n  static decodeRequestHeapFrame(\n    instruction: TransactionInstruction,\n  ): RequestHeapFrameParams {\n    this.checkProgramId(instruction.programId);\n    const {bytes} = decodeData(\n      COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame,\n      instruction.data,\n    );\n    return {bytes};\n  }\n\n  /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */\n  static decodeSetComputeUnitLimit(\n    instruction: TransactionInstruction,\n  ): SetComputeUnitLimitParams {\n    this.checkProgramId(instruction.programId);\n    const {units} = decodeData(\n      COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit,\n      instruction.data,\n    );\n    return {units};\n  }\n\n  /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */\n  static decodeSetComputeUnitPrice(\n    instruction: TransactionInstruction,\n  ): SetComputeUnitPriceParams {\n    this.checkProgramId(instruction.programId);\n    const {microLamports} = decodeData(\n      COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice,\n      instruction.data,\n    );\n    return {microLamports};\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId: PublicKey) {\n    if (!programId.equals(ComputeBudgetProgram.programId)) {\n      throw new Error(\n        'invalid instruction; programId is not ComputeBudgetProgram',\n      );\n    }\n  }\n}\n\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */\nexport type ComputeBudgetInstructionType =\n  // FIXME\n  // It would be preferable for this type to be `keyof ComputeBudgetInstructionInputData`\n  // but Typedoc does not transpile `keyof` expressions.\n  // See https://github.com/TypeStrong/typedoc/issues/1894\n  | 'RequestUnits'\n  | 'RequestHeapFrame'\n  | 'SetComputeUnitLimit'\n  | 'SetComputeUnitPrice';\n\ntype ComputeBudgetInstructionInputData = {\n  RequestUnits: IInstructionInputData & Readonly<RequestUnitsParams>;\n  RequestHeapFrame: IInstructionInputData & Readonly<RequestHeapFrameParams>;\n  SetComputeUnitLimit: IInstructionInputData &\n    Readonly<SetComputeUnitLimitParams>;\n  SetComputeUnitPrice: IInstructionInputData &\n    Readonly<SetComputeUnitPriceParams>;\n};\n\n/**\n * Request units instruction params\n */\nexport interface RequestUnitsParams {\n  /** Units to request for transaction-wide compute */\n  units: number;\n  /** Prioritization fee lamports */\n  additionalFee: number;\n}\n\n/**\n * Request heap frame instruction params\n */\nexport type RequestHeapFrameParams = {\n  /** Requested transaction-wide program heap size in bytes. Must be multiple of 1024. Applies to each program, including CPIs. */\n  bytes: number;\n};\n\n/**\n * Set compute unit limit instruction params\n */\nexport interface SetComputeUnitLimitParams {\n  /** Transaction-wide compute unit limit */\n  units: number;\n}\n\n/**\n * Set compute unit price instruction params\n */\nexport interface SetComputeUnitPriceParams {\n  /** Transaction compute unit price used for prioritization fees */\n  microLamports: number | bigint;\n}\n\n/**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */\nexport const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze<{\n  [Instruction in ComputeBudgetInstructionType]: InstructionType<\n    ComputeBudgetInstructionInputData[Instruction]\n  >;\n}>({\n  RequestUnits: {\n    index: 0,\n    layout: BufferLayout.struct<\n      ComputeBudgetInstructionInputData['RequestUnits']\n    >([\n      BufferLayout.u8('instruction'),\n      BufferLayout.u32('units'),\n      BufferLayout.u32('additionalFee'),\n    ]),\n  },\n  RequestHeapFrame: {\n    index: 1,\n    layout: BufferLayout.struct<\n      ComputeBudgetInstructionInputData['RequestHeapFrame']\n    >([BufferLayout.u8('instruction'), BufferLayout.u32('bytes')]),\n  },\n  SetComputeUnitLimit: {\n    index: 2,\n    layout: BufferLayout.struct<\n      ComputeBudgetInstructionInputData['SetComputeUnitLimit']\n    >([BufferLayout.u8('instruction'), BufferLayout.u32('units')]),\n  },\n  SetComputeUnitPrice: {\n    index: 3,\n    layout: BufferLayout.struct<\n      ComputeBudgetInstructionInputData['SetComputeUnitPrice']\n    >([BufferLayout.u8('instruction'), u64('microLamports')]),\n  },\n});\n\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */\nexport class ComputeBudgetProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Compute Budget program\n   */\n  static programId: PublicKey = new PublicKey(\n    'ComputeBudget111111111111111111111111111111',\n  );\n\n  /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */\n  static requestUnits(params: RequestUnitsParams): TransactionInstruction {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  static requestHeapFrame(\n    params: RequestHeapFrameParams,\n  ): TransactionInstruction {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  static setComputeUnitLimit(\n    params: SetComputeUnitLimitParams,\n  ): TransactionInstruction {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  static setComputeUnitPrice(\n    params: SetComputeUnitPriceParams,\n  ): TransactionInstruction {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n    const data = encodeData(type, {\n      microLamports: BigInt(params.microLamports),\n    });\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data,\n    });\n  }\n}\n", "import {Buffer} from 'buffer';\nimport * as BufferLayout from '@solana/buffer-layout';\n\nimport {Keypair} from '../keypair';\nimport {PublicKey} from '../publickey';\nimport {TransactionInstruction} from '../transaction';\nimport assert from '../utils/assert';\nimport {sign} from '../utils/ed25519';\n\nconst PRIVATE_KEY_BYTES = 64;\nconst PUBLIC_KEY_BYTES = 32;\nconst SIGNATURE_BYTES = 64;\n\n/**\n * Params for creating an ed25519 instruction using a public key\n */\nexport type CreateEd25519InstructionWithPublicKeyParams = {\n  publicKey: Uint8Array;\n  message: Uint8Array;\n  signature: Uint8Array;\n  instructionIndex?: number;\n};\n\n/**\n * Params for creating an ed25519 instruction using a private key\n */\nexport type CreateEd25519InstructionWithPrivateKeyParams = {\n  privateKey: Uint8Array;\n  message: Uint8Array;\n  instructionIndex?: number;\n};\n\nconst ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct<\n  Readonly<{\n    messageDataOffset: number;\n    messageDataSize: number;\n    messageInstructionIndex: number;\n    numSignatures: number;\n    padding: number;\n    publicKeyInstructionIndex: number;\n    publicKeyOffset: number;\n    signatureInstructionIndex: number;\n    signatureOffset: number;\n  }>\n>([\n  BufferLayout.u8('numSignatures'),\n  BufferLayout.u8('padding'),\n  BufferLayout.u16('signatureOffset'),\n  BufferLayout.u16('signatureInstructionIndex'),\n  BufferLayout.u16('publicKeyOffset'),\n  BufferLayout.u16('publicKeyInstructionIndex'),\n  BufferLayout.u16('messageDataOffset'),\n  BufferLayout.u16('messageDataSize'),\n  BufferLayout.u16('messageInstructionIndex'),\n]);\n\nexport class Ed25519Program {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the ed25519 program\n   */\n  static programId: PublicKey = new PublicKey(\n    'Ed25519SigVerify111111111111111111111111111',\n  );\n\n  /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */\n  static createInstructionWithPublicKey(\n    params: CreateEd25519InstructionWithPublicKeyParams,\n  ): TransactionInstruction {\n    const {publicKey, message, signature, instructionIndex} = params;\n\n    assert(\n      publicKey.length === PUBLIC_KEY_BYTES,\n      `Public Key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`,\n    );\n\n    assert(\n      signature.length === SIGNATURE_BYTES,\n      `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`,\n    );\n\n    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n    const signatureOffset = publicKeyOffset + publicKey.length;\n    const messageDataOffset = signatureOffset + signature.length;\n    const numSignatures = 1;\n\n    const instructionData = Buffer.alloc(messageDataOffset + message.length);\n\n    const index =\n      instructionIndex == null\n        ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n        : instructionIndex;\n\n    ED25519_INSTRUCTION_LAYOUT.encode(\n      {\n        numSignatures,\n        padding: 0,\n        signatureOffset,\n        signatureInstructionIndex: index,\n        publicKeyOffset,\n        publicKeyInstructionIndex: index,\n        messageDataOffset,\n        messageDataSize: message.length,\n        messageInstructionIndex: index,\n      },\n      instructionData,\n    );\n\n    instructionData.fill(publicKey, publicKeyOffset);\n    instructionData.fill(signature, signatureOffset);\n    instructionData.fill(message, messageDataOffset);\n\n    return new TransactionInstruction({\n      keys: [],\n      programId: Ed25519Program.programId,\n      data: instructionData,\n    });\n  }\n\n  /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */\n  static createInstructionWithPrivateKey(\n    params: CreateEd25519InstructionWithPrivateKeyParams,\n  ): TransactionInstruction {\n    const {privateKey, message, instructionIndex} = params;\n\n    assert(\n      privateKey.length === PRIVATE_KEY_BYTES,\n      `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${privateKey.length} bytes`,\n    );\n\n    try {\n      const keypair = Keypair.fromSecretKey(privateKey);\n      const publicKey = keypair.publicKey.toBytes();\n      const signature = sign(message, keypair.secretKey);\n\n      return this.createInstructionWithPublicKey({\n        publicKey,\n        message,\n        signature,\n        instructionIndex,\n      });\n    } catch (error) {\n      throw new Error(`Error creating instruction; ${error}`);\n    }\n  }\n}\n", "import {secp256k1} from '@noble/curves/secp256k1';\n\nexport const ecdsaSign = (\n  msgHash: Parameters<typeof secp256k1.sign>[0],\n  privKey: Parameters<typeof secp256k1.sign>[1],\n) => {\n  const signature = secp256k1.sign(msgHash, privKey);\n  return [signature.toCompactRawBytes(), signature.recovery!] as const;\n};\nexport const isValidPrivateKey = secp256k1.utils.isValidPrivateKey;\nexport const publicKeyCreate = secp256k1.getPublicKey;\n", "import {Buffer} from 'buffer';\nimport * as BufferLayout from '@solana/buffer-layout';\nimport {keccak_256} from '@noble/hashes/sha3';\n\nimport {PublicKey} from '../publickey';\nimport {TransactionInstruction} from '../transaction';\nimport assert from '../utils/assert';\nimport {publicKeyCreate, ecdsaSign} from '../utils/secp256k1';\nimport {toBuffer} from '../utils/to-buffer';\n\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n\n/**\n * Params for creating an secp256k1 instruction using a public key\n */\nexport type CreateSecp256k1InstructionWithPublicKeyParams = {\n  publicKey: Buffer | Uint8Array | Array<number>;\n  message: Buffer | Uint8Array | Array<number>;\n  signature: Buffer | Uint8Array | Array<number>;\n  recoveryId: number;\n  instructionIndex?: number;\n};\n\n/**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */\nexport type CreateSecp256k1InstructionWithEthAddressParams = {\n  ethAddress: Buffer | Uint8Array | Array<number> | string;\n  message: Buffer | Uint8Array | Array<number>;\n  signature: Buffer | Uint8Array | Array<number>;\n  recoveryId: number;\n  instructionIndex?: number;\n};\n\n/**\n * Params for creating an secp256k1 instruction using a private key\n */\nexport type CreateSecp256k1InstructionWithPrivateKeyParams = {\n  privateKey: Buffer | Uint8Array | Array<number>;\n  message: Buffer | Uint8Array | Array<number>;\n  instructionIndex?: number;\n};\n\nconst SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct<\n  Readonly<{\n    ethAddress: Uint8Array;\n    ethAddressInstructionIndex: number;\n    ethAddressOffset: number;\n    messageDataOffset: number;\n    messageDataSize: number;\n    messageInstructionIndex: number;\n    numSignatures: number;\n    recoveryId: number;\n    signature: Uint8Array;\n    signatureInstructionIndex: number;\n    signatureOffset: number;\n  }>\n>([\n  BufferLayout.u8('numSignatures'),\n  BufferLayout.u16('signatureOffset'),\n  BufferLayout.u8('signatureInstructionIndex'),\n  BufferLayout.u16('ethAddressOffset'),\n  BufferLayout.u8('ethAddressInstructionIndex'),\n  BufferLayout.u16('messageDataOffset'),\n  BufferLayout.u16('messageDataSize'),\n  BufferLayout.u8('messageInstructionIndex'),\n  BufferLayout.blob(20, 'ethAddress'),\n  BufferLayout.blob(64, 'signature'),\n  BufferLayout.u8('recoveryId'),\n]);\n\nexport class Secp256k1Program {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the secp256k1 program\n   */\n  static programId: PublicKey = new PublicKey(\n    'KeccakSecp256k11111111111111111111111111111',\n  );\n\n  /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */\n  static publicKeyToEthAddress(\n    publicKey: Buffer | Uint8Array | Array<number>,\n  ): Buffer {\n    assert(\n      publicKey.length === PUBLIC_KEY_BYTES,\n      `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`,\n    );\n\n    try {\n      return Buffer.from(keccak_256(toBuffer(publicKey))).slice(\n        -ETHEREUM_ADDRESS_BYTES,\n      );\n    } catch (error) {\n      throw new Error(`Error constructing Ethereum address: ${error}`);\n    }\n  }\n\n  /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */\n  static createInstructionWithPublicKey(\n    params: CreateSecp256k1InstructionWithPublicKeyParams,\n  ): TransactionInstruction {\n    const {publicKey, message, signature, recoveryId, instructionIndex} =\n      params;\n    return Secp256k1Program.createInstructionWithEthAddress({\n      ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n      message,\n      signature,\n      recoveryId,\n      instructionIndex,\n    });\n  }\n\n  /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */\n  static createInstructionWithEthAddress(\n    params: CreateSecp256k1InstructionWithEthAddressParams,\n  ): TransactionInstruction {\n    const {\n      ethAddress: rawAddress,\n      message,\n      signature,\n      recoveryId,\n      instructionIndex = 0,\n    } = params;\n\n    let ethAddress;\n    if (typeof rawAddress === 'string') {\n      if (rawAddress.startsWith('0x')) {\n        ethAddress = Buffer.from(rawAddress.substr(2), 'hex');\n      } else {\n        ethAddress = Buffer.from(rawAddress, 'hex');\n      }\n    } else {\n      ethAddress = rawAddress;\n    }\n\n    assert(\n      ethAddress.length === ETHEREUM_ADDRESS_BYTES,\n      `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`,\n    );\n\n    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n    const ethAddressOffset = dataStart;\n    const signatureOffset = dataStart + ethAddress.length;\n    const messageDataOffset = signatureOffset + signature.length + 1;\n    const numSignatures = 1;\n\n    const instructionData = Buffer.alloc(\n      SECP256K1_INSTRUCTION_LAYOUT.span + message.length,\n    );\n\n    SECP256K1_INSTRUCTION_LAYOUT.encode(\n      {\n        numSignatures,\n        signatureOffset,\n        signatureInstructionIndex: instructionIndex,\n        ethAddressOffset,\n        ethAddressInstructionIndex: instructionIndex,\n        messageDataOffset,\n        messageDataSize: message.length,\n        messageInstructionIndex: instructionIndex,\n        signature: toBuffer(signature),\n        ethAddress: toBuffer(ethAddress),\n        recoveryId,\n      },\n      instructionData,\n    );\n\n    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n\n    return new TransactionInstruction({\n      keys: [],\n      programId: Secp256k1Program.programId,\n      data: instructionData,\n    });\n  }\n\n  /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */\n  static createInstructionWithPrivateKey(\n    params: CreateSecp256k1InstructionWithPrivateKeyParams,\n  ): TransactionInstruction {\n    const {privateKey: pkey, message, instructionIndex} = params;\n\n    assert(\n      pkey.length === PRIVATE_KEY_BYTES,\n      `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`,\n    );\n\n    try {\n      const privateKey = toBuffer(pkey);\n      const publicKey = publicKeyCreate(\n        privateKey,\n        false /* isCompressed */,\n      ).slice(1); // throw away leading byte\n      const messageHash = Buffer.from(keccak_256(toBuffer(message)));\n      const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n\n      return this.createInstructionWithPublicKey({\n        publicKey,\n        message,\n        signature,\n        recoveryId,\n        instructionIndex,\n      });\n    } catch (error) {\n      throw new Error(`Error creating instruction; ${error}`);\n    }\n  }\n}\n", "import * as BufferLayout from '@solana/buffer-layout';\n\nimport {\n  encodeData,\n  decodeData,\n  InstructionType,\n  IInstructionInputData,\n} from '../instruction';\nimport * as Layout from '../layout';\nimport {PublicKey} from '../publickey';\nimport {SystemProgram} from './system';\nimport {\n  SYSVAR_CLOCK_PUBKEY,\n  SYSVAR_RENT_PUBKEY,\n  SYSVAR_STAKE_HISTORY_PUBKEY,\n} from '../sysvar';\nimport {Transaction, TransactionInstruction} from '../transaction';\nimport {toBuffer} from '../utils/to-buffer';\n\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */\nexport const STAKE_CONFIG_ID = new PublicKey(\n  'StakeConfig11111111111111111111111111111111',\n);\n\n/**\n * Stake account authority info\n */\nexport class Authorized {\n  /** stake authority */\n  staker: PublicKey;\n  /** withdraw authority */\n  withdrawer: PublicKey;\n\n  /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */\n  constructor(staker: PublicKey, withdrawer: PublicKey) {\n    this.staker = staker;\n    this.withdrawer = withdrawer;\n  }\n}\n\ntype AuthorizedRaw = Readonly<{\n  staker: Uint8Array;\n  withdrawer: Uint8Array;\n}>;\n\n/**\n * Stake account lockup info\n */\nexport class Lockup {\n  /** Unix timestamp of lockup expiration */\n  unixTimestamp: number;\n  /** Epoch of lockup expiration */\n  epoch: number;\n  /** Lockup custodian authority */\n  custodian: PublicKey;\n\n  /**\n   * Create a new Lockup object\n   */\n  constructor(unixTimestamp: number, epoch: number, custodian: PublicKey) {\n    this.unixTimestamp = unixTimestamp;\n    this.epoch = epoch;\n    this.custodian = custodian;\n  }\n\n  /**\n   * Default, inactive Lockup value\n   */\n  static default: Lockup = new Lockup(0, 0, PublicKey.default);\n}\n\ntype LockupRaw = Readonly<{\n  custodian: Uint8Array;\n  epoch: number;\n  unixTimestamp: number;\n}>;\n\n/**\n * Create stake account transaction params\n */\nexport type CreateStakeAccountParams = {\n  /** Address of the account which will fund creation */\n  fromPubkey: PublicKey;\n  /** Address of the new stake account */\n  stakePubkey: PublicKey;\n  /** Authorities of the new stake account */\n  authorized: Authorized;\n  /** Lockup of the new stake account */\n  lockup?: Lockup;\n  /** Funding amount */\n  lamports: number;\n};\n\n/**\n * Create stake account with seed transaction params\n */\nexport type CreateStakeAccountWithSeedParams = {\n  fromPubkey: PublicKey;\n  stakePubkey: PublicKey;\n  basePubkey: PublicKey;\n  seed: string;\n  authorized: Authorized;\n  lockup?: Lockup;\n  lamports: number;\n};\n\n/**\n * Initialize stake instruction params\n */\nexport type InitializeStakeParams = {\n  stakePubkey: PublicKey;\n  authorized: Authorized;\n  lockup?: Lockup;\n};\n\n/**\n * Delegate stake instruction params\n */\nexport type DelegateStakeParams = {\n  stakePubkey: PublicKey;\n  authorizedPubkey: PublicKey;\n  votePubkey: PublicKey;\n};\n\n/**\n * Authorize stake instruction params\n */\nexport type AuthorizeStakeParams = {\n  stakePubkey: PublicKey;\n  authorizedPubkey: PublicKey;\n  newAuthorizedPubkey: PublicKey;\n  stakeAuthorizationType: StakeAuthorizationType;\n  custodianPubkey?: PublicKey;\n};\n\n/**\n * Authorize stake instruction params using a derived key\n */\nexport type AuthorizeWithSeedStakeParams = {\n  stakePubkey: PublicKey;\n  authorityBase: PublicKey;\n  authoritySeed: string;\n  authorityOwner: PublicKey;\n  newAuthorizedPubkey: PublicKey;\n  stakeAuthorizationType: StakeAuthorizationType;\n  custodianPubkey?: PublicKey;\n};\n\n/**\n * Split stake instruction params\n */\nexport type SplitStakeParams = {\n  stakePubkey: PublicKey;\n  authorizedPubkey: PublicKey;\n  splitStakePubkey: PublicKey;\n  lamports: number;\n};\n\n/**\n * Split with seed transaction params\n */\nexport type SplitStakeWithSeedParams = {\n  stakePubkey: PublicKey;\n  authorizedPubkey: PublicKey;\n  splitStakePubkey: PublicKey;\n  basePubkey: PublicKey;\n  seed: string;\n  lamports: number;\n};\n\n/**\n * Withdraw stake instruction params\n */\nexport type WithdrawStakeParams = {\n  stakePubkey: PublicKey;\n  authorizedPubkey: PublicKey;\n  toPubkey: PublicKey;\n  lamports: number;\n  custodianPubkey?: PublicKey;\n};\n\n/**\n * Deactivate stake instruction params\n */\nexport type DeactivateStakeParams = {\n  stakePubkey: PublicKey;\n  authorizedPubkey: PublicKey;\n};\n\n/**\n * Merge stake instruction params\n */\nexport type MergeStakeParams = {\n  stakePubkey: PublicKey;\n  sourceStakePubKey: PublicKey;\n  authorizedPubkey: PublicKey;\n};\n\n/**\n * Stake Instruction class\n */\nexport class StakeInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(\n    instruction: TransactionInstruction,\n  ): StakeInstructionType {\n    this.checkProgramId(instruction.programId);\n\n    const instructionTypeLayout = BufferLayout.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n\n    let type: StakeInstructionType | undefined;\n    for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType as StakeInstructionType;\n        break;\n      }\n    }\n\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a StakeInstruction');\n    }\n\n    return type;\n  }\n\n  /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */\n  static decodeInitialize(\n    instruction: TransactionInstruction,\n  ): InitializeStakeParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n\n    const {authorized, lockup} = decodeData(\n      STAKE_INSTRUCTION_LAYOUTS.Initialize,\n      instruction.data,\n    );\n\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorized: new Authorized(\n        new PublicKey(authorized.staker),\n        new PublicKey(authorized.withdrawer),\n      ),\n      lockup: new Lockup(\n        lockup.unixTimestamp,\n        lockup.epoch,\n        new PublicKey(lockup.custodian),\n      ),\n    };\n  }\n\n  /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */\n  static decodeDelegate(\n    instruction: TransactionInstruction,\n  ): DelegateStakeParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 6);\n    decodeData(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      votePubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[5].pubkey,\n    };\n  }\n\n  /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */\n  static decodeAuthorize(\n    instruction: TransactionInstruction,\n  ): AuthorizeStakeParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {newAuthorized, stakeAuthorizationType} = decodeData(\n      STAKE_INSTRUCTION_LAYOUTS.Authorize,\n      instruction.data,\n    );\n\n    const o: AuthorizeStakeParams = {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      stakeAuthorizationType: {\n        index: stakeAuthorizationType,\n      },\n    };\n    if (instruction.keys.length > 3) {\n      o.custodianPubkey = instruction.keys[3].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */\n  static decodeAuthorizeWithSeed(\n    instruction: TransactionInstruction,\n  ): AuthorizeWithSeedStakeParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n\n    const {\n      newAuthorized,\n      stakeAuthorizationType,\n      authoritySeed,\n      authorityOwner,\n    } = decodeData(\n      STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,\n      instruction.data,\n    );\n\n    const o: AuthorizeWithSeedStakeParams = {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorityBase: instruction.keys[1].pubkey,\n      authoritySeed: authoritySeed,\n      authorityOwner: new PublicKey(authorityOwner),\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      stakeAuthorizationType: {\n        index: stakeAuthorizationType,\n      },\n    };\n    if (instruction.keys.length > 3) {\n      o.custodianPubkey = instruction.keys[3].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */\n  static decodeSplit(instruction: TransactionInstruction): SplitStakeParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {lamports} = decodeData(\n      STAKE_INSTRUCTION_LAYOUTS.Split,\n      instruction.data,\n    );\n\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      splitStakePubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey,\n      lamports,\n    };\n  }\n\n  /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */\n  static decodeMerge(instruction: TransactionInstruction): MergeStakeParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    decodeData(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      sourceStakePubKey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[4].pubkey,\n    };\n  }\n\n  /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */\n  static decodeWithdraw(\n    instruction: TransactionInstruction,\n  ): WithdrawStakeParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 5);\n    const {lamports} = decodeData(\n      STAKE_INSTRUCTION_LAYOUTS.Withdraw,\n      instruction.data,\n    );\n\n    const o: WithdrawStakeParams = {\n      stakePubkey: instruction.keys[0].pubkey,\n      toPubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[4].pubkey,\n      lamports,\n    };\n    if (instruction.keys.length > 5) {\n      o.custodianPubkey = instruction.keys[5].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */\n  static decodeDeactivate(\n    instruction: TransactionInstruction,\n  ): DeactivateStakeParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    decodeData(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey,\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId: PublicKey) {\n    if (!programId.equals(StakeProgram.programId)) {\n      throw new Error('invalid instruction; programId is not StakeProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys: Array<any>, expectedLength: number) {\n    if (keys.length < expectedLength) {\n      throw new Error(\n        `invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`,\n      );\n    }\n  }\n}\n\n/**\n * An enumeration of valid StakeInstructionType's\n */\nexport type StakeInstructionType =\n  // FIXME\n  // It would be preferable for this type to be `keyof StakeInstructionInputData`\n  // but Typedoc does not transpile `keyof` expressions.\n  // See https://github.com/TypeStrong/typedoc/issues/1894\n  | 'Authorize'\n  | 'AuthorizeWithSeed'\n  | 'Deactivate'\n  | 'Delegate'\n  | 'Initialize'\n  | 'Merge'\n  | 'Split'\n  | 'Withdraw';\n\ntype StakeInstructionInputData = {\n  Authorize: IInstructionInputData &\n    Readonly<{\n      newAuthorized: Uint8Array;\n      stakeAuthorizationType: number;\n    }>;\n  AuthorizeWithSeed: IInstructionInputData &\n    Readonly<{\n      authorityOwner: Uint8Array;\n      authoritySeed: string;\n      instruction: number;\n      newAuthorized: Uint8Array;\n      stakeAuthorizationType: number;\n    }>;\n  Deactivate: IInstructionInputData;\n  Delegate: IInstructionInputData;\n  Initialize: IInstructionInputData &\n    Readonly<{\n      authorized: AuthorizedRaw;\n      lockup: LockupRaw;\n    }>;\n  Merge: IInstructionInputData;\n  Split: IInstructionInputData &\n    Readonly<{\n      lamports: number;\n    }>;\n  Withdraw: IInstructionInputData &\n    Readonly<{\n      lamports: number;\n    }>;\n};\n\n/**\n * An enumeration of valid stake InstructionType's\n * @internal\n */\nexport const STAKE_INSTRUCTION_LAYOUTS = Object.freeze<{\n  [Instruction in StakeInstructionType]: InstructionType<\n    StakeInstructionInputData[Instruction]\n  >;\n}>({\n  Initialize: {\n    index: 0,\n    layout: BufferLayout.struct<StakeInstructionInputData['Initialize']>([\n      BufferLayout.u32('instruction'),\n      Layout.authorized(),\n      Layout.lockup(),\n    ]),\n  },\n  Authorize: {\n    index: 1,\n    layout: BufferLayout.struct<StakeInstructionInputData['Authorize']>([\n      BufferLayout.u32('instruction'),\n      Layout.publicKey('newAuthorized'),\n      BufferLayout.u32('stakeAuthorizationType'),\n    ]),\n  },\n  Delegate: {\n    index: 2,\n    layout: BufferLayout.struct<StakeInstructionInputData['Delegate']>([\n      BufferLayout.u32('instruction'),\n    ]),\n  },\n  Split: {\n    index: 3,\n    layout: BufferLayout.struct<StakeInstructionInputData['Split']>([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('lamports'),\n    ]),\n  },\n  Withdraw: {\n    index: 4,\n    layout: BufferLayout.struct<StakeInstructionInputData['Withdraw']>([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('lamports'),\n    ]),\n  },\n  Deactivate: {\n    index: 5,\n    layout: BufferLayout.struct<StakeInstructionInputData['Deactivate']>([\n      BufferLayout.u32('instruction'),\n    ]),\n  },\n  Merge: {\n    index: 7,\n    layout: BufferLayout.struct<StakeInstructionInputData['Merge']>([\n      BufferLayout.u32('instruction'),\n    ]),\n  },\n  AuthorizeWithSeed: {\n    index: 8,\n    layout: BufferLayout.struct<StakeInstructionInputData['AuthorizeWithSeed']>(\n      [\n        BufferLayout.u32('instruction'),\n        Layout.publicKey('newAuthorized'),\n        BufferLayout.u32('stakeAuthorizationType'),\n        Layout.rustString('authoritySeed'),\n        Layout.publicKey('authorityOwner'),\n      ],\n    ),\n  },\n});\n\n/**\n * Stake authorization type\n */\nexport type StakeAuthorizationType = {\n  /** The Stake Authorization index (from solana-stake-program) */\n  index: number;\n};\n\n/**\n * An enumeration of valid StakeAuthorizationLayout's\n */\nexport const StakeAuthorizationLayout = Object.freeze({\n  Staker: {\n    index: 0,\n  },\n  Withdrawer: {\n    index: 1,\n  },\n});\n\n/**\n * Factory class for transactions to interact with the Stake program\n */\nexport class StakeProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Stake program\n   */\n  static programId: PublicKey = new PublicKey(\n    'Stake11111111111111111111111111111111111111',\n  );\n\n  /**\n   * Max space of a Stake account\n   *\n   * This is generated from the solana-stake-program StakeState struct as\n   * `StakeStateV2::size_of()`:\n   * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n   */\n  static space: number = 200;\n\n  /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */\n  static initialize(params: InitializeStakeParams): TransactionInstruction {\n    const {stakePubkey, authorized, lockup: maybeLockup} = params;\n    const lockup: Lockup = maybeLockup || Lockup.default;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n    const data = encodeData(type, {\n      authorized: {\n        staker: toBuffer(authorized.staker.toBuffer()),\n        withdrawer: toBuffer(authorized.withdrawer.toBuffer()),\n      },\n      lockup: {\n        unixTimestamp: lockup.unixTimestamp,\n        epoch: lockup.epoch,\n        custodian: toBuffer(lockup.custodian.toBuffer()),\n      },\n    });\n    const instructionData = {\n      keys: [\n        {pubkey: stakePubkey, isSigner: false, isWritable: true},\n        {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */\n  static createAccountWithSeed(\n    params: CreateStakeAccountWithSeedParams,\n  ): Transaction {\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccountWithSeed({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.stakePubkey,\n        basePubkey: params.basePubkey,\n        seed: params.seed,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId,\n      }),\n    );\n\n    const {stakePubkey, authorized, lockup} = params;\n    return transaction.add(this.initialize({stakePubkey, authorized, lockup}));\n  }\n\n  /**\n   * Generate a Transaction that creates a new Stake account\n   */\n  static createAccount(params: CreateStakeAccountParams): Transaction {\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.stakePubkey,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId,\n      }),\n    );\n\n    const {stakePubkey, authorized, lockup} = params;\n    return transaction.add(this.initialize({stakePubkey, authorized, lockup}));\n  }\n\n  /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */\n  static delegate(params: DelegateStakeParams): Transaction {\n    const {stakePubkey, authorizedPubkey, votePubkey} = params;\n\n    const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n    const data = encodeData(type);\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: stakePubkey, isSigner: false, isWritable: true},\n        {pubkey: votePubkey, isSigner: false, isWritable: false},\n        {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false},\n        {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {pubkey: STAKE_CONFIG_ID, isSigner: false, isWritable: false},\n        {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */\n  static authorize(params: AuthorizeStakeParams): Transaction {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      newAuthorizedPubkey,\n      stakeAuthorizationType,\n      custodianPubkey,\n    } = params;\n\n    const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      stakeAuthorizationType: stakeAuthorizationType.index,\n    });\n\n    const keys = [\n      {pubkey: stakePubkey, isSigner: false, isWritable: true},\n      {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: true},\n      {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n    ];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false,\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */\n  static authorizeWithSeed(params: AuthorizeWithSeedStakeParams): Transaction {\n    const {\n      stakePubkey,\n      authorityBase,\n      authoritySeed,\n      authorityOwner,\n      newAuthorizedPubkey,\n      stakeAuthorizationType,\n      custodianPubkey,\n    } = params;\n\n    const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      stakeAuthorizationType: stakeAuthorizationType.index,\n      authoritySeed: authoritySeed,\n      authorityOwner: toBuffer(authorityOwner.toBuffer()),\n    });\n\n    const keys = [\n      {pubkey: stakePubkey, isSigner: false, isWritable: true},\n      {pubkey: authorityBase, isSigner: true, isWritable: false},\n      {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false},\n    ];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false,\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  static splitInstruction(params: SplitStakeParams): TransactionInstruction {\n    const {stakePubkey, authorizedPubkey, splitStakePubkey, lamports} = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n    const data = encodeData(type, {lamports});\n    return new TransactionInstruction({\n      keys: [\n        {pubkey: stakePubkey, isSigner: false, isWritable: true},\n        {pubkey: splitStakePubkey, isSigner: false, isWritable: true},\n        {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */\n  static split(\n    params: SplitStakeParams,\n    // Compute the cost of allocating the new stake account in lamports\n    rentExemptReserve: number,\n  ): Transaction {\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: params.authorizedPubkey,\n        newAccountPubkey: params.splitStakePubkey,\n        lamports: rentExemptReserve,\n        space: this.space,\n        programId: this.programId,\n      }),\n    );\n    return transaction.add(this.splitInstruction(params));\n  }\n\n  /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */\n  static splitWithSeed(\n    params: SplitStakeWithSeedParams,\n    // If this stake account is new, compute the cost of allocating it in lamports\n    rentExemptReserve?: number,\n  ): Transaction {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      splitStakePubkey,\n      basePubkey,\n      seed,\n      lamports,\n    } = params;\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.allocate({\n        accountPubkey: splitStakePubkey,\n        basePubkey,\n        seed,\n        space: this.space,\n        programId: this.programId,\n      }),\n    );\n    if (rentExemptReserve && rentExemptReserve > 0) {\n      transaction.add(\n        SystemProgram.transfer({\n          fromPubkey: params.authorizedPubkey,\n          toPubkey: splitStakePubkey,\n          lamports: rentExemptReserve,\n        }),\n      );\n    }\n    return transaction.add(\n      this.splitInstruction({\n        stakePubkey,\n        authorizedPubkey,\n        splitStakePubkey,\n        lamports,\n      }),\n    );\n  }\n\n  /**\n   * Generate a Transaction that merges Stake accounts.\n   */\n  static merge(params: MergeStakeParams): Transaction {\n    const {stakePubkey, sourceStakePubKey, authorizedPubkey} = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n    const data = encodeData(type);\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: stakePubkey, isSigner: false, isWritable: true},\n        {pubkey: sourceStakePubKey, isSigner: false, isWritable: true},\n        {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false},\n        {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */\n  static withdraw(params: WithdrawStakeParams): Transaction {\n    const {stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey} =\n      params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n    const data = encodeData(type, {lamports});\n\n    const keys = [\n      {pubkey: stakePubkey, isSigner: false, isWritable: true},\n      {pubkey: toPubkey, isSigner: false, isWritable: true},\n      {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false},\n      {\n        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n      {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n    ];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false,\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */\n  static deactivate(params: DeactivateStakeParams): Transaction {\n    const {stakePubkey, authorizedPubkey} = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n    const data = encodeData(type);\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: stakePubkey, isSigner: false, isWritable: true},\n        {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false},\n        {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n}\n", "import * as BufferLayout from '@solana/buffer-layout';\n\nimport {\n  encodeData,\n  decodeData,\n  InstructionType,\n  IInstructionInputData,\n} from '../instruction';\nimport * as Layout from '../layout';\nimport {PublicKey} from '../publickey';\nimport {SystemProgram} from './system';\nimport {SYSVAR_CLOCK_PUBKEY, SYSVAR_RENT_PUBKEY} from '../sysvar';\nimport {Transaction, TransactionInstruction} from '../transaction';\nimport {toBuffer} from '../utils/to-buffer';\n\n/**\n * Vote account info\n */\nexport class VoteInit {\n  nodePubkey: PublicKey;\n  authorizedVoter: PublicKey;\n  authorizedWithdrawer: PublicKey;\n  commission: number; /** [0, 100] */\n\n  constructor(\n    nodePubkey: PublicKey,\n    authorizedVoter: PublicKey,\n    authorizedWithdrawer: PublicKey,\n    commission: number,\n  ) {\n    this.nodePubkey = nodePubkey;\n    this.authorizedVoter = authorizedVoter;\n    this.authorizedWithdrawer = authorizedWithdrawer;\n    this.commission = commission;\n  }\n}\n\n/**\n * Create vote account transaction params\n */\nexport type CreateVoteAccountParams = {\n  fromPubkey: PublicKey;\n  votePubkey: PublicKey;\n  voteInit: VoteInit;\n  lamports: number;\n};\n\n/**\n * InitializeAccount instruction params\n */\nexport type InitializeAccountParams = {\n  votePubkey: PublicKey;\n  nodePubkey: PublicKey;\n  voteInit: VoteInit;\n};\n\n/**\n * Authorize instruction params\n */\nexport type AuthorizeVoteParams = {\n  votePubkey: PublicKey;\n  /** Current vote or withdraw authority, depending on `voteAuthorizationType` */\n  authorizedPubkey: PublicKey;\n  newAuthorizedPubkey: PublicKey;\n  voteAuthorizationType: VoteAuthorizationType;\n};\n\n/**\n * AuthorizeWithSeed instruction params\n */\nexport type AuthorizeVoteWithSeedParams = {\n  currentAuthorityDerivedKeyBasePubkey: PublicKey;\n  currentAuthorityDerivedKeyOwnerPubkey: PublicKey;\n  currentAuthorityDerivedKeySeed: string;\n  newAuthorizedPubkey: PublicKey;\n  voteAuthorizationType: VoteAuthorizationType;\n  votePubkey: PublicKey;\n};\n\n/**\n * Withdraw from vote account transaction params\n */\nexport type WithdrawFromVoteAccountParams = {\n  votePubkey: PublicKey;\n  authorizedWithdrawerPubkey: PublicKey;\n  lamports: number;\n  toPubkey: PublicKey;\n};\n\n/**\n * Update validator identity (node pubkey) vote account instruction params.\n */\nexport type UpdateValidatorIdentityParams = {\n  votePubkey: PublicKey;\n  authorizedWithdrawerPubkey: PublicKey;\n  nodePubkey: PublicKey;\n};\n\n/**\n * Vote Instruction class\n */\nexport class VoteInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(\n    instruction: TransactionInstruction,\n  ): VoteInstructionType {\n    this.checkProgramId(instruction.programId);\n\n    const instructionTypeLayout = BufferLayout.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n\n    let type: VoteInstructionType | undefined;\n    for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType as VoteInstructionType;\n        break;\n      }\n    }\n\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a VoteInstruction');\n    }\n\n    return type;\n  }\n\n  /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */\n  static decodeInitializeAccount(\n    instruction: TransactionInstruction,\n  ): InitializeAccountParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 4);\n\n    const {voteInit} = decodeData(\n      VOTE_INSTRUCTION_LAYOUTS.InitializeAccount,\n      instruction.data,\n    );\n\n    return {\n      votePubkey: instruction.keys[0].pubkey,\n      nodePubkey: instruction.keys[3].pubkey,\n      voteInit: new VoteInit(\n        new PublicKey(voteInit.nodePubkey),\n        new PublicKey(voteInit.authorizedVoter),\n        new PublicKey(voteInit.authorizedWithdrawer),\n        voteInit.commission,\n      ),\n    };\n  }\n\n  /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */\n  static decodeAuthorize(\n    instruction: TransactionInstruction,\n  ): AuthorizeVoteParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n\n    const {newAuthorized, voteAuthorizationType} = decodeData(\n      VOTE_INSTRUCTION_LAYOUTS.Authorize,\n      instruction.data,\n    );\n\n    return {\n      votePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      voteAuthorizationType: {\n        index: voteAuthorizationType,\n      },\n    };\n  }\n\n  /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */\n  static decodeAuthorizeWithSeed(\n    instruction: TransactionInstruction,\n  ): AuthorizeVoteWithSeedParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n\n    const {\n      voteAuthorizeWithSeedArgs: {\n        currentAuthorityDerivedKeyOwnerPubkey,\n        currentAuthorityDerivedKeySeed,\n        newAuthorized,\n        voteAuthorizationType,\n      },\n    } = decodeData(\n      VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,\n      instruction.data,\n    );\n\n    return {\n      currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n      currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(\n        currentAuthorityDerivedKeyOwnerPubkey,\n      ),\n      currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      voteAuthorizationType: {\n        index: voteAuthorizationType,\n      },\n      votePubkey: instruction.keys[0].pubkey,\n    };\n  }\n\n  /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */\n  static decodeWithdraw(\n    instruction: TransactionInstruction,\n  ): WithdrawFromVoteAccountParams {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n\n    const {lamports} = decodeData(\n      VOTE_INSTRUCTION_LAYOUTS.Withdraw,\n      instruction.data,\n    );\n\n    return {\n      votePubkey: instruction.keys[0].pubkey,\n      authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n      lamports,\n      toPubkey: instruction.keys[1].pubkey,\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId: PublicKey) {\n    if (!programId.equals(VoteProgram.programId)) {\n      throw new Error('invalid instruction; programId is not VoteProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys: Array<any>, expectedLength: number) {\n    if (keys.length < expectedLength) {\n      throw new Error(\n        `invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`,\n      );\n    }\n  }\n}\n\n/**\n * An enumeration of valid VoteInstructionType's\n */\nexport type VoteInstructionType =\n  // FIXME\n  // It would be preferable for this type to be `keyof VoteInstructionInputData`\n  // but Typedoc does not transpile `keyof` expressions.\n  // See https://github.com/TypeStrong/typedoc/issues/1894\n  | 'Authorize'\n  | 'AuthorizeWithSeed'\n  | 'InitializeAccount'\n  | 'Withdraw'\n  | 'UpdateValidatorIdentity';\n\n/** @internal */\nexport type VoteAuthorizeWithSeedArgs = Readonly<{\n  currentAuthorityDerivedKeyOwnerPubkey: Uint8Array;\n  currentAuthorityDerivedKeySeed: string;\n  newAuthorized: Uint8Array;\n  voteAuthorizationType: number;\n}>;\ntype VoteInstructionInputData = {\n  Authorize: IInstructionInputData & {\n    newAuthorized: Uint8Array;\n    voteAuthorizationType: number;\n  };\n  AuthorizeWithSeed: IInstructionInputData & {\n    voteAuthorizeWithSeedArgs: VoteAuthorizeWithSeedArgs;\n  };\n  InitializeAccount: IInstructionInputData & {\n    voteInit: Readonly<{\n      authorizedVoter: Uint8Array;\n      authorizedWithdrawer: Uint8Array;\n      commission: number;\n      nodePubkey: Uint8Array;\n    }>;\n  };\n  Withdraw: IInstructionInputData & {\n    lamports: number;\n  };\n  UpdateValidatorIdentity: IInstructionInputData;\n};\n\nconst VOTE_INSTRUCTION_LAYOUTS = Object.freeze<{\n  [Instruction in VoteInstructionType]: InstructionType<\n    VoteInstructionInputData[Instruction]\n  >;\n}>({\n  InitializeAccount: {\n    index: 0,\n    layout: BufferLayout.struct<VoteInstructionInputData['InitializeAccount']>([\n      BufferLayout.u32('instruction'),\n      Layout.voteInit(),\n    ]),\n  },\n  Authorize: {\n    index: 1,\n    layout: BufferLayout.struct<VoteInstructionInputData['Authorize']>([\n      BufferLayout.u32('instruction'),\n      Layout.publicKey('newAuthorized'),\n      BufferLayout.u32('voteAuthorizationType'),\n    ]),\n  },\n  Withdraw: {\n    index: 3,\n    layout: BufferLayout.struct<VoteInstructionInputData['Withdraw']>([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('lamports'),\n    ]),\n  },\n  UpdateValidatorIdentity: {\n    index: 4,\n    layout: BufferLayout.struct<\n      VoteInstructionInputData['UpdateValidatorIdentity']\n    >([BufferLayout.u32('instruction')]),\n  },\n  AuthorizeWithSeed: {\n    index: 10,\n    layout: BufferLayout.struct<VoteInstructionInputData['AuthorizeWithSeed']>([\n      BufferLayout.u32('instruction'),\n      Layout.voteAuthorizeWithSeedArgs(),\n    ]),\n  },\n});\n\n/**\n * VoteAuthorize type\n */\nexport type VoteAuthorizationType = {\n  /** The VoteAuthorize index (from solana-vote-program) */\n  index: number;\n};\n\n/**\n * An enumeration of valid VoteAuthorization layouts.\n */\nexport const VoteAuthorizationLayout = Object.freeze({\n  Voter: {\n    index: 0,\n  },\n  Withdrawer: {\n    index: 1,\n  },\n});\n\n/**\n * Factory class for transactions to interact with the Vote program\n */\nexport class VoteProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Vote program\n   */\n  static programId: PublicKey = new PublicKey(\n    'Vote111111111111111111111111111111111111111',\n  );\n\n  /**\n   * Max space of a Vote account\n   *\n   * This is generated from the solana-vote-program VoteState struct as\n   * `VoteState::size_of()`:\n   * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n   *\n   * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n   */\n  static space: number = 3762;\n\n  /**\n   * Generate an Initialize instruction.\n   */\n  static initializeAccount(\n    params: InitializeAccountParams,\n  ): TransactionInstruction {\n    const {votePubkey, nodePubkey, voteInit} = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n    const data = encodeData(type, {\n      voteInit: {\n        nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n        authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n        authorizedWithdrawer: toBuffer(\n          voteInit.authorizedWithdrawer.toBuffer(),\n        ),\n        commission: voteInit.commission,\n      },\n    });\n    const instructionData = {\n      keys: [\n        {pubkey: votePubkey, isSigner: false, isWritable: true},\n        {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n        {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false},\n        {pubkey: nodePubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a transaction that creates a new Vote account.\n   */\n  static createAccount(params: CreateVoteAccountParams): Transaction {\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.votePubkey,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId,\n      }),\n    );\n\n    return transaction.add(\n      this.initializeAccount({\n        votePubkey: params.votePubkey,\n        nodePubkey: params.voteInit.nodePubkey,\n        voteInit: params.voteInit,\n      }),\n    );\n  }\n\n  /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */\n  static authorize(params: AuthorizeVoteParams): Transaction {\n    const {\n      votePubkey,\n      authorizedPubkey,\n      newAuthorizedPubkey,\n      voteAuthorizationType,\n    } = params;\n\n    const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      voteAuthorizationType: voteAuthorizationType.index,\n    });\n\n    const keys = [\n      {pubkey: votePubkey, isSigner: false, isWritable: true},\n      {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false},\n      {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n    ];\n\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */\n  static authorizeWithSeed(params: AuthorizeVoteWithSeedParams): Transaction {\n    const {\n      currentAuthorityDerivedKeyBasePubkey,\n      currentAuthorityDerivedKeyOwnerPubkey,\n      currentAuthorityDerivedKeySeed,\n      newAuthorizedPubkey,\n      voteAuthorizationType,\n      votePubkey,\n    } = params;\n\n    const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n    const data = encodeData(type, {\n      voteAuthorizeWithSeedArgs: {\n        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(\n          currentAuthorityDerivedKeyOwnerPubkey.toBuffer(),\n        ),\n        currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        voteAuthorizationType: voteAuthorizationType.index,\n      },\n    });\n\n    const keys = [\n      {pubkey: votePubkey, isSigner: false, isWritable: true},\n      {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false},\n      {\n        pubkey: currentAuthorityDerivedKeyBasePubkey,\n        isSigner: true,\n        isWritable: false,\n      },\n    ];\n\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a transaction to withdraw from a Vote account.\n   */\n  static withdraw(params: WithdrawFromVoteAccountParams): Transaction {\n    const {votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey} = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n    const data = encodeData(type, {lamports});\n\n    const keys = [\n      {pubkey: votePubkey, isSigner: false, isWritable: true},\n      {pubkey: toPubkey, isSigner: false, isWritable: true},\n      {pubkey: authorizedWithdrawerPubkey, isSigner: true, isWritable: false},\n    ];\n\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */\n  static safeWithdraw(\n    params: WithdrawFromVoteAccountParams,\n    currentVoteAccountBalance: number,\n    rentExemptMinimum: number,\n  ): Transaction {\n    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n      throw new Error(\n        'Withdraw will leave vote account with insufficient funds.',\n      );\n    }\n    return VoteProgram.withdraw(params);\n  }\n\n  /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */\n  static updateValidatorIdentity(\n    params: UpdateValidatorIdentityParams,\n  ): Transaction {\n    const {votePubkey, authorizedWithdrawerPubkey, nodePubkey} = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n    const data = encodeData(type);\n\n    const keys = [\n      {pubkey: votePubkey, isSigner: false, isWritable: true},\n      {pubkey: nodePubkey, isSigner: true, isWritable: false},\n      {pubkey: authorizedWithdrawerPubkey, isSigner: true, isWritable: false},\n    ];\n\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data,\n    });\n  }\n}\n", "import {Buffer} from 'buffer';\nimport {\n  assert as assertType,\n  optional,\n  string,\n  type as pick,\n} from 'superstruct';\n\nimport * as Layout from './layout';\nimport * as shortvec from './utils/shortvec-encoding';\nimport {PublicKey, PUBLIC_KEY_LENGTH} from './publickey';\nimport {guardedShift, guardedSplice} from './utils/guarded-array-utils';\n\nexport const VALIDATOR_INFO_KEY = new PublicKey(\n  'Va1idator1nfo111111111111111111111111111111',\n);\n\n/**\n * @internal\n */\ntype ConfigKey = {\n  publicKey: PublicKey;\n  isSigner: boolean;\n};\n\n/**\n * Info used to identity validators.\n */\nexport type Info = {\n  /** validator name */\n  name: string;\n  /** optional, validator website */\n  website?: string;\n  /** optional, extra information the validator chose to share */\n  details?: string;\n  /** optional, validator logo URL */\n  iconUrl?: string;\n  /** optional, used to identify validators on keybase.io */\n  keybaseUsername?: string;\n};\n\nconst InfoString = pick({\n  name: string(),\n  website: optional(string()),\n  details: optional(string()),\n  iconUrl: optional(string()),\n  keybaseUsername: optional(string()),\n});\n\n/**\n * ValidatorInfo class\n */\nexport class ValidatorInfo {\n  /**\n   * validator public key\n   */\n  key: PublicKey;\n  /**\n   * validator information\n   */\n  info: Info;\n\n  /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */\n  constructor(key: PublicKey, info: Info) {\n    this.key = key;\n    this.info = info;\n  }\n\n  /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */\n  static fromConfigData(\n    buffer: Buffer | Uint8Array | Array<number>,\n  ): ValidatorInfo | null {\n    let byteArray = [...buffer];\n    const configKeyCount = shortvec.decodeLength(byteArray);\n    if (configKeyCount !== 2) return null;\n\n    const configKeys: Array<ConfigKey> = [];\n    for (let i = 0; i < 2; i++) {\n      const publicKey = new PublicKey(\n        guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH),\n      );\n      const isSigner = guardedShift(byteArray) === 1;\n      configKeys.push({publicKey, isSigner});\n    }\n\n    if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n      if (configKeys[1].isSigner) {\n        const rawInfo: any = Layout.rustString().decode(Buffer.from(byteArray));\n        const info = JSON.parse(rawInfo as string);\n        assertType(info, InfoString);\n        return new ValidatorInfo(configKeys[1].publicKey, info);\n      }\n    }\n\n    return null;\n  }\n}\n", "import * as BufferLayout from '@solana/buffer-layout';\nimport type {Buffer} from 'buffer';\n\nimport * as Layout from './layout';\nimport {PublicKey} from './publickey';\nimport {toBuffer} from './utils/to-buffer';\n\nexport const VOTE_PROGRAM_ID = new PublicKey(\n  'Vote111111111111111111111111111111111111111',\n);\n\nexport type Lockout = {\n  slot: number;\n  confirmationCount: number;\n};\n\n/**\n * History of how many credits earned by the end of each epoch\n */\nexport type EpochCredits = Readonly<{\n  epoch: number;\n  credits: number;\n  prevCredits: number;\n}>;\n\nexport type AuthorizedVoter = Readonly<{\n  epoch: number;\n  authorizedVoter: PublicKey;\n}>;\n\ntype AuthorizedVoterRaw = Readonly<{\n  authorizedVoter: Uint8Array;\n  epoch: number;\n}>;\n\ntype PriorVoters = Readonly<{\n  buf: PriorVoterRaw[];\n  idx: number;\n  isEmpty: number;\n}>;\n\nexport type PriorVoter = Readonly<{\n  authorizedPubkey: PublicKey;\n  epochOfLastAuthorizedSwitch: number;\n  targetEpoch: number;\n}>;\n\ntype PriorVoterRaw = Readonly<{\n  authorizedPubkey: Uint8Array;\n  epochOfLastAuthorizedSwitch: number;\n  targetEpoch: number;\n}>;\n\nexport type BlockTimestamp = Readonly<{\n  slot: number;\n  timestamp: number;\n}>;\n\ntype VoteAccountData = Readonly<{\n  authorizedVoters: AuthorizedVoterRaw[];\n  authorizedWithdrawer: Uint8Array;\n  commission: number;\n  epochCredits: EpochCredits[];\n  lastTimestamp: BlockTimestamp;\n  nodePubkey: Uint8Array;\n  priorVoters: PriorVoters;\n  rootSlot: number;\n  rootSlotValid: number;\n  votes: Lockout[];\n}>;\n\n/**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */\nconst VoteAccountLayout = BufferLayout.struct<VoteAccountData>([\n  Layout.publicKey('nodePubkey'),\n  Layout.publicKey('authorizedWithdrawer'),\n  BufferLayout.u8('commission'),\n  BufferLayout.nu64(), // votes.length\n  BufferLayout.seq<Lockout>(\n    BufferLayout.struct([\n      BufferLayout.nu64('slot'),\n      BufferLayout.u32('confirmationCount'),\n    ]),\n    BufferLayout.offset(BufferLayout.u32(), -8),\n    'votes',\n  ),\n  BufferLayout.u8('rootSlotValid'),\n  BufferLayout.nu64('rootSlot'),\n  BufferLayout.nu64(), // authorizedVoters.length\n  BufferLayout.seq<AuthorizedVoterRaw>(\n    BufferLayout.struct([\n      BufferLayout.nu64('epoch'),\n      Layout.publicKey('authorizedVoter'),\n    ]),\n    BufferLayout.offset(BufferLayout.u32(), -8),\n    'authorizedVoters',\n  ),\n  BufferLayout.struct<PriorVoters>(\n    [\n      BufferLayout.seq(\n        BufferLayout.struct([\n          Layout.publicKey('authorizedPubkey'),\n          BufferLayout.nu64('epochOfLastAuthorizedSwitch'),\n          BufferLayout.nu64('targetEpoch'),\n        ]),\n        32,\n        'buf',\n      ),\n      BufferLayout.nu64('idx'),\n      BufferLayout.u8('isEmpty'),\n    ],\n    'priorVoters',\n  ),\n  BufferLayout.nu64(), // epochCredits.length\n  BufferLayout.seq<EpochCredits>(\n    BufferLayout.struct([\n      BufferLayout.nu64('epoch'),\n      BufferLayout.nu64('credits'),\n      BufferLayout.nu64('prevCredits'),\n    ]),\n    BufferLayout.offset(BufferLayout.u32(), -8),\n    'epochCredits',\n  ),\n  BufferLayout.struct<BlockTimestamp>(\n    [BufferLayout.nu64('slot'), BufferLayout.nu64('timestamp')],\n    'lastTimestamp',\n  ),\n]);\n\ntype VoteAccountArgs = {\n  nodePubkey: PublicKey;\n  authorizedWithdrawer: PublicKey;\n  commission: number;\n  rootSlot: number | null;\n  votes: Lockout[];\n  authorizedVoters: AuthorizedVoter[];\n  priorVoters: PriorVoter[];\n  epochCredits: EpochCredits[];\n  lastTimestamp: BlockTimestamp;\n};\n\n/**\n * VoteAccount class\n */\nexport class VoteAccount {\n  nodePubkey: PublicKey;\n  authorizedWithdrawer: PublicKey;\n  commission: number;\n  rootSlot: number | null;\n  votes: Lockout[];\n  authorizedVoters: AuthorizedVoter[];\n  priorVoters: PriorVoter[];\n  epochCredits: EpochCredits[];\n  lastTimestamp: BlockTimestamp;\n\n  /**\n   * @internal\n   */\n  constructor(args: VoteAccountArgs) {\n    this.nodePubkey = args.nodePubkey;\n    this.authorizedWithdrawer = args.authorizedWithdrawer;\n    this.commission = args.commission;\n    this.rootSlot = args.rootSlot;\n    this.votes = args.votes;\n    this.authorizedVoters = args.authorizedVoters;\n    this.priorVoters = args.priorVoters;\n    this.epochCredits = args.epochCredits;\n    this.lastTimestamp = args.lastTimestamp;\n  }\n\n  /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */\n  static fromAccountData(\n    buffer: Buffer | Uint8Array | Array<number>,\n  ): VoteAccount {\n    const versionOffset = 4;\n    const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n\n    let rootSlot: number | null = va.rootSlot;\n    if (!va.rootSlotValid) {\n      rootSlot = null;\n    }\n\n    return new VoteAccount({\n      nodePubkey: new PublicKey(va.nodePubkey),\n      authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n      commission: va.commission,\n      votes: va.votes,\n      rootSlot,\n      authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n      priorVoters: getPriorVoters(va.priorVoters),\n      epochCredits: va.epochCredits,\n      lastTimestamp: va.lastTimestamp,\n    });\n  }\n}\n\nfunction parseAuthorizedVoter({\n  authorizedVoter,\n  epoch,\n}: AuthorizedVoterRaw): AuthorizedVoter {\n  return {\n    epoch,\n    authorizedVoter: new PublicKey(authorizedVoter),\n  };\n}\n\nfunction parsePriorVoters({\n  authorizedPubkey,\n  epochOfLastAuthorizedSwitch,\n  targetEpoch,\n}: PriorVoterRaw): PriorVoter {\n  return {\n    authorizedPubkey: new PublicKey(authorizedPubkey),\n    epochOfLastAuthorizedSwitch,\n    targetEpoch,\n  };\n}\n\nfunction getPriorVoters({buf, idx, isEmpty}: PriorVoters): PriorVoter[] {\n  if (isEmpty) {\n    return [];\n  }\n\n  return [\n    ...buf.slice(idx + 1).map(parsePriorVoters),\n    ...buf.slice(0, idx).map(parsePriorVoters),\n  ];\n}\n", "const endpoint = {\n  http: {\n    devnet: 'http://api.devnet.solana.com',\n    testnet: 'http://api.testnet.solana.com',\n    'mainnet-beta': 'http://api.mainnet-beta.solana.com/',\n  },\n  https: {\n    devnet: 'https://api.devnet.solana.com',\n    testnet: 'https://api.testnet.solana.com',\n    'mainnet-beta': 'https://api.mainnet-beta.solana.com/',\n  },\n};\n\nexport type Cluster = 'devnet' | 'testnet' | 'mainnet-beta';\n\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */\nexport function clusterApiUrl(cluster?: Cluster, tls?: boolean): string {\n  const key = tls === false ? 'http' : 'https';\n\n  if (!cluster) {\n    return endpoint[key]['devnet'];\n  }\n\n  const url = endpoint[key][cluster];\n  if (!url) {\n    throw new Error(`Unknown ${key} cluster: ${cluster}`);\n  }\n  return url;\n}\n", "import type {Buffer} from 'buffer';\n\nimport {\n  BlockheightBasedTransactionConfirmationStrategy,\n  Connection,\n  DurableNonceTransactionConfirmationStrategy,\n  TransactionConfirmationStrategy,\n} from '../connection';\nimport type {TransactionSignature} from '../transaction';\nimport type {ConfirmOptions} from '../connection';\nimport {SendTransactionError} from '../errors';\n\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\nexport async function sendAndConfirmRawTransaction(\n  connection: Connection,\n  rawTransaction: Buffer,\n  confirmationStrategy: TransactionConfirmationStrategy,\n  options?: ConfirmOptions,\n): Promise<TransactionSignature>;\n\n/**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */\n// eslint-disable-next-line no-redeclare\nexport async function sendAndConfirmRawTransaction(\n  connection: Connection,\n  rawTransaction: Buffer,\n  options?: ConfirmOptions,\n): Promise<TransactionSignature>;\n\n// eslint-disable-next-line no-redeclare\nexport async function sendAndConfirmRawTransaction(\n  connection: Connection,\n  rawTransaction: Buffer,\n  confirmationStrategyOrConfirmOptions:\n    | TransactionConfirmationStrategy\n    | ConfirmOptions\n    | undefined,\n  maybeConfirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n  let confirmationStrategy: TransactionConfirmationStrategy | undefined;\n  let options: ConfirmOptions | undefined;\n  if (\n    confirmationStrategyOrConfirmOptions &&\n    Object.prototype.hasOwnProperty.call(\n      confirmationStrategyOrConfirmOptions,\n      'lastValidBlockHeight',\n    )\n  ) {\n    confirmationStrategy =\n      confirmationStrategyOrConfirmOptions as BlockheightBasedTransactionConfirmationStrategy;\n    options = maybeConfirmOptions;\n  } else if (\n    confirmationStrategyOrConfirmOptions &&\n    Object.prototype.hasOwnProperty.call(\n      confirmationStrategyOrConfirmOptions,\n      'nonceValue',\n    )\n  ) {\n    confirmationStrategy =\n      confirmationStrategyOrConfirmOptions as DurableNonceTransactionConfirmationStrategy;\n    options = maybeConfirmOptions;\n  } else {\n    options = confirmationStrategyOrConfirmOptions as\n      | ConfirmOptions\n      | undefined;\n  }\n  const sendOptions = options && {\n    skipPreflight: options.skipPreflight,\n    preflightCommitment: options.preflightCommitment || options.commitment,\n    minContextSlot: options.minContextSlot,\n  };\n\n  const signature = await connection.sendRawTransaction(\n    rawTransaction,\n    sendOptions,\n  );\n\n  const commitment = options && options.commitment;\n  const confirmationPromise = confirmationStrategy\n    ? connection.confirmTransaction(confirmationStrategy, commitment)\n    : connection.confirmTransaction(signature, commitment);\n  const status = (await confirmationPromise).value;\n\n  if (status.err) {\n    if (signature != null) {\n      throw new SendTransactionError({\n        action: sendOptions?.skipPreflight ? 'send' : 'simulate',\n        signature: signature,\n        transactionMessage: `Status: (${JSON.stringify(status)})`,\n      });\n    }\n    throw new Error(\n      `Raw transaction ${signature} failed (${JSON.stringify(status)})`,\n    );\n  }\n\n  return signature;\n}\n", "export * from './account';\nexport * from './blockhash';\nexport * from './bpf-loader-deprecated';\nexport * from './bpf-loader';\nexport * from './connection';\nexport * from './epoch-schedule';\nexport * from './errors';\nexport * from './fee-calculator';\nexport * from './keypair';\nexport * from './loader';\nexport * from './message';\nexport * from './nonce-account';\nexport * from './programs';\nexport * from './publickey';\nexport * from './transaction';\nexport * from './validator-info';\nexport * from './vote-account';\nexport * from './sysvar';\nexport * from './utils';\n\n/**\n * There are 1-billion lamports in one SOL\n */\nexport const LAMPORTS_PER_SOL = 1000000000;\n", null, "export class WalletError extends Error {\n    error: any;\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(message?: string, error?: any) {\n        super(message);\n        this.error = error;\n    }\n}\n\nexport class WalletNotReadyError extends WalletError {\n    name = 'WalletNotReadyError';\n}\n\nexport class WalletLoadError extends WalletError {\n    name = 'WalletLoadError';\n}\n\nexport class WalletConfigError extends WalletError {\n    name = 'WalletConfigError';\n}\n\nexport class WalletConnectionError extends WalletError {\n    name = 'WalletConnectionError';\n}\n\nexport class WalletDisconnectedError extends WalletError {\n    name = 'WalletDisconnectedError';\n}\n\nexport class WalletDisconnectionError extends WalletError {\n    name = 'WalletDisconnectionError';\n}\n\nexport class WalletAccountError extends WalletError {\n    name = 'WalletAccountError';\n}\n\nexport class WalletPublicKeyError extends WalletError {\n    name = 'WalletPublicKeyError';\n}\n\nexport class WalletKeypairError extends WalletError {\n    name = 'WalletKeypairError';\n}\n\nexport class WalletNotConnectedError extends WalletError {\n    name = 'WalletNotConnectedError';\n}\n\nexport class WalletSendTransactionError extends WalletError {\n    name = 'WalletSendTransactionError';\n}\n\nexport class WalletSignTransactionError extends WalletError {\n    name = 'WalletSignTransactionError';\n}\n\nexport class WalletSignMessageError extends WalletError {\n    name = 'WalletSignMessageError';\n}\n\nexport class WalletSignInError extends WalletError {\n    name = 'WalletSignInError';\n}\n\nexport class WalletTimeoutError extends WalletError {\n    name = 'WalletTimeoutError';\n}\n\nexport class WalletWindowBlockedError extends WalletError {\n    name = 'WalletWindowBlockedError';\n}\n\nexport class WalletWindowClosedError extends WalletError {\n    name = 'WalletWindowClosedError';\n}\n", "import type { Connection, PublicKey, SendOptions, Signer, Transaction, TransactionSignature } from '@solana/web3.js';\nimport EventEmitter from 'eventemitter3';\nimport { type WalletError, WalletNotConnectedError } from './errors.js';\nimport type { SupportedTransactionVersions, TransactionOrVersionedTransaction } from './transaction.js';\n\nexport { EventEmitter };\n\nexport interface WalletAdapterEvents {\n    connect(publicKey: PublicKey): void;\n    disconnect(): void;\n    error(error: WalletError): void;\n    readyStateChange(readyState: WalletReadyState): void;\n}\n\nexport interface SendTransactionOptions extends SendOptions {\n    signers?: Signer[];\n}\n\n// WalletName is a nominal type that wallet adapters should use, e.g. `'MyCryptoWallet' as WalletName<'MyCryptoWallet'>`\n// https://medium.com/@KevinBGreene/surviving-the-typescript-ecosystem-branding-and-type-tagging-6cf6e516523d\nexport type WalletName<T extends string = string> = T & { __brand__: 'WalletName' };\n\nexport interface WalletAdapterProps<Name extends string = string> {\n    name: WalletName<Name>;\n    url: string;\n    icon: string;\n    readyState: WalletReadyState;\n    publicKey: PublicKey | null;\n    connecting: boolean;\n    connected: boolean;\n    supportedTransactionVersions?: SupportedTransactionVersions;\n\n    autoConnect(): Promise<void>;\n    connect(): Promise<void>;\n    disconnect(): Promise<void>;\n    sendTransaction(\n        transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\n        connection: Connection,\n        options?: SendTransactionOptions\n    ): Promise<TransactionSignature>;\n}\n\nexport type WalletAdapter<Name extends string = string> = WalletAdapterProps<Name> & EventEmitter<WalletAdapterEvents>;\n\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\nexport enum WalletReadyState {\n    /**\n     * User-installable wallets can typically be detected by scanning for an API\n     * that they've injected into the global context. If such an API is present,\n     * we consider the wallet to have been installed.\n     */\n    Installed = 'Installed',\n    NotDetected = 'NotDetected',\n    /**\n     * Loadable wallets are always available to you. Since you can load them at\n     * any time, it's meaningless to say that they have been detected.\n     */\n    Loadable = 'Loadable',\n    /**\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\n     * mobile) then it will stay in the `Unsupported` state.\n     */\n    Unsupported = 'Unsupported',\n}\n\nexport abstract class BaseWalletAdapter<Name extends string = string>\n    extends EventEmitter<WalletAdapterEvents>\n    implements WalletAdapter<Name>\n{\n    abstract name: WalletName<Name>;\n    abstract url: string;\n    abstract icon: string;\n    abstract readyState: WalletReadyState;\n    abstract publicKey: PublicKey | null;\n    abstract connecting: boolean;\n    abstract supportedTransactionVersions?: SupportedTransactionVersions;\n\n    get connected() {\n        return !!this.publicKey;\n    }\n\n    async autoConnect() {\n        await this.connect();\n    }\n\n    abstract connect(): Promise<void>;\n    abstract disconnect(): Promise<void>;\n\n    abstract sendTransaction(\n        transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\n        connection: Connection,\n        options?: SendTransactionOptions\n    ): Promise<TransactionSignature>;\n\n    protected async prepareTransaction(\n        transaction: Transaction,\n        connection: Connection,\n        options: SendOptions = {}\n    ): Promise<Transaction> {\n        const publicKey = this.publicKey;\n        if (!publicKey) throw new WalletNotConnectedError();\n\n        transaction.feePayer = transaction.feePayer || publicKey;\n        transaction.recentBlockhash =\n            transaction.recentBlockhash ||\n            (\n                await connection.getLatestBlockhash({\n                    commitment: options.preflightCommitment,\n                    minContextSlot: options.minContextSlot,\n                })\n            ).blockhash;\n\n        return transaction;\n    }\n}\n\nexport function scopePollingDetectionStrategy(detect: () => boolean): void {\n    // Early return when server-side rendering\n    if (typeof window === 'undefined' || typeof document === 'undefined') return;\n\n    const disposers: (() => void)[] = [];\n\n    function detectAndDispose() {\n        const detected = detect();\n        if (detected) {\n            for (const dispose of disposers) {\n                dispose();\n            }\n        }\n    }\n\n    // Strategy #1: Try detecting every second.\n    const interval =\n        // TODO: #334 Replace with idle callback strategy.\n        setInterval(detectAndDispose, 1000);\n    disposers.push(() => clearInterval(interval));\n\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n    if (\n        // Implies that `DOMContentLoaded` has not yet fired.\n        document.readyState === 'loading'\n    ) {\n        document.addEventListener('DOMContentLoaded', detectAndDispose, { once: true });\n        disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n    }\n\n    // Strategy #3: Detect after the `window` has fully loaded.\n    if (\n        // If the `complete` state has been reached, we're too late.\n        document.readyState !== 'complete'\n    ) {\n        window.addEventListener('load', detectAndDispose, { once: true });\n        disposers.push(() => window.removeEventListener('load', detectAndDispose));\n    }\n\n    // Strategy #4: Detect synchronously, now.\n    detectAndDispose();\n}\n\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */\nexport function isIosAndRedirectable() {\n    // SSR: return false\n    if (!navigator) return false;\n\n    const userAgent = navigator.userAgent.toLowerCase();\n\n    // if on iOS the user agent will contain either iPhone or iPad\n    // caveat: if requesting desktop site then this won't work\n    const isIos = userAgent.includes('iphone') || userAgent.includes('ipad');\n\n    // if in a webview then it will not include Safari\n    // note that other iOS browsers also include Safari\n    // so we will redirect only if Safari is also included\n    const isSafari = userAgent.includes('safari');\n\n    return isIos && isSafari;\n}\n", "import type { Transaction, TransactionVersion, VersionedTransaction } from '@solana/web3.js';\n\nexport type SupportedTransactionVersions = ReadonlySet<TransactionVersion> | null | undefined;\n\nexport type TransactionOrVersionedTransaction<S extends SupportedTransactionVersions> = S extends null | undefined\n    ? Transaction\n    : Transaction | VersionedTransaction;\n\nexport function isVersionedTransaction(\n    transaction: Transaction | VersionedTransaction\n): transaction is VersionedTransaction {\n    return 'version' in transaction;\n}\n", "import type { IdentifierString } from '@wallet-standard/base';\nimport type {\n    SolanaSignTransactionInput,\n    SolanaSignTransactionOptions,\n    SolanaTransactionCommitment,\n    SolanaTransactionVersion,\n} from './signTransaction.js';\n\n/** Name of the feature. */\nexport const SolanaSignAndSendTransaction = 'solana:signAndSendTransaction';\n\n/** TODO: docs */\nexport type SolanaSignAndSendTransactionFeature = {\n    /** Name of the feature. */\n    readonly [SolanaSignAndSendTransaction]: {\n        /** Version of the feature API. */\n        readonly version: SolanaSignAndSendTransactionVersion;\n\n        /** TODO: docs */\n        readonly supportedTransactionVersions: readonly SolanaTransactionVersion[];\n\n        /**\n         * Sign transactions using the account's secret key and send them to the chain.\n         *\n         * @param inputs Inputs for signing and sending transactions.\n         *\n         * @return Outputs of signing and sending transactions.\n         */\n        readonly signAndSendTransaction: SolanaSignAndSendTransactionMethod;\n    };\n};\n\n/** Version of the feature. */\nexport type SolanaSignAndSendTransactionVersion = '1.0.0';\n\n/** TODO: docs */\nexport type SolanaSignAndSendTransactionMethod = (\n    ...inputs: readonly SolanaSignAndSendTransactionInput[]\n) => Promise<readonly SolanaSignAndSendTransactionOutput[]>;\n\n/** Input for signing and sending a transaction. */\nexport interface SolanaSignAndSendTransactionInput extends SolanaSignTransactionInput {\n    /** Chain to use. */\n    readonly chain: IdentifierString;\n\n    /** TODO: docs */\n    readonly options?: SolanaSignAndSendTransactionOptions;\n}\n\n/** Output of signing and sending a transaction. */\nexport interface SolanaSignAndSendTransactionOutput {\n    /** Transaction signature, as raw bytes. */\n    readonly signature: Uint8Array;\n}\n\n/** Options for signing and sending a transaction. */\nexport type SolanaSignAndSendTransactionOptions = SolanaSignTransactionOptions & {\n    /** Desired commitment level. If provided, confirm the transaction after sending. */\n    readonly commitment?: SolanaTransactionCommitment;\n\n    /** Disable transaction verification at the RPC. */\n    readonly skipPreflight?: boolean;\n\n    /** Maximum number of times for the RPC node to retry sending the transaction to the leader. */\n    readonly maxRetries?: number;\n};\n", "import type { WalletAccount } from '@wallet-standard/base';\n\n/** Name of the feature. */\nexport const SolanaSignMessage = 'solana:signMessage';\n\n/** TODO: docs */\nexport type SolanaSignMessageFeature = {\n    /** Name of the feature. */\n    readonly [SolanaSignMessage]: {\n        /** Version of the feature API. */\n        readonly version: SolanaSignMessageVersion;\n\n        /** Sign messages (arbitrary bytes) using the account's secret key. */\n        readonly signMessage: SolanaSignMessageMethod;\n    };\n};\n\n/** Version of the feature. */\nexport type SolanaSignMessageVersion = '1.1.0' | '1.0.0';\n\n/** TODO: docs */\nexport type SolanaSignMessageMethod = (\n    ...inputs: readonly SolanaSignMessageInput[]\n) => Promise<readonly SolanaSignMessageOutput[]>;\n\n/** Input for signing a message. */\nexport interface SolanaSignMessageInput {\n    /** Account to use. */\n    readonly account: WalletAccount;\n\n    /** Message to sign, as raw bytes. */\n    readonly message: Uint8Array;\n}\n\n/** Output of signing a message. */\nexport interface SolanaSignMessageOutput {\n    /**\n     * Message bytes that were signed.\n     * The wallet may prefix or otherwise modify the message before signing it.\n     */\n    readonly signedMessage: Uint8Array;\n\n    /**\n     * Message signature produced.\n     * If the signature type is provided, the signature must be Ed25519.\n     */\n    readonly signature: Uint8Array;\n\n    /**\n     * Optional type of the message signature produced.\n     * If not provided, the signature must be Ed25519.\n     */\n    readonly signatureType?: 'ed25519';\n}\n", "import type { IdentifierString, WalletAccount } from '@wallet-standard/base';\n\n/** Name of the feature. */\nexport const SolanaSignTransaction = 'solana:signTransaction';\n\n/** TODO: docs */\nexport type SolanaSignTransactionFeature = {\n    /** Name of the feature. */\n    readonly [SolanaSignTransaction]: {\n        /** Version of the feature API. */\n        readonly version: SolanaSignTransactionVersion;\n\n        /** TODO: docs */\n        readonly supportedTransactionVersions: readonly SolanaTransactionVersion[];\n\n        /**\n         * Sign transactions using the account's secret key.\n         *\n         * @param inputs Inputs for signing transactions.\n         *\n         * @return Outputs of signing transactions.\n         */\n        readonly signTransaction: SolanaSignTransactionMethod;\n    };\n};\n\n/** Version of the feature. */\nexport type SolanaSignTransactionVersion = '1.0.0';\n\n/** TODO: docs */\nexport type SolanaTransactionVersion = 'legacy' | 0;\n\n/** TODO: docs */\nexport type SolanaSignTransactionMethod = (\n    ...inputs: readonly SolanaSignTransactionInput[]\n) => Promise<readonly SolanaSignTransactionOutput[]>;\n\n/** Input for signing a transaction. */\nexport interface SolanaSignTransactionInput {\n    /** Account to use. */\n    readonly account: WalletAccount;\n\n    /** Serialized transaction, as raw bytes. */\n    readonly transaction: Uint8Array;\n\n    /** Chain to use. */\n    readonly chain?: IdentifierString;\n\n    /** TODO: docs */\n    readonly options?: SolanaSignTransactionOptions;\n}\n\n/** Output of signing a transaction. */\nexport interface SolanaSignTransactionOutput {\n    /**\n     * Signed, serialized transaction, as raw bytes.\n     * Returning a transaction rather than signatures allows multisig wallets, program wallets, and other wallets that\n     * use meta-transactions to return a modified, signed transaction.\n     */\n    readonly signedTransaction: Uint8Array;\n}\n\n/** Options for signing a transaction. */\nexport type SolanaSignTransactionOptions = {\n    /** Preflight commitment level. */\n    readonly preflightCommitment?: SolanaTransactionCommitment;\n\n    /** The minimum slot that the request can be evaluated at. */\n    readonly minContextSlot?: number;\n};\n\n/** Commitment level for transactions. */\nexport type SolanaTransactionCommitment = 'processed' | 'confirmed' | 'finalized';\n", "import type { WalletAccount } from '@wallet-standard/base';\n\n/** Name of the feature. */\nexport const StandardConnect = 'standard:connect';\n/**\n * @deprecated Use {@link StandardConnect} instead.\n *\n * @group Deprecated\n */\nexport const Connect = StandardConnect;\n\n/**\n * `standard:connect` is a {@link \"@wallet-standard/base\".Wallet.features | feature} that may be implemented by a\n * {@link \"@wallet-standard/base\".Wallet} to allow the app to obtain authorization to use\n * {@link \"@wallet-standard/base\".Wallet.accounts}.\n *\n * @group Connect\n */\nexport type StandardConnectFeature = {\n    /** Name of the feature. */\n    readonly [StandardConnect]: {\n        /** Version of the feature implemented by the Wallet. */\n        readonly version: StandardConnectVersion;\n        /** Method to call to use the feature. */\n        readonly connect: StandardConnectMethod;\n    };\n};\n/**\n * @deprecated Use {@link StandardConnectFeature} instead.\n *\n * @group Deprecated\n */\nexport type ConnectFeature = StandardConnectFeature;\n\n/**\n * Version of the {@link StandardConnectFeature} implemented by a {@link \"@wallet-standard/base\".Wallet}.\n *\n * @group Connect\n */\nexport type StandardConnectVersion = '1.0.0';\n/**\n * @deprecated Use {@link StandardConnectVersion} instead.\n *\n * @group Deprecated\n */\nexport type ConnectVersion = StandardConnectVersion;\n\n/**\n * Method to call to use the {@link StandardConnectFeature}.\n *\n * @group Connect\n */\nexport type StandardConnectMethod = (input?: StandardConnectInput) => Promise<StandardConnectOutput>;\n/**\n * @deprecated Use {@link StandardConnectMethod} instead.\n *\n * @group Deprecated\n */\nexport type ConnectMethod = StandardConnectMethod;\n\n/**\n * Input for the {@link StandardConnectMethod}.\n *\n * @group Connect\n */\nexport interface StandardConnectInput {\n    /**\n     * By default, using the {@link StandardConnectFeature} should prompt the user to request authorization to accounts.\n     * Set the `silent` flag to `true` to request accounts that have already been authorized without prompting.\n     *\n     * This flag may or may not be used by the Wallet and the app should not depend on it being used.\n     * If this flag is used by the Wallet, the Wallet should not prompt the user, and should return only the accounts\n     * that the app is authorized to use.\n     */\n    readonly silent?: boolean;\n}\n/**\n * @deprecated Use {@link StandardConnectInput} instead.\n *\n * @group Deprecated\n */\nexport type ConnectInput = StandardConnectInput;\n\n/**\n * Output of the {@link StandardConnectMethod}.\n *\n * @group Connect\n */\nexport interface StandardConnectOutput {\n    /** List of accounts in the {@link \"@wallet-standard/base\".Wallet} that the app has been authorized to use. */\n    readonly accounts: readonly WalletAccount[];\n}\n/**\n * @deprecated Use {@link StandardConnectOutput} instead.\n *\n * @group Deprecated\n */\nexport type ConnectOutput = StandardConnectOutput;\n", "/** Name of the feature. */\nexport const StandardDisconnect = 'standard:disconnect';\n/**\n * @deprecated Use {@link StandardDisconnect} instead.\n *\n * @group Deprecated\n */\nexport const Disconnect = StandardDisconnect;\n\n/**\n * `standard:disconnect` is a {@link \"@wallet-standard/base\".Wallet.features | feature} that may be implemented by a\n * {@link \"@wallet-standard/base\".Wallet} to allow the app to perform any cleanup work.\n *\n * This feature may or may not be used by the app and the Wallet should not depend on it being used.\n * If this feature is used by the app, the Wallet should perform any cleanup work, but should not revoke authorization\n * to use accounts previously granted through the {@link ConnectFeature}.\n *\n * @group Disconnect\n */\nexport type StandardDisconnectFeature = {\n    /** Name of the feature. */\n    readonly [StandardDisconnect]: {\n        /** Version of the feature implemented by the Wallet. */\n        readonly version: StandardDisconnectVersion;\n        /** Method to call to use the feature. */\n        readonly disconnect: StandardDisconnectMethod;\n    };\n};\n/**\n * @deprecated Use {@link StandardDisconnectFeature} instead.\n *\n * @group Deprecated\n */\nexport type DisconnectFeature = StandardDisconnectFeature;\n\n/**\n * Version of the {@link StandardDisconnectFeature} implemented by a Wallet.\n *\n * @group Disconnect\n */\nexport type StandardDisconnectVersion = '1.0.0';\n/**\n * @deprecated Use {@link StandardDisconnectVersion} instead.\n *\n * @group Deprecated\n */\nexport type DisconnectVersion = StandardDisconnectVersion;\n\n/**\n * Method to call to use the {@link StandardDisconnectFeature}.\n *\n * @group Disconnect\n */\nexport type StandardDisconnectMethod = () => Promise<void>;\n/**\n * @deprecated Use {@link StandardDisconnectMethod} instead.\n *\n * @group Deprecated\n */\nexport type DisconnectMethod = StandardDisconnectMethod;\n", "import type { Wallet } from '@wallet-standard/base';\n\n/** Name of the feature. */\nexport const StandardEvents = 'standard:events';\n/**\n * @deprecated Use {@link StandardEvents} instead.\n *\n * @group Deprecated\n */\nexport const Events = StandardEvents;\n\n/**\n * `standard:events` is a {@link \"@wallet-standard/base\".Wallet.features | feature} that may be implemented by a\n * {@link \"@wallet-standard/base\".Wallet} to allow the app to add an event listener and subscribe to events emitted by\n * the Wallet when properties of the Wallet {@link StandardEventsListeners.change}.\n *\n * @group Events\n */\nexport type StandardEventsFeature = {\n    /** Name of the feature. */\n    readonly [StandardEvents]: {\n        /** Version of the feature implemented by the {@link \"@wallet-standard/base\".Wallet}. */\n        readonly version: StandardEventsVersion;\n        /** Method to call to use the feature. */\n        readonly on: StandardEventsOnMethod;\n    };\n};\n/**\n * @deprecated Use {@link StandardEventsFeature} instead.\n *\n * @group Deprecated\n */\nexport type EventsFeature = StandardEventsFeature;\n\n/**\n * Version of the {@link StandardEventsFeature} implemented by a {@link \"@wallet-standard/base\".Wallet}.\n *\n * @group Events\n */\nexport type StandardEventsVersion = '1.0.0';\n/**\n * @deprecated Use {@link StandardEventsVersion} instead.\n *\n * @group Deprecated\n */\nexport type EventsVersion = StandardEventsVersion;\n\n/**\n * Method to call to use the {@link StandardEventsFeature}.\n *\n * @param event    Event type to listen for. {@link StandardEventsListeners.change | `change`} is the only event type.\n * @param listener Function that will be called when an event of the type is emitted.\n *\n * @return\n * `off` function which may be called to remove the event listener and unsubscribe from events.\n *\n * As with all event listeners, be careful to avoid memory leaks.\n *\n * @group Events\n */\nexport type StandardEventsOnMethod = <E extends StandardEventsNames>(\n    event: E,\n    listener: StandardEventsListeners[E]\n) => () => void;\n/**\n * @deprecated Use {@link StandardEventsOnMethod} instead.\n *\n * @group Deprecated\n */\nexport type EventsOnMethod = StandardEventsOnMethod;\n\n/**\n * Types of event listeners of the {@link StandardEventsFeature}.\n *\n * @group Events\n */\nexport interface StandardEventsListeners {\n    /**\n     * Listener that will be called when {@link StandardEventsChangeProperties | properties} of the\n     * {@link \"@wallet-standard/base\".Wallet} have changed.\n     *\n     * @param properties Properties that changed with their **new** values.\n     */\n    change(properties: StandardEventsChangeProperties): void;\n}\n/**\n * @deprecated Use {@link StandardEventsListeners} instead.\n *\n * @group Deprecated\n */\nexport type EventsListeners = StandardEventsListeners;\n\n/**\n * Names of {@link StandardEventsListeners} that can be listened for.\n *\n * @group Events\n */\nexport type StandardEventsNames = keyof StandardEventsListeners;\n/**\n * @deprecated Use {@link StandardEventsNames} instead.\n *\n * @group Deprecated\n */\nexport type EventsNames = StandardEventsNames;\n\n/**\n * Properties of a {@link \"@wallet-standard/base\".Wallet} that {@link StandardEventsListeners.change | changed} with their\n * **new** values.\n *\n * @group Events\n */\nexport interface StandardEventsChangeProperties {\n    /**\n     * {@link \"@wallet-standard/base\".Wallet.chains | Chains} supported by the Wallet.\n     *\n     * The Wallet should only define this field if the value of the property has changed.\n     *\n     * The value must be the **new** value of the property.\n     */\n    readonly chains?: Wallet['chains'];\n    /**\n     * {@link \"@wallet-standard/base\".Wallet.features | Features} supported by the Wallet.\n     *\n     * The Wallet should only define this field if the value of the property has changed.\n     *\n     * The value must be the **new** value of the property.\n     */\n    readonly features?: Wallet['features'];\n    /**\n     * {@link \"@wallet-standard/base\".Wallet.accounts | Accounts} that the app is authorized to use.\n     *\n     * The Wallet should only define this field if the value of the property has changed.\n     *\n     * The value must be the **new** value of the property.\n     */\n    readonly accounts?: Wallet['accounts'];\n}\n/**\n * @deprecated Use {@link StandardEventsChangeProperties} instead.\n *\n * @group Deprecated\n */\nexport type EventsChangeProperties = StandardEventsChangeProperties;\n", "import {\n    SolanaSignAndSendTransaction,\n    type SolanaSignAndSendTransactionFeature,\n    type SolanaSignInFeature,\n    type SolanaSignMessageFeature,\n    SolanaSignTransaction,\n    type SolanaSignTransactionFeature,\n} from '@solana/wallet-standard-features';\nimport type { Wallet as StandardWallet, WalletWithFeatures as StandardWalletWithFeatures } from '@wallet-standard/base';\nimport {\n    StandardConnect,\n    type StandardConnectFeature,\n    type StandardDisconnectFeature,\n    StandardEvents,\n    type StandardEventsFeature,\n} from '@wallet-standard/features';\nimport type { WalletAdapter, WalletAdapterProps } from './adapter.js';\n\nexport type WalletAdapterCompatibleStandardWallet = StandardWalletWithFeatures<\n    StandardConnectFeature &\n        StandardEventsFeature &\n        (SolanaSignAndSendTransactionFeature | SolanaSignTransactionFeature) &\n        (StandardDisconnectFeature | SolanaSignMessageFeature | SolanaSignInFeature | object)\n>;\n\nexport interface StandardWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    wallet: WalletAdapterCompatibleStandardWallet;\n    standard: true;\n}\n\nexport type StandardWalletAdapter<Name extends string = string> = WalletAdapter<Name> &\n    StandardWalletAdapterProps<Name>;\n\nexport function isWalletAdapterCompatibleStandardWallet(\n    wallet: StandardWallet\n): wallet is WalletAdapterCompatibleStandardWallet {\n    return (\n        StandardConnect in wallet.features &&\n        StandardEvents in wallet.features &&\n        (SolanaSignAndSendTransaction in wallet.features || SolanaSignTransaction in wallet.features)\n    );\n}\n", "import type { WalletAdapter } from './adapter.js';\nimport type { MessageSignerWalletAdapter, SignerWalletAdapter, SignInMessageSignerWalletAdapter } from './signer.js';\nimport type { StandardWalletAdapter } from './standard.js';\n\nexport type Adapter =\n    | WalletAdapter\n    | SignerWalletAdapter\n    | MessageSignerWalletAdapter\n    | SignInMessageSignerWalletAdapter\n    | StandardWalletAdapter;\n\nexport enum WalletAdapterNetwork {\n    Mainnet = 'mainnet-beta',\n    Testnet = 'testnet',\n    Devnet = 'devnet',\n}\n", null, null, null, null, null, null, null, null, null, "import type {\n    DEPRECATED_WalletsCallback,\n    DEPRECATED_WalletsWindow,\n    Wallet,\n    WalletEventsWindow,\n    WindowAppReadyEvent,\n    WindowAppReadyEventAPI,\n} from '@wallet-standard/base';\n\nlet wallets: Wallets | undefined = undefined;\nconst registeredWalletsSet = new Set<Wallet>();\nfunction addRegisteredWallet(wallet: Wallet) {\n    cachedWalletsArray = undefined;\n    registeredWalletsSet.add(wallet);\n}\nfunction removeRegisteredWallet(wallet: Wallet) {\n    cachedWalletsArray = undefined;\n    registeredWalletsSet.delete(wallet);\n}\nconst listeners: { [E in WalletsEventNames]?: WalletsEventsListeners[E][] } = {};\n\n/**\n * Get an API for {@link Wallets.get | getting}, {@link Wallets.on | listening for}, and\n * {@link Wallets.register | registering} {@link \"@wallet-standard/base\".Wallet | Wallets}.\n *\n * When called for the first time --\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowAppReadyEvent} to notify each Wallet that the app is ready\n * to register it.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to listen for a notification\n * from each Wallet that the Wallet is ready to be registered by the app.\n *\n * This combination of event dispatch and listener guarantees that each Wallet will be registered synchronously as soon\n * as the app is ready whether the app loads before or after each Wallet.\n *\n * @return API for getting, listening for, and registering Wallets.\n *\n * @group App\n */\nexport function getWallets(): Wallets {\n    if (wallets) return wallets;\n    wallets = Object.freeze({ register, get, on });\n    if (typeof window === 'undefined') return wallets;\n\n    const api = Object.freeze({ register });\n    try {\n        (window as WalletEventsWindow).addEventListener('wallet-standard:register-wallet', ({ detail: callback }) =>\n            callback(api)\n        );\n    } catch (error) {\n        console.error('wallet-standard:register-wallet event listener could not be added\\n', error);\n    }\n    try {\n        (window as WalletEventsWindow).dispatchEvent(new AppReadyEvent(api));\n    } catch (error) {\n        console.error('wallet-standard:app-ready event could not be dispatched\\n', error);\n    }\n\n    return wallets;\n}\n\n/**\n * API for {@link Wallets.get | getting}, {@link Wallets.on | listening for}, and\n * {@link Wallets.register | registering} {@link \"@wallet-standard/base\".Wallet | Wallets}.\n *\n * @group App\n */\nexport interface Wallets {\n    /**\n     * Get all Wallets that have been registered.\n     *\n     * @return Registered Wallets.\n     */\n    get(): readonly Wallet[];\n\n    /**\n     * Add an event listener and subscribe to events for Wallets that are\n     * {@link WalletsEventsListeners.register | registered} and\n     * {@link WalletsEventsListeners.unregister | unregistered}.\n     *\n     * @param event    Event type to listen for. {@link WalletsEventsListeners.register | `register`} and\n     * {@link WalletsEventsListeners.unregister | `unregister`} are the only event types.\n     * @param listener Function that will be called when an event of the type is emitted.\n     *\n     * @return\n     * `off` function which may be called to remove the event listener and unsubscribe from events.\n     *\n     * As with all event listeners, be careful to avoid memory leaks.\n     */\n    on<E extends WalletsEventNames>(event: E, listener: WalletsEventsListeners[E]): () => void;\n\n    /**\n     * Register Wallets. This can be used to programmatically wrap non-standard wallets as Standard Wallets.\n     *\n     * Apps generally do not need to, and should not, call this.\n     *\n     * @param wallets Wallets to register.\n     *\n     * @return\n     * `unregister` function which may be called to programmatically unregister the registered Wallets.\n     *\n     * Apps generally do not need to, and should not, call this.\n     */\n    register(...wallets: Wallet[]): () => void;\n}\n\n/**\n * Types of event listeners of the {@link Wallets} API.\n *\n * @group App\n */\nexport interface WalletsEventsListeners {\n    /**\n     * Emitted when Wallets are registered.\n     *\n     * @param wallets Wallets that were registered.\n     */\n    register(...wallets: Wallet[]): void;\n\n    /**\n     * Emitted when Wallets are unregistered.\n     *\n     * @param wallets Wallets that were unregistered.\n     */\n    unregister(...wallets: Wallet[]): void;\n}\n\n/**\n * Names of {@link WalletsEventsListeners} that can be listened for.\n *\n * @group App\n */\nexport type WalletsEventNames = keyof WalletsEventsListeners;\n\n/**\n * @deprecated Use {@link WalletsEventsListeners} instead.\n *\n * @group Deprecated\n */\nexport type WalletsEvents = WalletsEventsListeners;\n\nfunction register(...wallets: Wallet[]): () => void {\n    // Filter out wallets that have already been registered.\n    // This prevents the same wallet from being registered twice, but it also prevents wallets from being\n    // unregistered by reusing a reference to the wallet to obtain the unregister function for it.\n    wallets = wallets.filter((wallet) => !registeredWalletsSet.has(wallet));\n    // If there are no new wallets to register, just return a no-op unregister function.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    if (!wallets.length) return () => {};\n\n    wallets.forEach((wallet) => addRegisteredWallet(wallet));\n    listeners['register']?.forEach((listener) => guard(() => listener(...wallets)));\n    // Return a function that unregisters the registered wallets.\n    return function unregister(): void {\n        wallets.forEach((wallet) => removeRegisteredWallet(wallet));\n        listeners['unregister']?.forEach((listener) => guard(() => listener(...wallets)));\n    };\n}\n\nlet cachedWalletsArray: readonly Wallet[] | undefined;\nfunction get(): readonly Wallet[] {\n    if (!cachedWalletsArray) {\n        cachedWalletsArray = [...registeredWalletsSet];\n    }\n    return cachedWalletsArray;\n}\n\nfunction on<E extends WalletsEventNames>(event: E, listener: WalletsEventsListeners[E]): () => void {\n    listeners[event]?.push(listener) || (listeners[event] = [listener]);\n    // Return a function that removes the event listener.\n    return function off(): void {\n        listeners[event] = listeners[event]?.filter((existingListener) => listener !== existingListener);\n    };\n}\n\nfunction guard(callback: () => void) {\n    try {\n        callback();\n    } catch (error) {\n        console.error(error);\n    }\n}\n\nclass AppReadyEvent extends Event implements WindowAppReadyEvent {\n    readonly #detail: WindowAppReadyEventAPI;\n\n    get detail() {\n        return this.#detail;\n    }\n\n    get type() {\n        return 'wallet-standard:app-ready' as const;\n    }\n\n    constructor(api: WindowAppReadyEventAPI) {\n        super('wallet-standard:app-ready', {\n            bubbles: false,\n            cancelable: false,\n            composed: false,\n        });\n        this.#detail = api;\n    }\n\n    /** @deprecated */\n    preventDefault(): never {\n        throw new Error('preventDefault cannot be called');\n    }\n\n    /** @deprecated */\n    stopImmediatePropagation(): never {\n        throw new Error('stopImmediatePropagation cannot be called');\n    }\n\n    /** @deprecated */\n    stopPropagation(): never {\n        throw new Error('stopPropagation cannot be called');\n    }\n}\n\n/**\n * @deprecated Use {@link getWallets} instead.\n *\n * @group Deprecated\n */\nexport function DEPRECATED_getWallets(): Wallets {\n    if (wallets) return wallets;\n    wallets = getWallets();\n    if (typeof window === 'undefined') return wallets;\n\n    const callbacks = (window as DEPRECATED_WalletsWindow).navigator.wallets || [];\n    if (!Array.isArray(callbacks)) {\n        console.error('window.navigator.wallets is not an array');\n        return wallets;\n    }\n\n    const { register } = wallets;\n    const push = (...callbacks: DEPRECATED_WalletsCallback[]): void =>\n        callbacks.forEach((callback) => guard(() => callback({ register })));\n    try {\n        Object.defineProperty((window as DEPRECATED_WalletsWindow).navigator, 'wallets', {\n            value: Object.freeze({ push }),\n        });\n    } catch (error) {\n        console.error('window.navigator.wallets could not be set');\n        return wallets;\n    }\n\n    push(...callbacks);\n    return wallets;\n}\n", "import type { SolanaTransactionCommitment } from '@solana/wallet-standard-features';\n\n// Copied from @solana/web3.js\ntype Commitment = 'processed' | 'confirmed' | 'finalized' | 'recent' | 'single' | 'singleGossip' | 'root' | 'max';\n\n/**\n * TODO: docs\n */\nexport function getCommitment(commitment?: Commitment): SolanaTransactionCommitment | undefined {\n    switch (commitment) {\n        case 'processed':\n        case 'confirmed':\n        case 'finalized':\n        case undefined:\n            return commitment;\n        case 'recent':\n            return 'processed';\n        case 'single':\n        case 'singleGossip':\n            return 'confirmed';\n        case 'max':\n        case 'root':\n            return 'finalized';\n        default:\n            return undefined;\n    }\n}\n", "import type { SolanaSignInInput, SolanaSignInOutput } from '@solana/wallet-standard-features';\nimport { verifyMessageSignature } from './signMessage.js';\nimport { arraysEqual } from './util.js';\n\n/**\n * TODO: docs\n */\nexport function verifySignIn(input: SolanaSignInInput, output: SolanaSignInOutput): boolean {\n    const {\n        signedMessage,\n        signature,\n        account: { publicKey },\n    } = output;\n    const message = deriveSignInMessage(input, output);\n    return (\n        !!message && verifyMessageSignature({ message, signedMessage, signature, publicKey: publicKey as Uint8Array })\n    );\n}\n\n/**\n * TODO: docs\n */\nexport function deriveSignInMessage(input: SolanaSignInInput, output: SolanaSignInOutput): Uint8Array | null {\n    const text = deriveSignInMessageText(input, output);\n    if (!text) return null;\n    return new TextEncoder().encode(text);\n}\n\n/**\n * TODO: docs\n */\nexport function deriveSignInMessageText(input: SolanaSignInInput, output: SolanaSignInOutput): string | null {\n    const parsed = parseSignInMessage(output.signedMessage);\n    if (!parsed) return null;\n\n    if (input.domain && input.domain !== parsed.domain) return null;\n    if (input.address && input.address !== parsed.address) return null;\n    if (input.statement !== parsed.statement) return null;\n    if (input.uri !== parsed.uri) return null;\n    if (input.version !== parsed.version) return null;\n    if (input.chainId !== parsed.chainId) return null;\n    if (input.nonce !== parsed.nonce) return null;\n    if (input.issuedAt !== parsed.issuedAt) return null;\n    if (input.expirationTime !== parsed.expirationTime) return null;\n    if (input.notBefore !== parsed.notBefore) return null;\n    if (input.requestId !== parsed.requestId) return null;\n    if (input.resources) {\n        if (!parsed.resources) return null;\n        if (!arraysEqual(input.resources, parsed.resources)) return null;\n    } else if (parsed.resources) return null;\n\n    return createSignInMessageText(parsed);\n}\n\n/**\n * TODO: docs\n */\nexport type SolanaSignInInputWithRequiredFields = SolanaSignInInput &\n    Required<Pick<SolanaSignInInput, 'domain' | 'address'>>;\n\n/**\n * TODO: docs\n */\nexport function parseSignInMessage(message: Uint8Array): SolanaSignInInputWithRequiredFields | null {\n    const text = new TextDecoder().decode(message);\n    return parseSignInMessageText(text);\n}\n\n// TODO: implement https://github.com/solana-labs/solana/blob/master/docs/src/proposals/off-chain-message-signing.md\nconst DOMAIN = '(?<domain>[^\\\\n]+?) wants you to sign in with your Solana account:\\\\n';\nconst ADDRESS = '(?<address>[^\\\\n]+)(?:\\\\n|$)';\nconst STATEMENT = '(?:\\\\n(?<statement>[\\\\S\\\\s]*?)(?:\\\\n|$))??';\nconst URI = '(?:\\\\nURI: (?<uri>[^\\\\n]+))?';\nconst VERSION = '(?:\\\\nVersion: (?<version>[^\\\\n]+))?';\nconst CHAIN_ID = '(?:\\\\nChain ID: (?<chainId>[^\\\\n]+))?';\nconst NONCE = '(?:\\\\nNonce: (?<nonce>[^\\\\n]+))?';\nconst ISSUED_AT = '(?:\\\\nIssued At: (?<issuedAt>[^\\\\n]+))?';\nconst EXPIRATION_TIME = '(?:\\\\nExpiration Time: (?<expirationTime>[^\\\\n]+))?';\nconst NOT_BEFORE = '(?:\\\\nNot Before: (?<notBefore>[^\\\\n]+))?';\nconst REQUEST_ID = '(?:\\\\nRequest ID: (?<requestId>[^\\\\n]+))?';\nconst RESOURCES = '(?:\\\\nResources:(?<resources>(?:\\\\n- [^\\\\n]+)*))?';\nconst FIELDS = `${URI}${VERSION}${CHAIN_ID}${NONCE}${ISSUED_AT}${EXPIRATION_TIME}${NOT_BEFORE}${REQUEST_ID}${RESOURCES}`;\nconst MESSAGE = new RegExp(`^${DOMAIN}${ADDRESS}${STATEMENT}${FIELDS}\\\\n*$`);\n\n/**\n * TODO: docs\n */\nexport function parseSignInMessageText(text: string): SolanaSignInInputWithRequiredFields | null {\n    const match = MESSAGE.exec(text);\n    if (!match) return null;\n    const groups = match.groups;\n    if (!groups) return null;\n\n    return {\n        domain: groups.domain!,\n\n        address: groups.address!,\n        statement: groups.statement,\n        uri: groups.uri,\n        version: groups.version,\n        nonce: groups.nonce,\n        chainId: groups.chainId,\n        issuedAt: groups.issuedAt,\n        expirationTime: groups.expirationTime,\n        notBefore: groups.notBefore,\n        requestId: groups.requestId,\n        resources: groups.resources?.split('\\n- ').slice(1),\n    };\n}\n\n/**\n * TODO: docs\n */\nexport function createSignInMessage(input: SolanaSignInInputWithRequiredFields): Uint8Array {\n    const text = createSignInMessageText(input);\n    return new TextEncoder().encode(text);\n}\n\n/**\n * TODO: docs\n */\nexport function createSignInMessageText(input: SolanaSignInInputWithRequiredFields): string {\n    // ${domain} wants you to sign in with your Solana account:\n    // ${address}\n    //\n    // ${statement}\n    //\n    // URI: ${uri}\n    // Version: ${version}\n    // Chain ID: ${chain}\n    // Nonce: ${nonce}\n    // Issued At: ${issued-at}\n    // Expiration Time: ${expiration-time}\n    // Not Before: ${not-before}\n    // Request ID: ${request-id}\n    // Resources:\n    // - ${resources[0]}\n    // - ${resources[1]}\n    // ...\n    // - ${resources[n]}\n\n    let message = `${input.domain} wants you to sign in with your Solana account:\\n`;\n    message += `${input.address}`;\n\n    if (input.statement) {\n        message += `\\n\\n${input.statement}`;\n    }\n\n    const fields: string[] = [];\n    if (input.uri) {\n        fields.push(`URI: ${input.uri}`);\n    }\n    if (input.version) {\n        fields.push(`Version: ${input.version}`);\n    }\n    if (input.chainId) {\n        fields.push(`Chain ID: ${input.chainId}`);\n    }\n    if (input.nonce) {\n        fields.push(`Nonce: ${input.nonce}`);\n    }\n    if (input.issuedAt) {\n        fields.push(`Issued At: ${input.issuedAt}`);\n    }\n    if (input.expirationTime) {\n        fields.push(`Expiration Time: ${input.expirationTime}`);\n    }\n    if (input.notBefore) {\n        fields.push(`Not Before: ${input.notBefore}`);\n    }\n    if (input.requestId) {\n        fields.push(`Request ID: ${input.requestId}`);\n    }\n    if (input.resources) {\n        fields.push(`Resources:`);\n        for (const resource of input.resources) {\n            fields.push(`- ${resource}`);\n        }\n    }\n    if (fields.length) {\n        message += `\\n\\n${fields.join('\\n')}`;\n    }\n\n    return message;\n}\n", null, null, null, null],
  "mappings": "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",
  "names": ["i", "j", "string", "state", "offset", "SolanaError", "offset", "SolanaError", "Endian", "offset", "combineCodec", "generatePrivateKey", "ed25519", "utils", "randomPrivateKey", "generateKeypair", "privateScalar", "publicKey", "getPublicKey", "secretKey", "Uint8Array", "set", "isOnCurve", "ExtendedPoint", "fromHex", "sign", "message", "slice", "verify", "toBuffer", "arr", "Buffer", "isBuffer", "from", "buffer", "byteOffset", "byteLength", "Struct", "constructor", "properties", "Object", "assign", "encode", "serialize", "SOLANA_SCHEMA", "decode", "data", "deserialize", "decodeUnchecked", "deserializeUnchecked", "SOLANA_SCHEMA", "Map", "MAX_SEED_LENGTH", "PUBLIC_KEY_LENGTH", "isPublicKeyData", "value", "_bn", "undefined", "uniquePublicKeyCounter", "PublicKey", "Struct", "constructor", "decoded", "bs58", "decode", "length", "Error", "BN", "byteLength", "unique", "key", "toBuffer", "equals", "publicKey", "eq", "toBase58", "encode", "toBytes", "toJSON", "buf", "Uint8Array", "buffer", "byteOffset", "b", "toArrayLike", "Buffer", "zeroPad", "alloc", "copy", "Symbol", "toStringTag", "toString", "createWithSeed", "fromPublicKey", "seed", "programId", "concat", "from", "publicKeyBytes", "sha256", "createProgramAddressSync", "seeds", "forEach", "TypeError", "isOnCurve", "createProgramAddress", "findProgramAddressSync", "nonce", "address", "seedsWithNonce", "err", "findProgramAddress", "pubkeyData", "pubkey", "_PublicKey", "default", "set", "kind", "fields", "BPF_LOADER_DEPRECATED_PROGRAM_ID", "PublicKey", "PACKET_DATA_SIZE", "VERSION_PREFIX_MASK", "SIGNATURE_LENGTH_IN_BYTES", "TransactionExpiredBlockheightExceededError", "Error", "constructor", "signature", "Object", "defineProperty", "prototype", "value", "TransactionExpiredTimeoutError", "timeoutSeconds", "toFixed", "TransactionExpiredNonceInvalidError", "MessageAccountKeys", "staticAccountKeys", "accountKeysFromLookups", "keySegments", "push", "writable", "readonly", "get", "index", "keySegment", "length", "flat", "compileInstructions", "instructions", "U8_MAX", "keyIndexMap", "Map", "forEach", "key", "set", "toBase58", "findKeyIndex", "keyIndex", "undefined", "map", "instruction", "programIdIndex", "programId", "accountKeyIndexes", "keys", "meta", "pubkey", "data", "publicKey", "property", "blob", "rustString", "rsl", "struct", "u32", "offset", "_decode", "decode", "bind", "_encode", "encode", "rslShim", "b", "toString", "str", "chars", "Buffer", "from", "alloc", "span", "authorized", "lockup", "ns64", "voteInit", "u8", "voteAuthorizeWithSeedArgs", "getAlloc", "type", "fields", "getItemAlloc", "item", "field", "Array", "isArray", "elementLayout", "layout", "decodeLength", "bytes", "len", "size", "elem", "shift", "encodeLength", "rem_len", "assert", "condition", "message", "CompiledKeys", "payer", "keyMetaMap", "compile", "getOrInsertDefault", "address", "keyMeta", "isSigner", "isWritable", "isInvoked", "payerKeyMeta", "ix", "accountMeta", "getMessageComponents", "mapEntries", "entries", "writableSigners", "filter", "readonlySigners", "writableNonSigners", "readonlyNonSigners", "header", "numRequiredSignatures", "numReadonlySignedAccounts", "numReadonlyUnsignedAccounts", "payerAddress", "extractTableLookup", "lookupTable", "writableIndexes", "drainedWritableKeys", "drainKeysFoundInLookupTable", "state", "addresses", "readonlyIndexes", "drainedReadonlyKeys", "accountKey", "lookupTableEntries", "keyMetaFilter", "lookupTableIndexes", "drainedKeys", "lookupTableIndex", "findIndex", "entry", "equals", "delete", "END_OF_BUFFER_ERROR_MESSAGE", "guardedShift", "byteArray", "guardedSplice", "args", "start", "splice", "Message", "accountKeys", "recentBlockhash", "indexToProgramIds", "account", "version", "compiledInstructions", "accounts", "bs58", "addressTableLookups", "getAccountKeys", "compiledKeys", "payerKey", "isAccountSigner", "isAccountWritable", "numSignedAccounts", "unsignedAccountIndex", "numUnsignedAccounts", "numWritableUnsignedAccounts", "numWritableSignedAccounts", "isProgramId", "has", "programIds", "values", "nonProgramIds", "_", "serialize", "numKeys", "keyCount", "shortvec", "keyIndicesCount", "dataCount", "keyIndices", "dataLength", "instructionCount", "instructionBuffer", "copy", "instructionBufferLength", "instructionLayout", "seq", "slice", "signDataLayout", "Layout", "transaction", "toBuffer", "toBytes", "signData", "buffer", "accountCount", "i", "PUBLIC_KEY_LENGTH", "dataSlice", "messageArgs", "MessageV0", "numAccountKeysFromLookups", "count", "lookup", "addressLookupTableAccounts", "resolveAddressTableLookups", "numStaticAccountKeys", "lookupAccountKeysIndex", "numWritableLookupAccountKeys", "reduce", "tableLookup", "tableAccount", "find", "lookupTableAccounts", "extractResult", "addressTableLookup", "encodedStaticAccountKeysLength", "serializedInstructions", "serializeInstructions", "encodedInstructionsLength", "serializedAddressTableLookups", "serializeAddressTableLookups", "encodedAddressTableLookupsLength", "messageLayout", "serializedMessage", "Uint8Array", "MESSAGE_VERSION_0_PREFIX", "serializedMessageLength", "prefix", "staticAccountKeysLength", "instructionsLength", "addressTableLookupsLength", "serializedLength", "encodedAccountKeyIndexesLength", "encodedDataLength", "encodedWritableIndexesLength", "encodedReadonlyIndexesLength", "addressTableLookupLayout", "deserialize", "maskedPrefix", "accountKeyIndexesLength", "addressTableLookupsCount", "writableIndexesLength", "readonlyIndexesLength", "VersionedMessage", "deserializeMessageVersion", "TransactionStatus", "DEFAULT_SIGNATURE", "fill", "TransactionInstruction", "opts", "toJSON", "Transaction", "signatures", "feePayer", "lastValidBlockHeight", "nonceInfo", "minNonceContextSlot", "_message", "_json", "hasOwnProperty", "call", "minContextSlot", "blockhash", "nonce", "nonceInstruction", "signers", "add", "items", "concat", "compileMessage", "JSON", "stringify", "console", "warn", "accountMetas", "includes", "uniqueMetas", "pubkeyString", "uniqueIndex", "x", "sort", "y", "options", "localeMatcher", "usage", "sensitivity", "ignorePunctuation", "numeric", "caseFirst", "localeCompare", "feePayerIndex", "payerMeta", "unshift", "signedKeys", "unsignedKeys", "indexOf", "invariant", "_compile", "valid", "every", "pair", "serializeMessage", "getEstimatedFee", "connection", "getFeeForMessage", "setSigners", "seen", "Set", "sign", "uniqueSigners", "signer", "_partialSign", "partialSign", "secretKey", "_addSignature", "addSignature", "sigpair", "verifySignatures", "requireAllSignatures", "signatureErrors", "_getMessageSignednessErrors", "errors", "missing", "verify", "invalid", "config", "assign", "sigErrors", "errorMessage", "p", "join", "_serialize", "signatureCount", "transactionLength", "wireTransaction", "keyObj", "populate", "sigPubkeyPair", "some", "VersionedTransaction", "version", "message", "constructor", "signatures", "undefined", "assert", "length", "header", "numRequiredSignatures", "defaultSignatures", "i", "push", "Uint8Array", "SIGNATURE_LENGTH_IN_BYTES", "serialize", "serializedMessage", "encodedSignaturesLength", "Array", "shortvec", "transactionLayout", "struct", "blob", "seq", "Layout", "serializedTransaction", "serializedTransactionLength", "encode", "slice", "deserialize", "byteArray", "signaturesLength", "guardedSplice", "VersionedMessage", "sign", "signers", "messageData", "signerPubkeys", "staticAccountKeys", "signer", "signerIndex", "findIndex", "pubkey", "equals", "publicKey", "toBase58", "secretKey", "addSignature", "signature", "byteLength", "NUM_TICKS_PER_SECOND", "DEFAULT_TICKS_PER_SLOT", "NUM_SLOTS_PER_SECOND", "MS_PER_SLOT", "SYSVAR_CLOCK_PUBKEY", "PublicKey", "SYSVAR_EPOCH_SCHEDULE_PUBKEY", "SYSVAR_INSTRUCTIONS_PUBKEY", "SYSVAR_RECENT_BLOCKHASHES_PUBKEY", "SYSVAR_RENT_PUBKEY", "SYSVAR_REWARDS_PUBKEY", "SYSVAR_SLOT_HASHES_PUBKEY", "SYSVAR_SLOT_HISTORY_PUBKEY", "SYSVAR_STAKE_HISTORY_PUBKEY", "SendTransactionError", "Error", "action", "transactionMessage", "logs", "maybeLogsOutput", "JSON", "stringify", "guideText", "a", "transactionLogs", "transactionError", "isArray", "cachedLogs", "getLogs", "connection", "Promise", "resolve", "reject", "getTransaction", "then", "tx", "meta", "logMessages", "catch", "SolanaJSONRPCError", "Error", "constructor", "code", "message", "data", "customMessage", "name", "sendAndConfirmTransaction", "connection", "transaction", "signers", "options", "sendOptions", "skipPreflight", "preflightCommitment", "commitment", "maxRetries", "minContextSlot", "signature", "sendTransaction", "status", "recentBlockhash", "lastValidBlockHeight", "confirmTransaction", "abortSignal", "blockhash", "value", "minNonceContextSlot", "nonceInfo", "nonceInstruction", "nonceAccountPubkey", "keys", "pubkey", "nonceValue", "nonce", "console", "warn", "err", "SendTransactionError", "action", "transactionMessage", "JSON", "stringify", "sleep", "ms", "Promise", "resolve", "setTimeout", "encodeData", "type", "fields", "allocLength", "layout", "span", "Layout", "Buffer", "alloc", "layoutFields", "Object", "assign", "instruction", "index", "encode", "FeeCalculatorLayout", "nu64", "NonceAccountLayout", "struct", "u32", "Layout", "NONCE_ACCOUNT_LENGTH", "span", "NonceAccount", "constructor", "args", "authorizedPubkey", "nonce", "feeCalculator", "fromAccountData", "buffer", "nonceAccount", "decode", "toBuffer", "PublicKey", "toString", "u64", "property", "layout", "blob", "bind", "encode", "bigIntLayout", "codec", "getU64Codec", "offset", "src", "bigInt", "SYSTEM_INSTRUCTION_LAYOUTS", "Object", "freeze", "Create", "index", "layout", "struct", "u32", "ns64", "Layout", "Assign", "Transfer", "u64", "CreateWithSeed", "AdvanceNonceAccount", "WithdrawNonceAccount", "InitializeNonceAccount", "AuthorizeNonceAccount", "Allocate", "AllocateWithSeed", "AssignWithSeed", "TransferWithSeed", "UpgradeNonceAccount", "SystemProgram", "constructor", "createAccount", "params", "type", "data", "encodeData", "lamports", "space", "programId", "toBuffer", "TransactionInstruction", "keys", "pubkey", "fromPubkey", "isSigner", "isWritable", "newAccountPubkey", "transfer", "BigInt", "seed", "basePubkey", "toPubkey", "assign", "base", "accountPubkey", "createAccountWithSeed", "equals", "push", "createNonceAccount", "transaction", "Transaction", "add", "noncePubkey", "NONCE_ACCOUNT_LENGTH", "initParams", "authorizedPubkey", "nonceInitialize", "authorized", "instructionData", "SYSVAR_RECENT_BLOCKHASHES_PUBKEY", "SYSVAR_RENT_PUBKEY", "nonceAdvance", "nonceWithdraw", "nonceAuthorize", "newAuthorizedPubkey", "allocate", "PublicKey", "CHUNK_SIZE", "PACKET_DATA_SIZE", "Loader", "getMinNumSignatures", "dataLength", "Math", "ceil", "chunkSize", "load", "connection", "payer", "program", "balanceNeeded", "getMinimumBalanceForRentExemption", "length", "programInfo", "getAccountInfo", "publicKey", "executable", "console", "error", "owner", "sendAndConfirmTransaction", "commitment", "dataLayout", "seq", "u8", "offset", "array", "transactions", "bytes", "slice", "Buffer", "alloc", "encode", "instruction", "bytesLength", "bytesLengthPadding", "_rpcEndpoint", "includes", "REQUESTS_PER_SECOND", "sleep", "Promise", "all", "span", "deployCommitment", "finalizeSignature", "sendTransaction", "preflightCommitment", "context", "value", "confirmTransaction", "signature", "lastValidBlockHeight", "blockhash", "recentBlockhash", "err", "Error", "JSON", "stringify", "currentSlot", "getSlot", "slot", "resolve", "setTimeout", "round", "MS_PER_SLOT", "BPF_LOADER_PROGRAM_ID", "fastStableStringify", "MINIMUM_SLOT_PER_EPOCH", "trailingZeros", "n", "nextPowerOfTwo", "EpochSchedule", "constructor", "slotsPerEpoch", "leaderScheduleSlotOffset", "warmup", "firstNormalEpoch", "firstNormalSlot", "getEpoch", "slot", "getEpochAndSlotIndex", "epoch", "epochLen", "getSlotsInEpoch", "slotIndex", "normalSlotIndex", "normalEpochIndex", "Math", "floor", "getFirstSlotInEpoch", "pow", "getLastSlotInEpoch", "globalThis", "fetch", "RpcWebSocketClient", "CommonClient", "address", "options", "generate_request_id", "webSocketFactory", "url", "rpc", "createRpc", "autoconnect", "max_reconnects", "reconnect", "reconnect_interval", "underlyingSocket", "socket", "call", "args", "readyState", "Promise", "reject", "Error", "notify", "decodeData", "type", "data", "decoded", "layout", "decode", "err", "typeIndex", "index", "LOOKUP_TABLE_META_SIZE", "AddressLookupTableAccount", "key", "state", "isActive", "U64_MAX", "BigInt", "deactivationSlot", "deserialize", "accountData", "meta", "LookupTableMetaLayout", "serializedAddressesLen", "length", "assert", "numSerializedAddresses", "addresses", "struct", "seq", "Layout", "slice", "lastExtendedSlot", "lastExtendedSlotStartIndex", "lastExtendedStartIndex", "authority", "PublicKey", "undefined", "map", "u32", "u64", "nu64", "u8", "offset", "URL_RE", "makeWebsocketUrl", "endpoint", "matches", "match", "TypeError", "_", "hostish", "portWithColon", "rest", "protocol", "startsWith", "startPort", "parseInt", "websocketPort", "PublicKeyFromString", "coerce", "instance", "string", "value", "RawAccountDataResult", "tuple", "literal", "BufferFromRawAccountData", "Buffer", "from", "BLOCKHASH_CACHE_TIMEOUT_MS", "assertEndpointUrl", "putativeUrl", "test", "extractCommitmentFromConfig", "commitmentOrConfig", "commitment", "config", "specifiedCommitment", "specifiedConfig", "applyDefaultMemcmpEncodingToFilters", "filters", "filter", "memcmp", "encoding", "createRpcResult", "result", "union", "pick", "jsonrpc", "id", "error", "code", "unknown", "message", "optional", "any", "UnknownRpcResult", "jsonRpcResult", "schema", "create", "jsonRpcResultAndContext", "context", "number", "notificationResultAndContext", "versionedMessageFromResponse", "version", "response", "MessageV0", "header", "staticAccountKeys", "accountKeys", "accountKey", "recentBlockhash", "compiledInstructions", "instructions", "ix", "programIdIndex", "accountKeyIndexes", "accounts", "bs58", "addressTableLookups", "Message", "GetInflationGovernorResult", "foundation", "foundationTerm", "initial", "taper", "terminal", "GetInflationRewardResult", "array", "nullable", "effectiveSlot", "amount", "postBalance", "commission", "GetRecentPrioritizationFeesResult", "prioritizationFee", "GetInflationRateResult", "total", "validator", "GetEpochInfoResult", "slotsInEpoch", "absoluteSlot", "blockHeight", "transactionCount", "GetEpochScheduleResult", "boolean", "GetLeaderScheduleResult", "record", "TransactionErrorResult", "SignatureStatusResult", "SignatureReceivedResult", "VersionResult", "ParsedInstructionStruct", "program", "programId", "parsed", "PartiallyDecodedInstructionStruct", "SimulatedTransactionResponseStruct", "logs", "executable", "owner", "lamports", "rentEpoch", "unitsConsumed", "returnData", "innerInstructions", "BlockProductionResponseStruct", "byIdentity", "range", "firstSlot", "lastSlot", "createRpcClient", "httpHeaders", "customFetch", "fetchMiddleware", "disableRetryOnRateLimit", "httpAgent", "fetchImpl", "agent", "console", "warn", "fetchWithMiddleware", "info", "init", "modifiedFetchArgs", "resolve", "modifiedInfo", "modifiedInit", "clientBrowser", "RpcClient", "request", "callback", "method", "body", "headers", "Object", "assign", "COMMON_HTTP_HEADERS", "too_many_requests_retries", "res", "waitTime", "status", "statusText", "sleep", "text", "ok", "createRpcRequest", "client", "createRpcBatchRequest", "requests", "batch", "params", "methodName", "GetInflationGovernorRpcResult", "GetInflationRateRpcResult", "GetRecentPrioritizationFeesRpcResult", "GetEpochInfoRpcResult", "GetEpochScheduleRpcResult", "GetLeaderScheduleRpcResult", "SlotRpcResult", "GetSupplyRpcResult", "circulating", "nonCirculating", "nonCirculatingAccounts", "TokenAmountResult", "uiAmount", "decimals", "uiAmountString", "GetTokenLargestAccountsResult", "GetTokenAccountsByOwner", "pubkey", "account", "ParsedAccountDataResult", "space", "GetParsedTokenAccountsByOwner", "GetLargestAccountsRpcResult", "AccountInfoResult", "KeyedAccountInfoResult", "ParsedOrRawAccountData", "Array", "isArray", "ParsedAccountInfoResult", "KeyedParsedAccountInfoResult", "StakeActivationResult", "active", "inactive", "GetConfirmedSignaturesForAddress2RpcResult", "signature", "memo", "blockTime", "GetSignaturesForAddressRpcResult", "AccountNotificationResult", "subscription", "ProgramAccountInfoResult", "ProgramAccountNotificationResult", "SlotInfoResult", "parent", "root", "SlotNotificationResult", "SlotUpdateResult", "timestamp", "stats", "numTransactionEntries", "numSuccessfulTransactions", "numFailedTransactions", "maxTransactionsPerEntry", "SlotUpdateNotificationResult", "SignatureNotificationResult", "RootNotificationResult", "ContactInfoResult", "gossip", "tpu", "VoteAccountInfoResult", "votePubkey", "nodePubkey", "activatedStake", "epochVoteAccount", "epochCredits", "lastVote", "rootSlot", "GetVoteAccounts", "current", "delinquent", "ConfirmationStatus", "SignatureStatusResponse", "confirmations", "confirmationStatus", "GetSignatureStatusesRpcResult", "GetMinimumBalanceForRentExemptionRpcResult", "AddressTableLookupStruct", "writableIndexes", "readonlyIndexes", "ConfirmedTransactionResult", "signatures", "numRequiredSignatures", "numReadonlySignedAccounts", "numReadonlyUnsignedAccounts", "AnnotatedAccountKey", "signer", "writable", "source", "ConfirmedTransactionAccountsModeResult", "ParsedInstructionResult", "RawInstructionResult", "InstructionResult", "UnknownInstructionResult", "ParsedOrRawInstruction", "ParsedConfirmedTransactionResult", "TokenBalanceResult", "accountIndex", "mint", "uiTokenAmount", "LoadedAddressesResult", "readonly", "ConfirmedTransactionMetaResult", "fee", "preBalances", "postBalances", "logMessages", "preTokenBalances", "postTokenBalances", "loadedAddresses", "computeUnitsConsumed", "ParsedConfirmedTransactionMetaResult", "TransactionVersionStruct", "RewardsResult", "rewardType", "GetBlockRpcResult", "blockhash", "previousBlockhash", "parentSlot", "transactions", "transaction", "rewards", "GetNoneModeBlockRpcResult", "GetAccountsModeBlockRpcResult", "GetParsedBlockRpcResult", "GetParsedAccountsModeBlockRpcResult", "GetParsedNoneModeBlockRpcResult", "GetConfirmedBlockRpcResult", "GetBlockSignaturesRpcResult", "GetTransactionRpcResult", "GetParsedTransactionRpcResult", "GetLatestBlockhashRpcResult", "lastValidBlockHeight", "IsBlockhashValidRpcResult", "PerfSampleResult", "numTransactions", "numSlots", "samplePeriodSecs", "GetRecentPerformanceSamplesRpcResult", "GetFeeCalculatorRpcResult", "feeCalculator", "lamportsPerSignature", "RequestAirdropRpcResult", "SendTransactionRpcResult", "LogsResult", "LogsNotificationResult", "process", "Connection", "_commitment", "_confirmTransactionInitialTimeout", "_rpcEndpoint", "_rpcWsEndpoint", "_rpcClient", "_rpcRequest", "_rpcBatchRequest", "_rpcWebSocket", "_rpcWebSocketConnected", "_rpcWebSocketHeartbeat", "_rpcWebSocketIdleTimeout", "_rpcWebSocketGeneration", "_disableBlockhashCaching", "_pollingBlockhash", "_blockhashInfo", "latestBlockhash", "lastFetch", "transactionSignatures", "simulatedSignatures", "_nextClientSubscriptionId", "_subscriptionDisposeFunctionsByClientSubscriptionId", "_subscriptionHashByClientSubscriptionId", "_subscriptionStateChangeCallbacksByHash", "_subscriptionCallbacksByServerSubscriptionId", "_subscriptionsByHash", "_subscriptionsAutoDisposedByRpc", "Set", "getBlockHeight", "requestPromises", "_buildArgs", "requestHash", "unsafeRes", "SolanaJSONRPCError", "wsEndpoint", "confirmTransactionInitialTimeout", "Infinity", "on", "_wsOnOpen", "bind", "_wsOnError", "_wsOnClose", "_wsOnAccountNotification", "_wsOnProgramAccountNotification", "_wsOnSlotNotification", "_wsOnSlotUpdatesNotification", "_wsOnSignatureNotification", "_wsOnRootNotification", "_wsOnLogsNotification", "rpcEndpoint", "getBalanceAndContext", "publicKey", "toBase58", "getBalance", "then", "x", "catch", "e", "getBlockTime", "getMinimumLedgerSlot", "getFirstAvailableBlock", "getSupply", "configArg", "getTokenSupply", "tokenMintAddress", "getTokenAccountBalance", "tokenAddress", "getTokenAccountsByOwner", "ownerAddress", "_args", "push", "getParsedTokenAccountsByOwner", "getLargestAccounts", "arg", "getTokenLargestAccounts", "mintAddress", "getAccountInfoAndContext", "getParsedAccountInfo", "getAccountInfo", "getMultipleParsedAccounts", "publicKeys", "rawConfig", "keys", "getMultipleAccountsInfoAndContext", "getMultipleAccountsInfo", "getStakeActivation", "getProgramAccounts", "configOrCommitment", "configWithoutEncoding", "baseSchema", "withContext", "getParsedProgramAccounts", "confirmTransaction", "strategy", "rawSignature", "abortSignal", "aborted", "reason", "decodedSignature", "confirmTransactionUsingLegacyTimeoutStrategy", "confirmTransactionUsingBlockHeightExceedanceStrategy", "confirmTransactionUsingDurableNonceStrategy", "getCancellationPromise", "signal", "addEventListener", "getTransactionConfirmationPromise", "signatureSubscriptionId", "disposeSignatureSubscriptionStateChangeObserver", "done", "confirmationPromise", "onSignature", "__type", "TransactionStatus", "PROCESSED", "subscriptionSetupPromise", "resolveSubscriptionSetup", "_onSubscriptionStateChange", "nextState", "getSignatureStatus", "abortConfirmation", "removeSignatureListener", "expiryPromise", "checkBlockHeight", "_e", "currentBlockHeight", "BLOCKHEIGHT_EXCEEDED", "cancellationPromise", "outcome", "race", "TransactionExpiredBlockheightExceededError", "minContextSlot", "nonceAccountPubkey", "nonceValue", "currentNonceValue", "lastCheckedSlot", "getCurrentNonceValue", "nonceAccount", "getNonceAndContext", "nonce", "NONCE_INVALID", "slotInWhichNonceDidAdvance", "signatureStatus", "commitmentForStatus", "TransactionExpiredNonceInvalidError", "timeoutId", "timeoutMs", "setTimeout", "TIMED_OUT", "TransactionExpiredTimeoutError", "clearTimeout", "getClusterNodes", "getVoteAccounts", "getSlot", "getSlotLeader", "getSlotLeaders", "startSlot", "limit", "values", "getSignatureStatuses", "getTransactionCount", "getTotalSupply", "excludeNonCirculatingAccountsList", "getInflationGovernor", "getInflationReward", "getInflationRate", "getEpochInfo", "getEpochSchedule", "epochSchedule", "getLeaderSchedule", "getMinimumBalanceForRentExemption", "dataLength", "getRecentBlockhashAndContext", "getLatestBlockhashAndContext", "toJSON", "getRecentPerformanceSamples", "getFeeCalculatorForBlockhash", "getFeeForMessage", "wireMessage", "toBuffer", "serialize", "toString", "getRecentPrioritizationFees", "lockedWritableAccounts", "getRecentBlockhash", "getLatestBlockhash", "isBlockhashValid", "getVersion", "getGenesisHash", "getBlock", "_buildArgsAtLeastConfirmed", "transactionDetails", "getParsedBlock", "getBlockProduction", "extra", "c", "getTransaction", "getParsedTransaction", "getParsedTransactions", "getTransactions", "getConfirmedBlock", "block", "Transaction", "populate", "getBlocks", "endSlot", "getBlockSignatures", "getConfirmedBlockSignatures", "getConfirmedTransaction", "getParsedConfirmedTransaction", "getParsedConfirmedTransactions", "getConfirmedSignaturesForAddress", "firstAvailableBlock", "until", "includes", "highestConfirmedRoot", "before", "confirmedSignatureInfo", "getConfirmedSignaturesForAddress2", "getSignaturesForAddress", "getAddressLookupTable", "accountInfo", "NonceAccount", "fromAccountData", "getNonce", "requestAirdrop", "to", "_blockhashWithExpiryBlockHeight", "disableCache", "timeSinceFetch", "Date", "now", "expired", "_pollNewBlockhash", "startTime", "cachedLatestBlockhash", "cachedBlockhash", "i", "MS_PER_SLOT", "getStakeMinimumDelegation", "simulateTransaction", "transactionOrMessage", "configOrSigners", "includeAccounts", "versionedTx", "wireTransaction", "encodedTransaction", "originalTx", "feePayer", "nonceInfo", "_message", "_json", "signers", "sign", "_compile", "signData", "_serialize", "nonProgramIds", "sigVerify", "traceIndent", "logTrace", "join", "SendTransactionError", "action", "transactionMessage", "sendTransaction", "signersOrOptions", "sendRawTransaction", "rawTransaction", "sendEncodedTransaction", "skipPreflight", "preflightCommitment", "maxRetries", "setInterval", "_updateSubscriptions", "Number", "MAX_SAFE_INTEGER", "clearInterval", "entries", "forEach", "hash", "_setSubscription", "nextSubscription", "prevState", "stateChangeCallbacks", "cb", "clientSubscriptionId", "add", "delete", "size", "close", "log", "connect", "activeWebSocketGeneration", "isCurrentConnectionStillActive", "all", "callbacks", "serverSubscriptionId", "unsubscribeMethod", "has", "_handleServerNotification", "callbackArgs", "notification", "_makeSubscription", "subscriptionConfig", "existingSubscription", "onAccountChange", "removeAccountChangeListener", "_unsubscribeClientSubscription", "accountId", "onProgramAccountChange", "maybeFilters", "removeProgramAccountChangeListener", "onLogs", "mentions", "removeOnLogsListener", "onSlotChange", "removeSlotChangeListener", "onSlotUpdate", "removeSlotUpdateListener", "subscriptionName", "dispose", "override", "_err", "onSignatureWithOptions", "onRootChange", "removeRootChangeListener", "Keypair", "keypair", "_keypair", "generateKeypair", "generate", "fromSecretKey", "secretKey", "byteLength", "skipValidation", "privateScalar", "computedPublicKey", "getPublicKey", "ii", "fromSeed", "seed", "Uint8Array", "set", "LOOKUP_TABLE_INSTRUCTION_LAYOUTS", "freeze", "CreateLookupTable", "bigintLayout", "FreezeLookupTable", "ExtendLookupTable", "DeactivateLookupTable", "CloseLookupTable", "AddressLookupTableProgram", "constructor", "createLookupTable", "params", "lookupTableAddress", "bumpSeed", "PublicKey", "findProgramAddressSync", "authority", "toBuffer", "getU64Encoder", "encode", "recentSlot", "programId", "type", "LOOKUP_TABLE_INSTRUCTION_LAYOUTS", "CreateLookupTable", "data", "encodeData", "BigInt", "keys", "pubkey", "isSigner", "isWritable", "payer", "SystemProgram", "TransactionInstruction", "freezeLookupTable", "FreezeLookupTable", "lookupTable", "extendLookupTable", "ExtendLookupTable", "addresses", "map", "addr", "toBytes", "push", "deactivateLookupTable", "DeactivateLookupTable", "closeLookupTable", "CloseLookupTable", "recipient", "COMPUTE_BUDGET_INSTRUCTION_LAYOUTS", "Object", "freeze", "RequestUnits", "index", "layout", "struct", "u8", "u32", "RequestHeapFrame", "SetComputeUnitLimit", "SetComputeUnitPrice", "u64", "ComputeBudgetProgram", "constructor", "requestUnits", "params", "type", "data", "encodeData", "TransactionInstruction", "keys", "programId", "requestHeapFrame", "setComputeUnitLimit", "setComputeUnitPrice", "microLamports", "BigInt", "PublicKey", "PRIVATE_KEY_BYTES", "PUBLIC_KEY_BYTES", "SIGNATURE_BYTES", "ED25519_INSTRUCTION_LAYOUT", "u16", "Ed25519Program", "createInstructionWithPublicKey", "publicKey", "message", "signature", "instructionIndex", "assert", "length", "publicKeyOffset", "span", "signatureOffset", "messageDataOffset", "numSignatures", "instructionData", "Buffer", "alloc", "encode", "padding", "signatureInstructionIndex", "publicKeyInstructionIndex", "messageDataSize", "messageInstructionIndex", "fill", "createInstructionWithPrivateKey", "privateKey", "keypair", "Keypair", "fromSecretKey", "toBytes", "sign", "secretKey", "error", "Error", "ecdsaSign", "msgHash", "privKey", "secp256k1", "toCompactRawBytes", "recovery", "utils", "isValidPrivateKey", "publicKeyCreate", "getPublicKey", "ETHEREUM_ADDRESS_BYTES", "SIGNATURE_OFFSETS_SERIALIZED_SIZE", "SECP256K1_INSTRUCTION_LAYOUT", "blob", "Secp256k1Program", "publicKeyToEthAddress", "from", "keccak_256", "toBuffer", "slice", "recoveryId", "createInstructionWithEthAddress", "ethAddress", "rawAddress", "startsWith", "substr", "dataStart", "ethAddressOffset", "ethAddressInstructionIndex", "pkey", "messageHash", "STAKE_CONFIG_ID", "Lockup", "constructor", "unixTimestamp", "epoch", "custodian", "_Lockup", "default", "PublicKey", "STAKE_INSTRUCTION_LAYOUTS", "Object", "freeze", "Initialize", "index", "layout", "struct", "u32", "Layout", "Authorize", "Delegate", "Split", "ns64", "Withdraw", "Deactivate", "Merge", "AuthorizeWithSeed", "StakeAuthorizationLayout", "Staker", "Withdrawer", "StakeProgram", "constructor", "initialize", "params", "stakePubkey", "authorized", "lockup", "maybeLockup", "Lockup", "default", "type", "data", "encodeData", "staker", "toBuffer", "withdrawer", "unixTimestamp", "epoch", "custodian", "instructionData", "keys", "pubkey", "isSigner", "isWritable", "SYSVAR_RENT_PUBKEY", "programId", "TransactionInstruction", "createAccountWithSeed", "transaction", "Transaction", "add", "SystemProgram", "fromPubkey", "newAccountPubkey", "basePubkey", "seed", "lamports", "space", "createAccount", "delegate", "authorizedPubkey", "votePubkey", "SYSVAR_CLOCK_PUBKEY", "SYSVAR_STAKE_HISTORY_PUBKEY", "STAKE_CONFIG_ID", "authorize", "newAuthorizedPubkey", "stakeAuthorizationType", "custodianPubkey", "newAuthorized", "push", "authorizeWithSeed", "authorityBase", "authoritySeed", "authorityOwner", "splitInstruction", "splitStakePubkey", "split", "rentExemptReserve", "splitWithSeed", "allocate", "accountPubkey", "transfer", "toPubkey", "merge", "sourceStakePubKey", "withdraw", "deactivate", "PublicKey", "VOTE_INSTRUCTION_LAYOUTS", "Object", "freeze", "InitializeAccount", "index", "layout", "struct", "u32", "Layout", "Authorize", "Withdraw", "ns64", "UpdateValidatorIdentity", "AuthorizeWithSeed", "VoteAuthorizationLayout", "Voter", "Withdrawer", "VoteProgram", "constructor", "initializeAccount", "params", "votePubkey", "nodePubkey", "voteInit", "type", "data", "encodeData", "toBuffer", "authorizedVoter", "authorizedWithdrawer", "commission", "instructionData", "keys", "pubkey", "isSigner", "isWritable", "SYSVAR_RENT_PUBKEY", "SYSVAR_CLOCK_PUBKEY", "programId", "TransactionInstruction", "createAccount", "transaction", "Transaction", "add", "SystemProgram", "fromPubkey", "newAccountPubkey", "lamports", "space", "authorize", "authorizedPubkey", "newAuthorizedPubkey", "voteAuthorizationType", "newAuthorized", "authorizeWithSeed", "currentAuthorityDerivedKeyBasePubkey", "currentAuthorityDerivedKeyOwnerPubkey", "currentAuthorityDerivedKeySeed", "voteAuthorizeWithSeedArgs", "withdraw", "authorizedWithdrawerPubkey", "toPubkey", "safeWithdraw", "currentVoteAccountBalance", "rentExemptMinimum", "Error", "updateValidatorIdentity", "PublicKey", "VALIDATOR_INFO_KEY", "InfoString", "pick", "name", "string", "website", "optional", "details", "iconUrl", "keybaseUsername", "VOTE_PROGRAM_ID", "PublicKey", "VoteAccountLayout", "struct", "Layout", "u8", "nu64", "seq", "u32", "offset", "LAMPORTS_PER_SOL", "WalletReadyState", "WalletAdapterNetwork", "signature", "signature", "signature", "wallets", "__classPrivateFieldGet", "publicKey", "signature", "get", "on", "listeners", "wallets", "signature", "publicKey"]
}
